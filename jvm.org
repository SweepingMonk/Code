* 深入理解java虚拟机
** jvm对锁进行的优化
1. 自旋锁和自适应自旋
2. 锁消除
3. 锁粗化
4. 轻量级锁
5. 偏向锁

其中，自旋锁，是指线程在等待一个锁的时候，不放弃cpu时间，而是在忙等。这个功能是有缺点的，比如说，等待时间过长，那么自旋只会白白浪费cpu时间。如果等待时间很短，那么自旋倒是很有价值。

自适应自旋锁于是诞生了。如果上一次自旋成功了，那么自适应自旋锁会认为下一次等待也应该会成功，于是可以适当的放宽自旋的等待时间。如果之前一直自旋失败，那么会省掉这个自旋过程，直接进入线程挂起。

锁消除是指，根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁比如说String a="a"+"b"，这段代码中其实是有锁的【想想StringBuffer】，但是编译器把锁给优化掉了。

锁粗化，什么是粗化？？比如说String a="a"+"b"+"c"，这里其实是有多个锁操作的。但是在同一个函数里面，是没有代码竞争的，根本就没有必要进行锁操作。于是，编译器就可以优化掉这部分锁操作。

轻量级锁，是JDK1.6新增的锁机制。这里的轻量级是针对需要操作系统互斥量来实现的传统锁而言的。因此传统的锁被称作是“重量级锁”。轻量级锁并不是用来取代重量级锁的，他的本意是在没有多线程竞争的情况下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗。

偏向锁，也是1.6才引入的一项锁优化。目的是为了消除数据在无竞争的情况下
的同步原语。进一步提高程序的性能。偏向锁就是“偏袒”第一个获得这个锁的
线程，如果在接下来的执行过程中，该锁没有被其他线程获取，那么该线程将永
远不需要再次进行同步。但是当另外一个线程尝试获取该锁的时候，偏向模式宣
告结束。根据锁定对象的当前状态，撤销偏向后恢复到未锁定状态或者是进入轻
量级锁定状态。可以看出，如果程序中大多数的锁都是被多个线程所访问的，那
么偏向锁就是多余的。
** JIT just in time
正常情况下java程序的执行过程是，java编译器将java文件编译成class字节码
文件，然后由java虚拟机解释执行这些字节码文件。

JIT是一种动态编译技术，它把字节码文件直接转换为本地机器代码执行，大大
提高了java程序的执行速度，Android 2.2版本中加入了jit技术之后程序执行速
度是原来的4-5倍。

** 多核并行
Fork/join模式是处理并行编程的一种经典方法，目前Apache的Hadoop
Map/Reduce,是一个简单易行的并行框架

** 运行时数据区
java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域
主要包括方法区、堆区、虚拟机栈、本地方法栈、程序计数器
其中方法区和堆区为进程的所有子线程共享，其它的为线程独有

#程序计数器

程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。每个线程都有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，是线程私有内存

#Java虚拟机栈和本地方法栈

本地方法栈和虚拟机栈所发挥的作用是非常相似的，区别是虚拟机栈执行java方法，而本地方法栈则为虚拟机使用的Native方法服务，在sun hotspot中已经把两者合二为一了，本地方法栈区也会抛出StackOverFlowError和OutOfMemeoryError异常

#Java堆

java堆是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，几乎所有对象的实例都在这分配内存。

#方法区

方法区和java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量。即时编译器编译后的代码等数据。

#运行时常量池

运行时常量池是方法区的一部分。用于存放编译器生成的各种字面量和符号引用，它同样也受到方法去内存的限制，当常量池无法在申请到内存的时候会抛出OutOfMemoryError异常

#直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。

OutOfMemoryErrot异常

#java堆溢出

Java堆用于储存对象实例，只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆的容量限制后产生内存溢出异常。

#虚拟机和本地方法栈溢出

#运行时常量池溢出

 如果要向运行时常量池添加内容，最简单的方法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含了一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区，因此可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小间接限制其中常量池中的容量。

#方法区溢出

#本地直接内存溢出

DirectMemory容量可通过参数指定，如果不指定则默认和Java堆的最大值一样

** Java的垃圾收集算法和垃圾收集器

垃圾收集算法

虚拟机是如何判断一个对象已经死去呢？大部分人都回答是引用计数算法。
1. 引用计数算法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引
用失效时，计数器值就减1，任何时刻计数器值为0的对象就是不可能再被使用的。
引用计数法的实现简单，判定效率比较高，但是java中并没有选择引用计数法来
管理内存，其中主要的原因是它很难解决对象之间的相互循环引用问题。
objA.instance=objB;objB.instance=objA;除此之外，这两个对象再无任何引用，
实际上这两个对象已经不可能再被访问，但是它们相互引用，引用计数器无法通
知GC收集器回收它们。

2. 根搜索算法
java c#以及Lisp都是使用根搜索算法判定对象是否存活的。这个算法的基本思
路就是通过一系列的名为GC Roots的对象作为起始点，从这些节点开始向下搜索，
搜索所走过的路径就称为引用链。当一个对象到引用链没有对象相连时，则证明
此对象是不可用的。

*对象的死亡历程*
当一个对象从GC Roots不可达以后，就可以被回收了，如果类覆盖了finalize方
法，就有可能会执行finalize，正常情况下执行完毕后，就面临真正的垃圾回收，
如果在finalize方法中，将对象本身赋值给另外一个变量，那就可以逃脱垃圾回
收的命运，但是请注意，finalize方法只能调用一次，下一次这个对象再面临垃
圾回收的时候就不会再调用finalize方法了。

但是finalize方法中的工作不确定性太大，代价高昂，不鼓励使用这个方法。

*垃圾收集算法*
1. 标记-清除算法
算法分为标记和清除两个阶段：首先标记处所有需要回收的对象，在标记完成后
统一回收掉所有被标记对象，是最基本的收集算法。

2. 复制算法
它将内存按容量划分为大小相等的两块，每次只是用其中的一块，当这一块的内
存用完了，就将还活着的对象复制到另外一块上边，然后把已经是用过的内存空
间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也不
用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简
单，高效。只是这种算法的代价是将内存缩小为原来的一半。

3. 标记-整理算法
标记过程仍然与“标记-整理算法”一样，但是后续步骤不是直接对可回收对象
进行清理，而是让所有存活对象都向一端移动，然后清理掉端边界以外的内存。

4. 分代收集算法
当前商业虚拟机都采用这种算法，根据对象的存活周期将内存划分为几块，java
堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
新生代中，每次垃圾收集都有大批对象死去，可以选用复制算法，只需要付出少
量存活对象的复制就可以完成收集。而老年代对象存活率高，没有额外空间，必
须使用标记-清理或者标记-整理算法来进行回收。

垃圾收集器

在垃圾回收的语境中，有必要先解释两个名词：并发和并行
并行：多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态
并发：用户线程和垃圾收集线程同时工作，用户程序继续运行，而垃圾收集程序
运行于另一个CPU上

1. Serial收集器  采用复制算法
Serial收集器是最基本历史最悠久的收集器，它是一个单线程的收集器，它在垃圾收集的时候必须暂停其他所有的工作线程，直到收集完成。垃圾收集的工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是难以接受的

但是它也有自己的优点：简单高效 对于限定单个CPU的环境来说，收集器由于没有线程交互的开销，可以获得最高的单线程收集效率。

2. ParNew收集器  采用复制算法
ParNew收集器其实就是Serial收集器的多线程版本，包括收集器可用的控制参数、
收集算法、暂停所有用户线程、对象分配策略、回收策略等都和Serial收集器完
全一样，它是运行在Server模式下的虚拟机中首选的新生代收集器，其中一个原
因是，除了Serial收集器，目前只有它能和CMS收集器配合使用。CMS收集器是
HotSpot虚拟机上第一款真正意义上的并发收集器

ParNew收集器在单CPU环境中不会比Serial收集器有更好的效果

3. Parallel Scavenge收集器 采用复制算法
Paraller Scavenge收集器也是一个新生代收集器，使用复制算法的收集器，是
一个并行的多线程收集器

Parellel Scavenge收集器的特点是它的关注点和其它收集器不同，CMS等收集器
尽可能的缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的
目标则是达到一个可控制的吞吐量，吞吐量是CPU用于运行用户代码的时间与CPU
总消耗时间的比值。吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集
时间），虚拟机运行了100分钟，垃圾收集花掉1分钟，吞吐量是99%

停顿时间越短越适合与用户交互的程序，良好的响应速度能提升用户的体验；高
吞吐量可以更高效的利用CPU时间

Parallel Scavenge收集器有一种称为GC自适应调用策略，虚拟机根据当前系统
的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或最大的
吞吐量

自适应策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别

4. Serial Old收集器 采用标记-整理算法
它是Serial收集器的老年版本，单线程收集器，采用标记-整理算法。

5. Parallel Old收集器 采用标记-整理算法
Parallel Old是Parallel Scavenge收集器的老年版本，使用多线程和标记-整理
算法。

6. CMS收集器 采用标记-清理算法
CMS收集器是一种以获得最短回收停顿时间为目标的收集器。
它分为四个步骤：初始标记、并发标记、重新标记、并发清除
其中初始标记和重新标记两个步骤任然需要暂停其它线程。

初始标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶
段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期
间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个
阶段一般比初始标记阶段稍长一些，但远比并发标记的时间短。

由于整个过程中耗时最长的并发标记和并发清理过程中，收集器都可以与用户线
程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用于线程一起并
发执行的。

CMS收集器的缺点：
CMS收集器对CPU资源非常敏感，面向并发设计的程序都对CPU资源比较敏感，虽
然并发阶段不会导致应用线程停顿，但是会因为占用了一部分线程导致应用程序
编码，总吞吐量会降低。

CMS是基于标记-清理算法，收集结束的时候会产生大量空间碎片，空间碎片过多
的时候将会给大家分配带来很大的麻烦，玩玩会出现老年代有很大剩余空间，但
是无法找打足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。

7. G1收集器 采用标记整理算法
G1收集器是收集器理论进一步发展的产物，它与CMS收集器相比有两个重要的改
进：G1收集器基于标记-整理算法，不会产生空间碎片，对于长时间运行的应用
程序来说非常重要。二是，它可以非常精确的控制停顿，能让使用者明确指定一
个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒

G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，它能够
避免全区域的垃圾收集。

*内存分配与回收策略*
Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：
给对象分配内存以及回收分配给对象的内存。

对象的内存分配，就是在堆上分配，对象主要分配在新生代的Eden区上，少数情
况下也可能会直接分配在老年代中

1. 对象优先在Eden分配
对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发
起一次Minor GC

2. 大对象直接进入老年代
所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的就是那种很长
的字符串及数组

3. 长期存活的对象将进入老年代
虚拟机给每个对象定义了一个对象年龄计数器，当年龄增加到一定程序时，就会
被晋升到老年代中

新生代使用复制收集算法
Minor GC:发生在新生代的垃圾收集动作，Java对象大多都具有朝生夕灭的特性，
所以Minor GC非常频繁，一般回收速度也比较快

Major GC/Full GC:发生在老年代的GC，Major GC的速度一般会比Minor GC慢10
倍以上。

** 类文件结构
实现语言无关性的基础仍然是虚拟机和字节码存储格式，使用Java编译器可以把Java代码编译为存储字节码的Class文件，
使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是什么语言，只要他符合Class文件应用的结构就可以在Java虚拟机中运行。

Class文件是一组以八位字节为基础的单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要八位字节以上的空间的数据项时，则会按照高位在前分割方式分割成若干个八位字节进行存储。

根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种结构只要两种数据类型：无符号数和表。
无符号数属于基本的数据类型。
表是由多个无符号数或者其他表作为数据项构成的复合数据类型。

*魔数*
每个class文件的头4个字节称为魔数，它的唯一作用是用来确定这个文件是否为
一个能被虚拟机接收的class文件。紧着接魔数的4个字节存储的是Class文件的
版本号，5、6字节是次版本号，7、8字节是主版本号，java的版本号是从45开始
的。

*常量池*
紧接着主次版本号之后是常量池入口，常量池是Class文件结构中与其它项目关
联最多的数据类型，也是占用Class文件空间最大的数据项目之一，用于常量池
的数量是不固定的，所以需要在常量池的入口放置一个常量池容量计数值，这个
计数器是从1开始而不是从0开始，因此如果计数器的值为18，表示有17个常量。
作Class文件格式规范的时候，将第0项常量空出来是有特殊考虑的，可以用来表
示不引用任何常量池。

常量池之中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。
字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为finla的常量值等。
而符号引用则属于编译原理方面的概念，包括下面三个常量：
·类和接口的权限类名
·字段的名称和描述符
·方法的名称和描述符

Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而
是在虚拟机加载Class文件的时候进行动态连接。

*访问标志位*
在常量池结束之后，紧着着的2字节代表访问标志，这个标志用于识别一些类或
接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型，
是否定义为abstract类型；如果是类的话，是否被声明为final等

*字段值集合*

*方法表集合*
在java语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还
要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数
在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，
因此java语言里是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但
是在Class文件格式中，只要描述符不是完全一致的两个方法也可以共存，也就
是说如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法
共存于同一个Class文件中的。

** 类加载机制
*** 基本概念
一般来说，java虚拟机使用一个类的方式如下：java源程序在经过java编译器编译之后就被转换成java字节码文件.class，虚拟机加载字节码文件被转换为java.lang.Class的一个实例，每个这样的实例代表一个java类，然后通过这个实例的newInstance()方法生成一个对象。基本上所有类加载器都是java.lang.ClassLoader的实例。

与那些在编译时需要进行连接工作的语言不同，在Java语言里边，类型的加载和
连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，
但是却能为java应用程序提供高度的灵活性，java中天生可以动态扩展的语言特
性就是依赖运行期动态加载和动态连接这个特点实现的。例如，如果编写一个使
用接口的应用程序，可以等到运行时再指定其实际的实现。

*** 类加载的时机
类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备和解析三个部分统称为连接。

加载、验证、准备初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须
按照这种顺序安部就班地开始，而解析阶段则不一定：它在某些情况下可以在初
始化阶段之后开始，这是为了支持java语言的运行时绑定（动态绑定），这里写
的是按部就班的开始，而不是按部就班的“运行”或者“完成”，因为这些阶段
通常都是互相交叉地混合式进行的

*** 类加载过程
类加载的过程，也就是加载、验证、准备、解析和初始化这五个阶段的过程。

*加载*
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数
   据的访问入口

至于从哪里加载定义此类的二进制字节流，有多种方式，如JAR、EAR，从网络获
取，由其它文件生成，如JSP应用

相对于类加载过程的其它阶段，加载阶段（获取类的二进制字节流的动作）是开
发期可控性最强的阶段，因为加载阶段可以使用系统提供的类加载器来完成，也
可以由用户自定义的类加载器来完成，开发人员可以通过定义自己的类加载器去
控制字节流的获取方式

加载完成之后，虚拟机外部的二进制字节流就按照虚拟机所需要的格式存储在方
法区之中，方法区中的数据存储格式由虚拟机实现自行定义，然后在java堆中实
例化一个java.lang.Class类的对象，这个对象作为程序访问方法区中的这些类
型数据的外部接口。

*验证*
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包
含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

class文件的格式虚拟机有严格的要求，必须按照这种格式，类文件才可以被虚
拟机加载执行

如果验证到输入的字节流不符合Class文件的存储格式，就抛出一个
java.lang.VerifyError异常或其子类异常，具体应当检查哪些方面，如何检查，
何时检查，都没有强制要求或明确说明，但大致都会完成四个阶段的检验过程：
文件格式检验、元数据验证、字节码验证和符号引用验证
1. 文件格式检验
2. 元数据验证
3. 字节码验证
4. 符号引用验证

*准备*
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在
方法去中进行分配。这个时候进行内存分配的仅包括类变量（被static修饰的变
量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在
Java堆中，假设一个类变量的定义为：
public static int value=123;
那么变量value在准备阶段过后的初始值为0，而不是123，因为这个时候尚未开
始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，
存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化
阶段才会被执行。

假如上面类变量value的定义变为：
public static final int value=123;
编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据
ConstantValue的设置将value赋值为123。

*解析*
解析阶段是虚拟机将常量池内的符号引用替换位直接引用的过程

*初始化*
类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段
用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和
控制，到了初始化阶段，才真正开始执行类中定义的java程序代码(或者说字节
码)

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据
程序员通过程序制定的主观计划去初始化类变量和其它资源，也可以说：初始化
阶段是执行类构造器<clinit>()方法的过程。

<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块
({static}块)中的语句合并生成的

<clinit>()方法与类的构造函数(或者说<init>()方法)不同，它不需要显式的调
用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的
<clinit>()方法已经执行完毕，因此在虚拟机中第一个被执行的<clinit>()方法
的类肯定是java.lang.Object

由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优于
子类的变量赋值操作，代码清单中，字段B的值将是2而不是1
#+BEGIN_EXAMPLE
public class Parent {
	public static int  A = 1;
	static{
		A = 2;
	}
}

public class Sub extends Parent{
	public static int B = A;

	public static void main(String args[]){
		System.out.print(Sub.B);
	}
}
#+END_EXAMPLE

<clinit>()方法对于类和接口来说并不是必须的，如果一个类中没有静态语句块，
也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。

接口中不能使用静态初始化块，但仍然有变量初始化的赋值操作，因此接口与类
一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方
法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，
父接口才会被初始化。另外接口的实现类在初始化时也不会执行接口的
<clinit>()方法。

虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁和同步，如
果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<clinit>()
方法，其它线程都需要阻塞等待，知道活动线程执行<clinit>()方法完毕，如果
在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞

*** 类加载器ClassLoader
虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取定义此类的二
进制字节流”这个动作放在java虚拟机外部去实现，以便由应用程序决定它如何
去获取需要的类，实现这个动作的代码模块就是类加载器ClassLoader

java.lang.ClassLoader的主要作用是根据一个给定类的名字，查找该类的字节码文件，并生成一个class实例，它同时也加载java类所需要的一些资源如图像和配置文件。

java.lang.ClassLoader与加载类有关的方法
| 方法                         | 说明                                                  |
|------------------------------+-------------------------------------------------------|
| getParent()                  | 返回该类加载器的父加载器                              |
| loadClass(String name)       | 加载名称为name的类，返回结果是java.lang.Class的实例   |
| findClass(String name)       | 查找名称为name的类，返回结果是java.lang.Class类的实例 |
| findLoadedClass(String name) | 查找名字为name的已经加载过的类，返回结果同上          |
| defineClass()                | 把字节数组b中的内容转换成java类，返回结果同上         |
| resolveClass(Class<?> c)     | 连接指定的java类                                      |

*** 类加载器的树状组织结构
java中的类加载器分为两种，一种是系统提供的，另一种是由java应用开发人员
编写的。

java中系统提供的类加载器有三种：
•引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，存
放在<JAVA_HOME>/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的
jar文件如rt.jar，它是虚拟机整体中的一部分，通常用原生代码C++来实现的，
并不继承自java.lang.ClassLoader，使用String.class.getClassLoader()将返
回null。引导类加载器无法被java程序直接引用。

•扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。
 Java 虚拟机的实现会提供一个扩展库目录(<JAVA_HOME>/lib/ext 或者被java.ext.dirs系统变量所指定的路径)。该类加载器在此目录里面查找并加载
 Java 类。


•系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。

扩展类加载器和系统类加载器通常都是由java实现的，它们都是URLClassLoader类的实例。
Class.forName()是使用系统类加载器加载的。

除了引导类加载器外，每个类加载器都有一个父类加载器， 通过getParent()方法可以得到，类加载器会为它的父类加载器提供一个机会，以便加载任何给定类，只有在其父类加载器加载失败时，它才会加载给定类。

虚拟机一旦启动会先做一些初始化动作，一旦初始化动作完成之后，就会产生第
一个类加载器，即所谓的的BootstrapClassLoader，BootstrapClassLoader是由C++编写的，这个Bootstrap Loader所做的初始工作中，除了也做一些基本的初始化动作之外，最重要的就是加载定义在sun.misc 命名空间底下的Launcher.java 之中的ExtClassLoader( 因为是inner class ，所以编译之后会变成Launcher$ExtClassLoader.class) ，并设定其Parent 为null，代表其父加载器为Bootstrap Loader 。然后Bootstrap Loader ,再要求加载定义于sun.misc 命名空间底下的Launcher.java 之中的AppClassLoader( 因为是inner class，所以编译之后会变成Launcher$AppClassLoader.class) ，并设定其Parent 为之前产生的ExtClassLoader 实例。

注意: 扩展类加载器和系统类加载器都是由引导类加载器来加载的

a. Bootstrap ClassLoader/引导类加载器
主要负责java_home/jre/lib目录下的核心 api 或 -Xbootclasspath 选项指定的jar包装入工作.
b. Extension ClassLoader/扩展类加载器
主要负责java_home/jre/lib/ext目录下的jar包或 -Djava.ext.dirs 指定目录下的jar包装入工作
c. System ClassLoader/系统类加载器
主要负责java -classpath/-Djava.class.path或$CLASSPATH变量所指的目录下的类与jar包装入工作.
d. User Custom ClassLoader/用户自定义类加载类(java.lang.ClassLoader的子类)在程序运行期间, 通过java.lang.ClassLoader的子类动态加载class文件, 体现java动态实时类装入特性.


类加载器树状组织结构示意图

[[file:pic/ClassLoaderTree.jpg]]

类加载过程使用到了双亲委派模型，双亲委派模型要求除了顶层引导类加载器外，
其余的类加载器都应当有自己的父亲加载器，这里的类加载器之间的父子关系一
般都不会以继承关系来实现，都是使用组合关系来复用父加载器的代码。

双亲委派链模式的工作过程是:如果一个类加载器收到了类加载的请求，它首先
不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次
的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载
器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自
己去加载。

使用双亲委派模型的好处:对于Object类，它存放在rt.jar中，无论哪一个类加
载器要加载这个类，最终都是委派给引导类加载器来完成的，因此Object类在程
序的各个类加载器环境中都是同一个类

双亲委派模式的实现方式： 实现双亲委派模式的代码都集中在java.lang.ClassLoader的loadClass()方法中，它首先检测类是否已经加载过，如果没有加载过则调用父加载器的loadClass()方法，若父加载器为空则默认使用引导类加载器作为父加载器，如果父加载器加载失败，则抛出ClassNotFoundException异常，再调用自己的FindClass()方法进行加载。

*** 类加载器的代理模式

在介绍代理模式背后的动机之前，首先需要说明一下 Java 虚拟机是如何判定两
个 Java 类是相同的。Java 虚拟机不仅要看类的全名是否相同，还要看加载此
类的类加载器是否一样。只有两者都相同的情况，才为两个类是相同的。即便是
同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一
个 Java 类 com.example.Sample，编译之后生成了字节代码文件Sample.class。
两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个
Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这
两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个
类的对象进行相互赋值，会抛出运行时异常 ClassCastException。

了解了这一点之后，就可以理解代理模式的设计动机了。代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。

*** 网络类加载器
Java 字节代码（.class）文件存放在服务器上，客户端通过网络的方式获取字节代码并执行。当有版本更新的时候，只需要替换掉服务器上保存的文件即可。通过类加载器可以比较简单的实现这种需求。
类 NetworkClassLoader负责通过网络下载 Java 类字节代码并定义出 Java 类。
它的实现与 FileSystemClassLoader类似。在通过 NetworkClassLoader加载了
某个版本的类之后，一般有两种做法来使用它。第一种做法是使用 Java 反射
API。另外一种做法是使用接口。

需要注意的是，并不能直接在客户端代码中引用从服务器上下载的类，因为客户端代码的类加载器找不到这些类。使用 Java 反射 API 可以直接调用 Java 类的方法。而使用接口的做法则是把接口的类放在客户端中，从服务器上加载实现此接口的不同版本的类。在客户端通过相同的接口来使用这些实现类。

*** 两种加载类的方法以及区别  使用loadClass方法不会Class进行初始化
有两种手动加载类的方法：ClassLoader.loadClass()和Class.forName()
而Class.forName()实际上也是调用类加载器的loadClass方法。两者也存在一些
区别

JVM加载类的时候，需要经过三个步骤：装载、连接和初始化。
装载就是找到相应的class文件，读入JVM；
初始化就是对class文件的初始化；
连接分为三步：
+ 验证class文件是否符合规格
+ 准备 为类变量分配内存的同时设置默认初始值
+ 解释 根据loadClass方法第二个参数判定是否需要解释，这里的解释是指根据
  类中的符号引用查找响应的实体，再把符号引用替换成一个直接引用的过程

Class.forName()调用Class.forName(name, initialize, loader);
因此Class.forName("classString")等同于Class.forName("classString",
true, CALLCLASS.class.getClassLoader())
第二个参数为true，设置加载类的时候连接该类

用户使用类加载器加载类ClassLoader.loadClass(name)，它会默认调用
ClassLoader.loadClass(name,false),第二个参数为false，因此通过loadClass
加载类的时候并不对该类进行解释，不会初始化该类，而Class类的forName方法
则相反，会将Class进行解释和初始化。

** 虚拟机字节码执行引擎
代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，执行引
擎是java虚拟机最核心的组成部分之一。虚拟机是一个相对于物理机的概念，这
两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、
硬件、指令集和操作系统层面上的，而虚拟机执行引擎是由自己实现的，因此可
以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持
的指令集格式。

不同的虚拟机实现里边，执行引擎在执行java代码时可以是解释执行或者编译执
行(通过即时编译器JIT产生本地代码执行)两种选择，也可能两者兼备。

从外观上看，所有的java虚拟机的执行引擎都是一致的，输入的是字节码文件，
处理过程是字节码解析的等效过程，输出的是执行结果。

*** 运行时栈桢结构 栈也包括复杂的结构
栈桢是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时
数据区中的虚拟机栈的栈元素，每一个栈桢都包括了局部变量表、操作数栈、动
态连接、方法返回地址和一些额外的附加信息

执行引擎所运行的所有字节码指令都只针对当前栈桢进行操作

每个栈桢都包括局部变量、操作数栈、动态连接、方法返回地址等各个部分的作
用和数据结构。

*局部变量表*
局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变
量，局部变量表的容量以变量槽为最小单位

对于64位的数据类型，虚拟机会以高位在前的方式为其分配两个连续的slot空间，
如long和double。由于局部变量表建立在线程的堆栈上，是线程的私有数据，无
论读写两个连续的slot是否是原子操作，都不会引起数据安全问题。

*操作数栈*
操作数栈也被称为操作栈，它是一个后入先出栈。
当一个方法开始执行的时候，操作数栈是空的，在方法的执行过程中，会有各种
字节码指令向操作数栈中写入和提取内容，也就是入栈出栈操作，例如，在做算
法运算的时候是通过操作数栈来进行的

java虚拟机的解释执行引擎被称为是“基于栈的执行引擎”，其中的栈就是指操
作数栈，在字节码指令的执行过程中需要借助于操作数栈

*动态连接*
每个栈桢都包含一个指向运行时常量池中该栈桢所属方法的引用，持有这个引用
是为了支持方法调用过程中的动态连接。

*方法返回地址*
当一个方法被执行以后，有两种方式退出这个方法，第一种是执行引擎遇到任意
一个方法返回的字节码指令，这个时候可能会有返回值传递给上层的方法调用者

另一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体
内得到处理，就会导致方法退出，这种退出方法的方式称为异常完成出口，一个
方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的

*附加信息*



*** 方法调用
方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的
版本，暂时不涉及方法内部的具体运行过程。Class文件的编译过程总并不包含
传统编译中的连接步骤，一切方法调用在Class文件里面存储的都是符号应用，
而不是方法在实际运行时内存布局中的入口地址，这个特性给java带来了更强大
的动态扩展能力，但也使得java方法调用过程变得相对复杂起来，需要在类加载
期间甚至到运行期间才能确定目标方法的直接引用。


