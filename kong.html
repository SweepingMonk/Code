<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>kong</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="kong"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-10-19 14:37:08 中国标准时间"/>
<meta name="author" content=""/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">kong</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 笔记</a>
<ul>
<li><a href="#sec-1-1">1.1 个人笔记</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1 配置emacs</a></li>
<li><a href="#sec-1-1-2">1.1.2 学习Lisp</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2 学习笔记</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1 可执行文件的内存布局</a></li>
<li><a href="#sec-1-2-2">1.2.2 进程的地址空间</a></li>
<li><a href="#sec-1-2-3">1.2.3 java中创建socke超时的解决办法</a></li>
<li><a href="#sec-1-2-4">1.2.4 java获取本机地址的方式</a></li>
<li><a href="#sec-1-2-5">1.2.5 段错误和BUS错误</a></li>
<li><a href="#sec-1-2-6">1.2.6 捕捉信号signal</a></li>
<li><a href="#sec-1-2-7">1.2.7 类型提升 不怎么准  在ANSI C中已经取消了</a></li>
<li><a href="#sec-1-2-8">1.2.8 unix系统中逐字符输入的两种实现</a></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3 面试经验收集</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1 百度某部门 java研发</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-2">2 各种有趣问题</a>
<ul>
<li><a href="#sec-2-1">2.1 用磁带机求第K小元素</a></li>
<li><a href="#sec-2-2">2.2 裁纸机程序</a></li>
<li><a href="#sec-2-3">2.3 从0-N中随机生成M个数</a></li>
<li><a href="#sec-2-4">2.4 求平方根 求多维空间中两个点间的距离</a></li>
</ul>
</li>
<li><a href="#sec-3">3 时间表</a>
<ul>
<li><a href="#sec-3-1">3.1 后缀数组</a></li>
<li><a href="#sec-3-2">3.2 后缀树</a></li>
<li><a href="#sec-3-3">3.3 java webservice</a></li>
<li><a href="#sec-3-4">3.4 bitmap位图</a></li>
<li><a href="#sec-3-5">3.5 爬虫程序</a></li>
<li><a href="#sec-3-6">3.6 快捷键</a>
<ul>
<li><a href="#sec-3-6-1">3.6.1 todo 常用快捷键</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 笔记</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 个人笔记</h3>
<div class="outline-text-3" id="text-1-1">


</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> 配置emacs</h4>
<div class="outline-text-4" id="text-1-1-1">

<ul>
<li id="sec-1-1-1-1">10.16 ecb 和 全屏显示<br/>
配置ecb   darkroom 和 win32fullscreen
其中darkroom和win32fullscreen都可以实现全屏显示
主要用到了四个文件w32-fullscreen.el w32toggletitle.exe
darkroom-mode.el frame-local-vars.el
将w32toggletitle.exe放在path目录中，其它三个el文件都配置在init.el文件
中
</li>
</ul>
<ul>
<li id="sec-1-1-1-2">10.17 sr-speedbar<br/>
新增sr-speedbar功能，使speedbar可以在同一个frame中显示，不用重新开启一
个frame
下载sr-speedbar.el文件，在init.el文件中添加 (require 'sr-speedbar)
</li>
</ul>
<ul>
<li id="sec-1-1-1-3">10.17 查看历史打开文件 和历史编辑记录<br/>
recentf-open-files命令  C-c o按键
goto-last-change        C-c k 查看立即编辑记录
</li>
</ul>
<ul>
<li id="sec-1-1-1-4">10.17 查看历史编辑记录<br/>
使用goto-last-change命令回到上次编辑的位置，快捷键是C-c k   快捷键C-c
h被ecb占用
</li>
</ul>
<ul>
<li id="sec-1-1-1-5">10.17 用iexp命令在org模式插入括号<br/>
C-x p  you may try.
</li>
</ul>
<ul>
<li id="sec-1-1-1-6">10.18 emacs打开文件的字符编码问题<br/>
使用命令revert-buffer-with-coding-system手动选择打开文件的字符编码，
在保存的时候还可以指定文件的保存编码，使用命令
set-buffer-file-coding-system
</li>
</ul>
<ul>
<li id="sec-1-1-1-7">10.18 emacs配置etags<br/>
find -name "*.[chCH]" -print | etags - 命令用来生成TAGS
成功配置etags 
f5可以查找TAG，f6可以查找当前TAG,C-f6可以回跳
</li>
</ul>
</div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> 学习Lisp</h4>
<div class="outline-text-4" id="text-1-1-2">

<ul>
<li id="sec-1-1-2-1">学习Lisp 基本操作符<br/>
Lisp 的 7 个公理（基本操作符）
操作符一： quote
(quote x) 返回x
操作符二： atom
(atom x) 当 x 是一个原子或者空表时返回原子 t，否则返回NIL
操作符三： eq
(eq x y) 当 x 和y 指向相同的对象的时候返回t，否则返回NIL，值得注意的是
在Common Lisp中，原子对象在内存中只会有一份拷贝，所以(eq 'a 'a)返回t
操作符四： car
(car x) 要求 x 是一个表，它返回 x 中的第一个元素
操作符五： cdr
(cdr x) 同样要求 x 是一个表，它返回x中除第一个元素之外的所有元素组成的
表
操作符六： cons
(cons x y) 返回一个cons cell (x y)，如果y不是一个list，将会一dotted
pair形式展现这个cons cell

<p>
<b>多重的cons cell就构成了表</b>
(cons 'a (cons 'b (cons 'c ())))
(a b c)
</p>
<p>
操作符七： cond
(cond (p1 e1) &hellip;(pn en)) 的求值规则如下. 对“条件表达式p”依次求值直
到有一个返回t. 如果能找到这样的p表达式,相应的“结果表达式e”的值作为整
个cond表达式的返回值.
(cond ((eq 'a 'b) 'first)  ((atom 'a)  'second))
</p>
</li>
</ul>
<ul>
<li id="sec-1-1-2-2">Lisp高级属性<br/>
<b>构造函数</b>
cons
(cons 'lions '(tigers bears)) cons带有两个参数，一个原子和一个列表，
cons将原子作为第一个原子添加到该列表中。
append
(append '(lions) '(tigers bears)) append连接两个列表
list
(list 'lions 'tigers 'bears) list包含一个有所有参数组成的列表



</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 学习笔记</h3>
<div class="outline-text-3" id="text-1-2">


</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 可执行文件的内存布局</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>可执行文件内部主要包括文本端text，数据段data，和BSS段，用size命令可以
查看可执行文件a.out的大小。
数据段主要放置的是经过初始化的全局变量和静态变量，注意是经过初始化的，
如果没有被初始化则会放在BSS段，文本段主要放置可执行程序的指令。
局部变量并不进入a.out，它们在运行时创建。
</p>
</div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> 进程的地址空间</h4>
<div class="outline-text-4" id="text-1-2-2">

<p>注意：进程的地址空间和可执行程序的内存空间不太一样。
它除了包括上边的文本段，数据段和BSS段之外，还需要保存堆栈段，用于保存
局部与函数的数据。
同时，注意虚拟地址空间的最低部分未被映射，它位于进程的地址空间中，但并未赋予
物理地址，所有对它的引用都是非法的，在典型情况下，它是地址零开始的几K
字节，用于捕获使用空指针和小整形值的指针引用内存的情况。
堆栈段占据进程空间的最高地址，并向下增长。
</p>
</div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> java中创建socke超时的解决办法</h4>
<div class="outline-text-4" id="text-1-2-3">

<p>Socket s = new Socket("time&hellip;.", 13); #创建一个Socket连接
s.setSoTimeOut(1000);                  #设置socket获取信息的超时时间
</p>
<p>
这里有一个问题，创建socket也有一个时间，如果连接不到服务器就会一直阻塞，
这里哟一个办法，先创建一个未连接的套接字，然后把该套接字连接到给定的地
址。
Socket s = new Socket();   #设置创建socket的超时时间
s.connect(new InetSocketAddress("time&hellip;", 13), 1000);
s.setSoTimeOut(1000;        #设置获取信息的超时时间
</p></div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> java获取本机地址的方式</h4>
<div class="outline-text-4" id="text-1-2-4">

<p>InetAddress.getByName("localhost") #结果总是127.0.0.1
InetAddress.getLocalHost();     #得到本机的有效网络地址
</p>
</div>

</div>

<div id="outline-container-1-2-5" class="outline-4">
<h4 id="sec-1-2-5"><span class="section-number-4">1.2.5</span> 段错误和BUS错误</h4>
<div class="outline-text-4" id="text-1-2-5">

<p>常见的段错误和BUS错误，BUS错误通常是由于数据在内存中不对齐引起的
</p>


<pre class="example">union{ char a[10];
       int i;
}u;
int * p = (int *)&amp;(u.a[1]);
*p = 17;
</pre>

<p>
在实例中，数组a在共用体中是和int对齐的，所以a<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup>必然不和int对齐，然后
在这个地方放入一个4字节的数据会引发BUS错误。
</p>
<p>
段错误比较常见，通常是
</p><ol>
<li>坏指针值错误。在指针赋值前就用它来引用内存，指针释放后再将它置为空
   值。
</li>
<li>改写错误。 数组越界。
</li>
<li>释放链表出错。
</li>
</ol>

</div>

</div>

<div id="outline-container-1-2-6" class="outline-4">
<h4 id="sec-1-2-6"><span class="section-number-4">1.2.6</span> 捕捉信号signal</h4>
<div class="outline-text-4" id="text-1-2-6">

<p>使用头文件signal.h,使用句柄函数signal(SIGSGEV, handler)
常见的错误信号值SIGBUS,SIGSGEV,SIGILL
</p></div>

</div>

<div id="outline-container-1-2-7" class="outline-4">
<h4 id="sec-1-2-7"><span class="section-number-4">1.2.7</span> 类型提升 不怎么准  在ANSI C中已经取消了</h4>
<div class="outline-text-4" id="text-1-2-7">

<p>整型提升，就是char,short,int和位段类型(无论signed或unsigned)以及枚举类
型将被提升为int，前提是int能够完整的容纳原先的数据，否则将被转换为
unsigined int。float将被转换为double类型，任何数组将被转换为相应类型的
指针。
char c1,c2;
c1 = c1 + c2;
运算的时候，把每个变量的值提升为int的长度，然后对int执行加法，然后对运
算结果进行裁剪。
试试sizeof('c')的值
注意：另一个会发生隐式类型转换的地方就是参数传递，由于函数的参数也是表
达式，所以也会发生类型提升，在被调用函数的内部，提升后的参数被裁剪为原
先声明的大小。
</p>
</div>

</div>

<div id="outline-container-1-2-8" class="outline-4">
<h4 id="sec-1-2-8"><span class="section-number-4">1.2.8</span> unix系统中逐字符输入的两种实现</h4>
<div class="outline-text-4" id="text-1-2-8">

<p>一种是把I/O设置为raw状态，可以实现阻塞式读入，如果终端没有字符输入，进
程就一直等待，直到有字符输入为止。
</p>


<pre class="example">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int c;
    /* 中断驱动原来处于普通的一次一行模式*/
    /* 把终端设置为raw状态可以实现阻塞式读入*/
    system("stty raw");
    while(1){
        /*现在驱动处于一次一字符的模式*/
        c=getchar();
        putchar(c);
        if(c=='q')
            break;
    }
    /* 终端驱动又处于一次一字符的方式 */
    system("stty cooked");
    return 0;
}
</pre>


<p>
另外一种方式是使用ioctl(),这样只有当一个字符等待被读入时，进程才进行读
取，这种类型的I/O被称为轮询，就好像你不断地询问设备的状态，看看它是否
有字符要传给你。
</p>



<pre class="example">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/ioctl.h&gt;

int kbhit()
{
    int i;
    /* 设置I/O轮询 */
    ioctl(0, FIONREAD, &amp;i);
    return i;
}

int main()
{
    int i=0;
    int c=' ';
    system("stty raw -echo");
    printf("enter 'q' to quit \n");
    for(;c!='q';i++){
        if(kbhit()){
            c=getchar();
            printf("\n got %c, on iteration %d", c, i);
        }
    }
    system("stty cooked echo");
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 面试经验收集</h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> 百度某部门 java研发</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>研一小硕一枚，本科我邮计算机，玩了四年，在论坛上看到百度忘记哪个部门招java实习生，就投了简历凑了凑热闹 
先是电面，问了几个比较基础的问题，比如.equals()和==的区别，Spring中IOC和AOP什么意思，还有java中collection框架的架构..然后有人通知面试，这勉强算第一面 
下午到百度，然后先做了一个小时的笔试题，大概能做出来一半吧..发现他们问的题都很底层，比如SSH，不会问你怎么用，而是问你怎么理解它的设计思想的..貌似有个Hibernate中的懒加载..就果断不会了&hellip;Java也是很底层的，印象比较深的有个问什么叫unchecked Exception和checked Exception&hellip;.当时只知道有RuntimeException&hellip;就随便写了写.还有设计模式的东西，面java肯定要问设计模式的..后来感觉笔试仅仅是给你一个表现自己的机会，有个题不会也不要紧，把与题目相关的东西，知道多少就写多少&hellip; 
交完卷子等了半个小时然后来了个美女mm来二面&hellip;先是讲了项目上的东西，问了很多关于SSH和Flex里面的东西..看到我项目里面用过Ibatis/Mybatis..然后巴拉巴拉讨论了很多，比如Ibatis/Hibernate的区别以及Ibatis/Mybatis的区别，还有使用时的细节&hellip;然后又问了很多java基础的知识..设计模式的时候问了个单例模式，之前在一本书上看过单例模式有线程安全和线程不安全的两种写法，就巴拉巴拉讲了一大堆..还问了很多线程方面的知道。数据库方面先出了一个题让我写一个SQL语句，然后让我自己写一个我能想到最复杂的Sql语句..我的项目里面有涉及到数据库设计的，又讨论了很多.. 
二面结束了让我在原地等着..后来来了一个看着就像大牛的员工来三面..三面问的东西各种发散各种宽广..差不多五分钟一道题问了一个小时&hellip;.印象比较深的是HashMap/HashSet的内部实现原理，还好之前看过它们的源码..这个问题不要简简单单的回答散列表&hellip;看看源码就会知道里面还有好多重要知识&hellip;还有+号和append的区别..线程的实现方式以及优缺点..以及我对java中collection框架的看法..还有很多SSH方面的问题..具体的忘了&hellip;算法问了一个全排列的递归和非递归，编程之美上面有的..还有一个二分查找 
三面完了让我在那里等..一般实习生最多就是三面..我就在那里等结果..出来一个HR姐姐对我说项目头儿想面我..让我明天下午来..当时我就凌乱了..我是下午一点半开始笔试的&hellip;面到五点半.. 
第二天下午四面，面试官问的知识更发散了..有个问题是让我自己设计一套jdk我该怎么设计&hellip;当时我就凌乱了&hellip;反正也没正确答案就胡诌了一堆东西..然后问了很多代码优化的东西，问我对自己参与过的项目代码的优化经历以及有什么想法..还有对设计模式的理解和看法..反正问的都是没有正确答案的，要靠自己的经历总结和归纳，当时是能想多少就说多少&hellip;我的项目里面涉及到数据库的不少,问了一个内存数据库的问题..就是把数据库放在内存中需要注意哪些问题&hellip;问题很发散&hellip;和面试官巴拉巴拉聊了两个小时..然后让我回去等消息 
在回去的地铁上收到了HR的电话让去报道..
虽然因为某些原因最终还是没有去百度实习..这次面试获益匪浅啊..一次电面，一次笔试，然后三面.. 
java基础方面一定要扎实..能看源码最好看源码..以前学的太漂了..
框架方面主要理解思想跟设计方法..比较注重于概念..
数据库设计跟Sql的书写还是挺重要的
算法这次问的倒不多..估计跟岗位有关系吧..
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 各种有趣问题</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 用磁带机求第K小元素 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="_K___">第K大元素</span></span></h3>
<div class="outline-text-3" id="text-2-1">

<p>如果输入在磁带机上， 你的机器只有一个磁带机驱动器和几十字的内存，如何
找第K小的数
</p><ol>
<li>遍历一遍磁带，随即选择一个数M
</li>
<li>再遍历一遍磁带， 计算大于和小于M的个数，这样就可以获得数M在总序列中
   的排名，这里考虑到可能有重复元素所以要统计大于和小于的个数
</li>
<li>如果M的排名正好为所求，则结束；否则如果M的排名大于K，则下次遍历磁带
   时随即选择一个小于M的数，统计它的排名；如果M的排名小于K，下次遍历磁
   带的时候随即选择一个大于M的数，统计排名
</li>
<li>经过步骤3，所选数的范围缩小，最后就能找到所要求的数
</li>
<li>最多遍历磁带2logN次， 每次遍历时间O(n),总时间复杂度为O(nlogn)
</li>
</ol>


<p>
目前求第K小的数，比较好的算法时间复杂度为O(n),常数大概为3.4
</p>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 裁纸机程序</h3>
<div class="outline-text-3" id="text-2-2">

<p>一个字条上边印有一串数字，对字条进行切割，满足一下条件
</p><ol>
<li>每个字条上边都有字
</li>
<li>所有字条上数字的和小于给定数字
</li>
</ol>


<p>
一个长度为n的数字串，共有n-1个位置可以切割，每个位置可以切割也可以不切
割时间复杂度为o(2<sup>(n-1)</sup>)
</p>


<pre class="example">#include &lt;stdio.h&gt;
long long s = 0;
long long k, max = -1;
int flag=0;
void cutpaper(long long d, long long t)
{
    t *= 10;
    if(d &lt; t){
        s += d;
        if(s &lt;k &amp;&amp; s &gt;= max){
            if(s==max)
                flag=1;
            else{
                max=s;
                flag=0;
            }
        }
        s -= d;
        return;
    }
    cutpaper(d, t);
    long long temp = d % t;
    d = d/t;
    s += temp;
    cutpaper(d, 1);
    s -= temp;
}

int main()
{
    long long d, t;
    scanf("%ld%ld", &amp;d, &amp;k);
    cutpaper(d, 1);
    if(max &gt;= k)
        printf("not exists\n");
    else if(flag)
        printf("not service\n");
    else
        printf("%ld\n", max);
    return 0;
}
</pre>


</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 从0-N中随机生成M个数</h3>
<div class="outline-text-3" id="text-2-3">

<p>思路一：先从N个数中随机找出M个，然后对这M个数进行随机排列，时间复杂度
为O(n),空间复杂度为O(M)。
</p>


<pre class="example">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;

int s[100];
int f=0;

int getrand(int a, int b)
{
    return a + rand() % (b - a);
}
int in(int a)
{
    for(int i=0;i&lt;f;i++)
        if(s[i]==a)
            return 1;
    return 0;
}

void swap(int i, int j)
{
    int t = s[i];
    s[i]=s[j];
    s[j]=t;
}

int main()
{
    int n,m;
    srand(time(NULL));
    scanf("%d%d", &amp;n, &amp;m);
    for(int i=n-m;i&lt;n;i++){
        int temp=getrand(0, i + 1); #注：这里是 i + 1
        if(!in(temp))
            s[f++]=temp;
        else
            s[f++]=i;
    }
    for(int i=m-1;i&gt;0;i--){
        int temp = getrand(0, i+1);
        swap(i, temp);
    }
    for(int i=0;i&lt;f;i++)
        printf("%d\n", s[i]);
    return 0;
}
</pre>


<p>
思路二：直接从N个数中生成M个随机数
</p>


<pre class="example">for(int i=1;i&lt;=N;i++)
    s[i]=i;      #这样保证了生成的数不会重复，缺点是需要O(N)的空间
for(int i =1;i&lt;=M;i++)
    int temp = RandInt(i, N);
    swap(i, temp);
</pre>


<p>
思路三：对思路一中的情况进行了修改,插入S时刻意选择插入的位置，这样可以
制造更好的随机，编程珠玑（续）
</p>


<pre class="example">initialize sequence S to empty
for J:=N-M+1 to N do
    T = RandInt(1, J)
    if T is not in S then
       prefix T to S
    else
       insert J in S after T
</pre>


</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 求平方根 求多维空间中两个点间的距离</h3>
<div class="outline-text-3" id="text-2-4">

<ol>
<li>K维空间中有两个点A和B，求它们间的距离
</li>
<li>其中最重要的是求平方根操作，使用牛顿迭代可以减小开方操作的时间
</li>
<li>先找出A到B的距离中距离最大的一维 并记该距离为M，则A到B的距离值介于M和sqrt(K) * M
   之间
</li>
<li>用二分法直到两次求的的距离值小于一定范围为止
</li>
</ol>




<pre class="example">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define exp 1.0e-7

int main()
{
    double A[16]={4,6,2,6,1,9,12,64,43};
    double B[16]={4,6,8,15,31,26,43,17,41};
    double T = A[0]-B[0];
    double max = T;
    double sum= T * T;
    for(int i=1;i&lt;10;i++){
        T =fabs(A[i]-B[i]);
        if(T &gt; max)
            max = T;
        sum += T * T;
    }
    printf("%lf\n", sum);
    if(sum - 0.0 &lt; exp)
        return 0;

    /* 现在已经知道从A到B距离最大的一维的距离max， A到B的距离介于max
     * 和 sqrt(k) * max 之间 */

    /* 方法一 ------------------------------------------------------------------------*//
    double z = max;
    double newz;
    while(1){
        newz = 0.5 * (z + sum / z); #每一步都缩小了newz和精确值的差距
        if(fabs(newz - z) &lt; z * exp)
            break;
        z = newz;
    }
    /* 改进 --------------------------------------------------------------------------*/
    max = max * 2;
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    /* ------------------------------------------------------------------------------*/
    printf("%lf\n", newz);
    return 0;
}
</pre>






</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 时间表 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="____">工作计划</span></span></h2>
<div class="outline-text-2" id="text-3">

<p> <a href="../arrange.gif"> 基本流程</a>
</p>
</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> <span class="todo TODO">TODO</span> 后缀数组</h3>
<div class="outline-text-3" id="text-3-1">

</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> <span class="todo TODO">TODO</span> 后缀树</h3>
<div class="outline-text-3" id="text-3-2">

</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> <span class="todo TODO">TODO</span> java webservice</h3>
<div class="outline-text-3" id="text-3-3">

</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> <span class="todo TODO">TODO</span> bitmap位图</h3>
<div class="outline-text-3" id="text-3-4">

</div>

</div>

<div id="outline-container-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> <span class="todo TODO">TODO</span> 爬虫程序</h3>
<div class="outline-text-3" id="text-3-5">

</div>

</div>

<div id="outline-container-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> 快捷键</h3>
<div class="outline-text-3" id="text-3-6">


</div>

<div id="outline-container-3-6-1" class="outline-4">
<h4 id="sec-3-6-1"><span class="section-number-4">3.6.1</span> todo 常用快捷键</h4>
<div class="outline-text-4" id="text-3-6-1">

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">快捷键</th><th scope="col" class="left">功能</th></tr>
</thead>
<tbody>
<tr><td class="left">C-c C-t</td><td class="left">在定义的状态中循环</td></tr>
<tr><td class="left">C-u C-c C-t</td><td class="left">指定一个状态</td></tr>
<tr><td class="left">S-right</td><td class="left">在定义的状态中循环</td></tr>
<tr><td class="left">S-Left</td><td class="left">在定义的状态中循环</td></tr>
<tr><td class="left">C-c C-q</td><td class="left">为当前状态插入标签</td></tr>
</tbody>
</table>


<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> DEFINITION NOT FOUND: 1
</p>

</div>
</div>
</div>
</div>

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-10-19 14:37:08 中国标准时间</p>
<p class="author">Author: </p>
<p class="creator">Org version 7.8.11 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
