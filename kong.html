<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>kong</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="kong"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-10-26 17:44:30 中国标准时间"/>
<meta name="author" content=""/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">kong</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 笔记</a>
<ul>
<li><a href="#sec-1-1">1.1 个人笔记</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1 配置emacs</a></li>
<li><a href="#sec-1-1-2">1.1.2 学习Lisp</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2 学习笔记</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1 java编程</a></li>
<li><a href="#sec-1-2-2">1.2.2 c编程</a></li>
<li><a href="#sec-1-2-3">1.2.3 系统编程</a></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3 面试经验收集</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1 百度某部门 java研发</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-2">2 各种有趣问题</a>
<ul>
<li><a href="#sec-2-1">2.1 用磁带机求第K小元素</a></li>
<li><a href="#sec-2-2">2.2 裁纸机程序</a></li>
<li><a href="#sec-2-3">2.3 从0-N中随机生成M个数</a></li>
<li><a href="#sec-2-4">2.4 求平方根 求多维空间中两个点间的距离</a></li>
<li><a href="#sec-2-5">2.5 检测链表中是否存在循环 前提是链表中所有结点元素都不相同</a></li>
<li><a href="#sec-2-6">2.6 如何判断一个变量时有符号数还是无符号数</a></li>
<li><a href="#sec-2-7">2.7 一个文本文件中存入了很多字符串，如果随机的从中选中一个</a></li>
<li><a href="#sec-2-8">2.8 判定点是否在多边形内部</a></li>
<li><a href="#sec-2-9">2.9 poj1503 简单求大整数的和</a></li>
</ul>
</li>
<li><a href="#sec-3">3 工作计划</a>
<ul>
<li>
<ul>
<li><a href="#sec-3-1">3.1 后缀树</a></li>
<li><a href="#sec-3-2">3.2 后缀数组</a></li>
<li><a href="#sec-3-3">3.3 java webservice</a></li>
<li><a href="#sec-3-4">3.4 Delvik虚拟机和Java虚拟机的区别  Android技术内幕</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-4">4 图形子系统</a></li>
<li><a href="#sec-5">5 Android编译框架</a>
<ul>
<li><a href="#sec-5-1">5.1 编译框架基本概念</a></li>
<li><a href="#sec-5-2">5.2 Android中的三种不同编译方式</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 笔记</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 个人笔记</h3>
<div class="outline-text-3" id="text-1-1">


</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> 配置emacs</h4>
<div class="outline-text-4" id="text-1-1-1">

<p> **** emacs快捷键
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">命令类型</th><th scope="col" class="left">快捷键</th><th scope="col" class="left">快捷键描述</th></tr>
</thead>
<tbody>
<tr><td class="left">查找</td><td class="left">C-s C-w</td><td class="left">在查找模式下，查找光标指定位置处的单词</td></tr>
<tr><td class="left">指定目录下查找文件</td><td class="left">find-name-dired</td><td class="left"></td></tr>
<tr><td class="left">指定目录下查找只包含指定内容的文件</td><td class="left">find-grep-dired</td><td class="left"></td></tr>
<tr><td class="left">与上边两个类似但自由度最高</td><td class="left">find-dired</td><td class="left">gre</td></tr>
</tbody>
</table>

<ul>
<li id="sec-1-1-1-1">10.16 ecb 和 全屏显示<br/>
配置ecb   darkroom 和 win32fullscreen
其中darkroom和win32fullscreen都可以实现全屏显示
主要用到了四个文件w32-fullscreen.el w32toggletitle.exe
darkroom-mode.el frame-local-vars.el
将w32toggletitle.exe放在path目录中，其它三个el文件都配置在init.el文件
中
</li>
</ul>
<ul>
<li id="sec-1-1-1-2">10.17 sr-speedbar<br/>
新增sr-speedbar功能，使speedbar可以在同一个frame中显示，不用重新开启一
个frame
下载sr-speedbar.el文件，在init.el文件中添加 (require 'sr-speedbar)
</li>
</ul>
<ul>
<li id="sec-1-1-1-3">10.17 查看历史打开文件 和历史编辑记录<br/>
recentf-open-files命令  C-c o按键
goto-last-change        C-c k 查看立即编辑记录
</li>
</ul>
<ul>
<li id="sec-1-1-1-4">10.17 查看历史编辑记录<br/>
使用goto-last-change命令回到上次编辑的位置，快捷键是C-c k   快捷键C-c
h被ecb占用
</li>
</ul>
<ul>
<li id="sec-1-1-1-5">10.17 用iexp命令在org模式插入括号<br/>
C-x p  you may try.
</li>
</ul>
<ul>
<li id="sec-1-1-1-6">10.18 emacs打开文件的字符编码问题<br/>
使用命令revert-buffer-with-coding-system手动选择打开文件的字符编码，
在保存的时候还可以指定文件的保存编码，使用命令
set-buffer-file-coding-system
</li>
</ul>
<ul>
<li id="sec-1-1-1-7">10.18 emacs配置etags<br/>
find -name "*.[chCH]" -print | etags - 命令用来生成TAGS
visit-tags-table 用来查找指定的TAGS
成功配置etags 
f5可以查找TAG，f6可以查找当前TAG,C-f6可以回跳
</li>
</ul>
</div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> 学习Lisp</h4>
<div class="outline-text-4" id="text-1-1-2">

<ul>
<li id="sec-1-1-2-1">List命令<br/>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">关键字</th><th scope="col" class="left">简介</th></tr>
</thead>
<tbody>
<tr><td class="left">first</td><td class="left">返回列表的第一个元素</td></tr>
<tr><td class="left">rest</td><td class="left">返回列表中除了第一个元素外的其它元素</td></tr>
<tr><td class="left">car</td><td class="left">作用同first，区别不详</td></tr>
<tr><td class="left">cdr</td><td class="left">作用同rest，区别不详</td></tr>
<tr><td class="left">cons</td><td class="left">构造函数，两个参数</td></tr>
<tr><td class="left">append</td><td class="left">连接两个列表</td></tr>
<tr><td class="left">List</td><td class="left">返回一个由所有参数组成的列表</td></tr>
</tbody>
</table>

</li>
</ul>
<ul>
<li id="sec-1-1-2-2">Lisp推荐书籍<br/>
SICP 麻省理工的本科教材，实例以schema表示
On Lisp 是迄今为止讲Lisp的书籍里最深的一本，适合有一定基础的人看，有一
定难度。
Successful Lisp 适合做入门教材
Practical Common Lisp 提供了很多面向对象的实例，但不推荐
</li>
</ul>
<ul>
<li id="sec-1-1-2-3">Lisp特性<br/>
自动内存回收 显示类型 闭包
Lisp凌驾于面向对象程序设计 动态的面向对象语言
</li>
</ul>
<ul>
<li id="sec-1-1-2-4">学习Lisp 基本操作符<br/>
Lisp 的 7 个公理（基本操作符）
操作符一： quote
(quote x) 返回x
操作符二： atom
(atom x) 当 x 是一个原子或者空表时返回原子 t，否则返回NIL
操作符三： eq
(eq x y) 当 x 和y 指向相同的对象的时候返回t，否则返回NIL，值得注意的是
在Common Lisp中，原子对象在内存中只会有一份拷贝，所以(eq 'a 'a)返回t
操作符四： car
(car x) 要求 x 是一个表，它返回 x 中的第一个元素
操作符五： cdr
(cdr x) 同样要求 x 是一个表，它返回x中除第一个元素之外的所有元素组成的
表
操作符六： cons
(cons x y) 返回一个cons cell (x y)，如果y不是一个list，将会一dotted
pair形式展现这个cons cell

<p>
<b>多重的cons cell就构成了表</b>
(cons 'a (cons 'b (cons 'c ())))
(a b c)
</p>
<p>
操作符七： cond
(cond (p1 e1) &hellip;(pn en)) 的求值规则如下. 对“条件表达式p”依次求值直
到有一个返回t. 如果能找到这样的p表达式,相应的“结果表达式e”的值作为整
个cond表达式的返回值.
(cond ((eq 'a 'b) 'first)  ((atom 'a)  'second))
</p>
</li>
</ul>
<ul>
<li id="sec-1-1-2-5">Lisp高级属性<br/>
<b>构造函数</b>
cons
(cons 'lions '(tigers bears)) cons带有两个参数，一个原子和一个列表，
cons将原子作为第一个原子添加到该列表中。
append
(append '(lisons) '(tigers bears)) append连接两个列表
list
(list 'lions 'tigers 'bears) list包含一个有所有参数组成的列表

<p>
使用cons和first rest可以构建任何列表或者列表片段
</p>
<p>
<b>循环操作</b>
数循环
(dotimes (i 10) (print i))
打印列表
(dolist (i '(0 1 2 3 3 4 5 6)) (print i))
常见的do操作
(do ((i 0 (+ 1 i))) ((&gt; i 10)) (print i))
</p>
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 学习笔记</h3>
<div class="outline-text-3" id="text-1-2">


</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> java编程</h4>
<div class="outline-text-4" id="text-1-2-1">

<ul>
<li id="sec-1-2-1-1">面向对象的三个基本特征<br/>
封装、继承和多态
封装：把客观的数据和操作封装成抽象的类，只暴露一些对外的接口，具体实现
对外不可见。
继承：通过继承，它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这
些功能进行扩展。
多态：对于同一个调用，父类的不同子类执行不同的操作。
多态的实现方式有两种，覆盖和重载。覆盖就是覆盖父类中的同名函数，参数
列表和返回值都必须相同。重载就是存在多个同名函数，参数列表不同，包括参
数个数不同或者参数类型不同，或者两者都不同，返回值随意。
</li>
</ul>
<ul>
<li id="sec-1-2-1-2">网络通信<br/>
<ul>
<li id="sec-1-2-1-2-1">java获取本机地址的方式<br/>
InetAddress.getByName("localhost") #结果总是127.0.0.1
InetAddress.getLocalHost();     #得到本机的有效网络地址
</li>
</ul>
<ul>
<li id="sec-1-2-1-2-2">java中创建socke超时的解决办法<br/>
Socket s = new Socket("time&hellip;.", 13); #创建一个Socket连接
s.setSoTimeOut(1000);                  #设置socket获取信息的超时时间

<p>
这里有一个问题，创建socket也有一个时间，如果连接不到服务器就会一直阻塞，
这里哟一个办法，先创建一个未连接的套接字，然后把该套接字连接到给定的地
址。
Socket s = new Socket();   #设置创建socket的超时时间
s.connect(new InetSocketAddress("time&hellip;", 13), 1000);
s.setSoTimeOut(1000;        #设置获取信息的超时时间
</p></li>
</ul>
</li>
</ul>
<ul>
<li id="sec-1-2-1-3">数据库操作<br/>
<ul>
<li id="sec-1-2-1-3-1">数据库连接<br/>
注意在使用mysql时，要首先加载mysql驱动程序类
Class.forName("com.mysql.jdbc.Driver");
或者使用System.setProperty("jdbc.drivers", "com.mysql.jdbc.Driver");
</li>
</ul>
<ul>
<li id="sec-1-2-1-3-2">数据库设计自增操作<br/>
如果要在某一列上设置自增操作，该列绝大多数时间必须是主键



<pre class="example">create table student(id int(4) primary key auto_increment,name
varchar(20), age int)
创建一个student表，并且设置主键自增

对于自增字段插入时，如果指定要插入的列则不需要特殊处理，否则自增的列插
入null即可
insert into student values(null, 'xiaoming', 20)
</pre>


</li>
</ul>
<ul>
<li id="sec-1-2-1-3-3">存储过程<br/>
sql语句执行的时候要先编译，然后执行。存储过程（Stored Procedure）是一
组为了完成特定功能的SQL语句集，经编译后存储在数据库中。用户通过指定存
储过程的名字并给出参数（如果该存储过程带有参数）来执行它。

<p>
数据库存储过程的实质就是部署在数据库端的一组定义代码以及SQL。
</p>
<p>
mysql存储过程实现过程
（1）MySQL存储过程是在“命令提示符”下创建的，所以首先应该打开“命令提示符”窗口。
（2）进入“命令提示符”窗口后，首先应该登录MySQL数据库服务器，在“命令提示符”下输入如下命令：
mysql –u用户名 –p用户密码
（3）更改语句结束符号，本实例将语句结束符更改为“//”。代码如下：
delimiter //
说明:存储过程用以;作为结束符，而;又是命令行下sql语句的结束符，所以要进
行更改
（4）创建存储过程前应首先选择某个数据库。代码如下：
use 数据库名
（5）delimiter ;
（6）创建存储过程。
（7）通过call语句调用存储过程。
</p>
<p>
存储过程示例:
</p>


<pre class="example">create procedure pr_add
(
a int,
b int
)
begin
declare c int;
-- 用来声明局部变量
-- DECLARE仅被用在BEGIN ... END复合语句里，并且必须在复合语句的开头，在任何其它语句之前。
if a is null then
set a = 0;
end if;
if b is null then
set b = 0;
end if;
set c = a + b;
select c as sum;
/*
return c;
不能在 MySQL 存储过程中使用。return 只能出现在函数中。
*/
end;

#执行：
set @a = 10;
set @b = 20;
call pr_add(@a, @b);

create procedure pro_sort(a int)
begin
if a=0
then
select * from student order by age desc;   -- 降序排列
else
select * from student order by age asc;    -- 升序排列
end if;
end;

#创建 MySQL 存储过程的简单语法为：

create procedure 存储过程名字()
(
[in|out|inout] 参数 datatype
)
begin
MySQL 语句;
end;
</pre>

<p>
删除存储过程
DROP PROCEDURE  IF  EXISTS存储过程名
不能在一个存储过程中删除另一个存储过程，只能调用另一个存储过程
</p>
</li>
</ul>
<ul>
<li id="sec-1-2-1-3-4">存储过程参数的三种形态<br/>
见示例
<a href="http://www.exampledepot.com/egs/java.sql/CallProcedure.html">http://www.exampledepot.com/egs/java.sql/CallProcedure.html</a>
</li>
</ul>
<ul>
<li id="sec-1-2-1-3-5">数据库一些不常见概念<br/>
CachedRowSet 被缓存的行集：允许与用户的整个交互过程中，断开连接，并且
可以将修改的部分同步到数据库
数据库元数据 DatabaseMetaData:可以获取数据库的一些信息，比如表格
结果集元数据 RestltSetMetaData: 可以获取结果集的总列数，列名，列的宽度
可滚动的结果集
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-1-2-1-4">jndi java命名与目录接口<br/>
java命名与目录接口，是java平台的一个标准扩展，提供一组接口、类和关于命
名空间的概念。如同其它很多java技术一样，JDNI是provider-based的技术，暴
露一个API和一个服务供应接口(SPI)。这意味着任何基于名字的技术都能通过
JNDI而提供服务，只要JNDI支持这项技术。
jdbc1.0使用DriverManager类来产生一个对数据源的连接，jdbc2.0使用
DataSource对象代表了一个真正的数据源。根据DataSource的实现方法，数据源
既可以是从关系数据库，也可以是电子表格，还可以是一个表格形式的文件，当
一个DataSource对象注册到名字服务中，应用程序就可以通过名字服务获得
DataSource对象并用它来产生一个与DataSource代表的数据源之间的连接。
命名服务：提供名称-对象的映射
目录服务：提供有关对象的信息，并提供定位这些对象所需的搜索工具。有许多
命名和目录服务的实现并且到它们的接口是不同的。

</li>
</ul>
<ul>
<li id="sec-1-2-1-5">URL和URI<br/>
URI: A uniform resource identifier (URI) is a compact sequence of
characters that identifier an abstract or physical resource.

<p>
Uniform, 统一。统一可以使不同类型的资源标志在同一个上下文中使用，即使
对这些资源的访问方式可能是不同的。
Resource， 资源。自理的资源可以是任何东西，比如电子表格，图片，邮件服
务等。
identifier, 标志符。标识符用来唯一标志Web中的资源，可以使用名称来作为
标志符，也可以用资源的地址作为标识符，前者称为URN(统一资源名称)，后者
称为URL(统一资源定位符)，所以URN和URL是URI的子集。
</p>
<p>
URL和URI的区别： URI确定一个资源，URL不但确定一个资源，也指定了资源的
地址。
比如下面的统一资源标志符确定因特网工程工作组RFC1738，但并没有说出在哪里才找得到这份资料
urn:ietf:rfc:1738
</p>
</li>
</ul>
<ul>
<li id="sec-1-2-1-6">Http Get/Post请求区别<br/>
<ol>
<li>HTTP请求格式：
   &lt;request line&gt;
   &lt;headers&gt;
   &lt;blank line&gt;
   [&lt;request body&gt;]
   在HTTP请求中，第一行是一个请求行，用来说请求的方式，要访问的资源，
   HTTP版本。然后是首部小节header，用来说明服务器要使用的附加信息。首
   部之后是一个空行，然后是请求主体。
</li>
<li>GET和POST
   HTTP定义了与服务器交互的不同方法，最基本的方法是POST和GET。HTTP-GET
   和HTTP-POST是使用HTTP的标准协议动词，用于编码和传送变量名/变量值对
   参数，如果请求成功则返回应答。URL字符串中如果含有中文字符则用base64
   加密。

<p>
   POST方式，变量名/变量值不作为URL的一部分传送，而是放在实际的HTTP请
   求消息内部被传送
</p>
<p>
   浏览器请求时，默认是GET方式
   GET一般用于获取/查询 资源信息，而POST一般用于更新 资源信息
   #根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。
   1.所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
</p></li>
</ol>


<p>
　　* 注意：这里安全的含义仅仅是指是非修改信息。
</p>
<p>
　　2.幂等的意味着对同一URL的多个请求应该返回同样的结果。
</p>
<p>
   #根据HTTP规范，POST表示可能修改变服务器上的资源的请求。
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">get</th><th scope="col" class="left">post</th></tr>
</thead>
<tbody>
<tr><td class="left">从服务器上获取数据</td><td class="left">向服务器传送数据</td></tr>
<tr><td class="left">在客户端，通过URL提交数据</td><td class="left">数据放在HTML HEADER内提交</td></tr>
<tr><td class="left">服务器端用Request.QueryString获取变量的值</td><td class="left">服务器端用Request.Form获取提交的数据</td></tr>
<tr><td class="left">提交的数据受到URL长度的限制，如IE限制长度为2083字节</td><td class="left">没有限制</td></tr>
<tr><td class="left">参数显示在地址栏，不安全</td><td class="left">安全</td></tr>
</tbody>
</table>


<p>
示例代码
</p>


<pre class="example">&lt;!-分别通过get和post方式提交表单--&gt; 
&lt;FORM ACTION="getpost.asp" METHOD="get"&gt; 
&lt;INPUT TYPE="text" NAME="Text" VALUE="http://wxf0701.cnblogs.com//&gt; 
&lt;INPUT TYPE="submit" VALUE="Get方式"&gt;&lt;/INPUT&gt; 
&lt;/FORM&gt; 
&lt;BR&gt; 
&lt;FORM ACTION="getpost.asp" METHOD="post"&gt; 
&lt;INPUT TYPE="text" NAME="Text" VALUE="http://wxf0701.cnblogs.com/&gt; 
&lt;INPUT TYPE="submit" VALUE="Post方式"&gt;&lt;/INPUT&gt; 
&lt;/FORM&gt; 
&lt;BR&gt;

&lt;% If Request.QueryString("Text") &lt;&gt; "" Then %&gt; 
通过get方式传递的字符串是： "&lt;B&gt;&lt;%= Request.QueryString("Text") %&gt;&lt;/B&gt;"&lt;BR&gt; 
&lt;% End If %&gt;

&lt;% If Request.Form("Text") &lt;&gt; "" Then %&gt; 
通过Post方式传递的字符串是： "&lt;B&gt;&lt;%= Request.Form("Text") %&gt;&lt;/B&gt;"&lt;BR&gt; 
&lt;% End If %&gt;
</pre>


<p>
<b>HTTP响应实例</b>
</p>


<pre class="example">HTTP响应实例

HTTP/1.1 200 OK
Date: Sat, 31 Dec 2005 23:59:59 GMT
Content-Type: text/html;charset=ISO-8859-1
Content-Length: 122
＜html＞
＜head＞
＜title＞Wrox Homepage＜/title＞
＜/head＞
＜body＞
＜!-- body goes here --＞
＜/body＞
＜/html＞
2．最常用的状态码有：

◆200 (OK): 找到了该资源，并且一切正常。
◆304 (NOT MODIFIED): 该资源在上次请求之后没有任何修改。这通常用于浏览器的缓存机制。
◆401 (UNAUTHORIZED): 客户端无权访问该资源。这通常会使得浏览器要求用户输入用户名和密码，以登录到服务器。
◆403 (FORBIDDEN): 客户端未能获得授权。这通常是在401之后输入了不正确的用户名或密码。
◆404 (NOT FOUND): 在指定的位置不存在所申请的资源。
</pre>



<pre class="example">#+begin_src ditaa :file helloworld.png :cmdline -r -s 1.5 -e UTF-8
+-----------+
| cBLU      |
| 你好        |
|    +------+
|    |cPNK  |
|    |世界    |
+----+------+
#+end_src

#+results:
[[file:helloworld.png]]

</pre>



</li>
</ul>
</div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> c编程</h4>
<div class="outline-text-4" id="text-1-2-2">

<ul>
<li id="sec-1-2-2-1">类型提升 不怎么准 在ANSI C中已经取消了<br/>
整型提升，就是char,short,int和位段类型(无论signed或unsigned)以及枚举类
型将被提升为int，前提是int能够完整的容纳原先的数据，否则将被转换为
unsigined int。float将被转换为double类型，任何数组将被转换为相应类型的
指针。 char c1,c2; c1 = c1 + c2; 运算的时候，把每个变量的值提升为int的
长度，然后对int执行加法，然后对运 算结果进行裁剪。 试试sizeof('c')的值
注意：另一个会发生隐式类型转换的地方就是参数传递，由于函数的参数也是表
达式，所以也会发生类型提升，在被调用函数的内部，提升后的参数被裁剪为原
先声明的大小。
</li>
</ul>
<ul>
<li id="sec-1-2-2-2">fgets()函数<br/>
fgets(s, n, stdin); 函数最多接收n-1个字符，并自动在字符串最后加上结束
符号，如果输入字符个 数少于n-1，会接收回车符，然后在后边加上字符串结束
标志，所以如果输入字 符个数少于n-1的时候，后边多了一个回车符号，注意手
动去除. s[strlen(s)-1]=0
</li>
</ul>
<ul>
<li id="sec-1-2-2-3">swap交换两个元素 注意情况<br/>
*a ^= *b;
*b ^= *a;
*a ^= *b;
当a,b指向同一个元素时，该元素最后会被置为0，如果不是同一个元素，可以正
常交换

</li>
</ul>
</div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> 系统编程</h4>
<div class="outline-text-4" id="text-1-2-3">

<ul>
<li id="sec-1-2-3-1">可执行文件的内存布局<br/>
可执行文件内部主要包括文本端text，数据段data，和BSS段，用size命令可以
查看可执行文件a.out的大小。
数据段主要放置的是经过初始化的全局变量和静态变量，注意是经过初始化的，
如果没有被初始化则会放在BSS段，文本段主要放置可执行程序的指令。
局部变量并不进入a.out，它们在运行时创建。

</li>
</ul>
<ul>
<li id="sec-1-2-3-2">进程的地址空间<br/>
注意：进程的地址空间和可执行程序的内存空间不太一样。
它除了包括上边的文本段，数据段和BSS段之外，还需要保存堆栈段，用于保存
局部与函数的数据。
同时，注意虚拟地址空间的最低部分未被映射，它位于进程的地址空间中，但并未赋予
物理地址，所有对它的引用都是非法的，在典型情况下，它是地址零开始的几K
字节，用于捕获使用空指针和小整形值的指针引用内存的情况。
堆栈段占据进程空间的最高地址，并向下增长。
</li>
</ul>
<ul>
<li id="sec-1-2-3-3">段错误和BUS错误<br/>
常见的段错误和BUS错误，BUS错误通常是由于数据在内存中不对齐引起的



<pre class="example">union{ char a[10];
       int i;
}u;
int * p = (int *)&amp;(u.a[1]);
*p = 17;
</pre>

<p>
在实例中，数组a在共用体中是和int对齐的，所以a<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup>必然不和int对齐，然后
在这个地方放入一个4字节的数据会引发BUS错误。
</p>
<p>
段错误比较常见，通常是
</p><ol>
<li>坏指针值错误。在指针赋值前就用它来引用内存，指针释放后再将它置为空
   值。
</li>
<li>改写错误。 数组越界。
</li>
<li>释放链表出错。
</li>
</ol>

</li>
</ul>
<ul>
<li id="sec-1-2-3-4">捕捉信号signal<br/>
使用头文件signal.h,使用句柄函数signal(SIGSGEV, handler)
常见的错误信号值SIGBUS,SIGSGEV,SIGILL
</li>
</ul>
<ul>
<li id="sec-1-2-3-5">unix系统中逐字符输入的两种实现<br/>
一种是把I/O设置为raw状态，可以实现阻塞式读入，如果终端没有字符输入，进
程就一直等待，直到有字符输入为止。



<pre class="example">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int c;
    /* 中断驱动原来处于普通的一次一行模式*/
    /* 把终端设置为raw状态可以实现阻塞式读入*/
    system("stty raw");
    while(1){
        /*现在驱动处于一次一字符的模式*/
        c=getchar();
        putchar(c);
        if(c=='q')
            break;
    }
    /* 终端驱动又处于一次一字符的方式 */
    system("stty cooked");
    return 0;
}
</pre>


<p>
另外一种方式是使用ioctl(),这样只有当一个字符等待被读入时，进程才进行读
取，这种类型的I/O被称为轮询，就好像你不断地询问设备的状态，看看它是否
有字符要传给你。
</p>



<pre class="example">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/ioctl.h&gt;

int kbhit()
{
    int i;
    /* 设置I/O轮询 */
    ioctl(0, FIONREAD, &amp;i);
    return i;
}

int main()
{
    int i=0;
    int c=' ';
    system("stty raw -echo");
    printf("enter 'q' to quit \n");
    for(;c!='q';i++){
        if(kbhit()){
            c=getchar();
            printf("\n got %c, on iteration %d", c, i);
        }
    }
    system("stty cooked echo");
}
</pre>

</li>
</ul>
<ul>
<li id="sec-1-2-3-6">函数库调用和系统调用的区别<br/>
system是一个库函数 strlen并不调用任何系统调用
函数库调用是语言或应用程序的一部分，而系统调用是操作系统的一部分
系统调用时用户程序和内核交互的接口
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">函数库调用</th><th scope="col" class="left">系统调用</th></tr>
</thead>
<tbody>
<tr><td class="left">在所有的ansi c编译器版本中，c库函数是相同的</td><td class="left">各个操作系统的系统调用时不同的</td></tr>
<tr><td class="left">它调用函数库中的一个程序</td><td class="left">它调用系统内核的服务</td></tr>
<tr><td class="left">与用户程序相联系           important</td><td class="left">是操作系统的一个入口点</td></tr>
<tr><td class="left">在用户地址空间执行         important</td><td class="left">在内核地址空间执行</td></tr>
<tr><td class="left">它的运行时间属于用户时间    important</td><td class="left">它的运行时间属于系统时间</td></tr>
<tr><td class="left">属于过程调用，开销较小      important</td><td class="left">需要切换到内核上下文环境然后再切换回来开销大</td></tr>
<tr><td class="left">在C函数库libc中有大约300个程序</td><td class="left">在unix中有大约90个系统调用(MS-DOS)中少一些</td></tr>
</tbody>
</table>


<p>
自己总结
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">函数库调用</th><th scope="col" class="left">系统调用</th></tr>
</thead>
<tbody>
<tr><td class="left">通常提供比较复杂的功能</td><td class="left">通常提供一种最小界面</td></tr>
</tbody>
</table>





<pre class="example">int main()

{
    int fd = create("filename",0666);

    exit(0);
}
</pre>

<p>
在执行main函数时，是在user mode下执行，当遇到create函数时，继续在user
mode下执行，然后将filename和0666两个参数压入栈中寄存器，接着调用库函数
create，系统仍然处于user mode。
这里的库函数create实际上调用了内核的系统调用create，执行到这里后，系统将create系统调用的unique number压入寄
存器，然后执行指令trap使系统进入kernel mode(执行int $0x80产生中断)。
这时系统意识到要进行系统调用的invoke，于是从刚才的寄存器中取出create系统调用的unique number，从系统调用表中得知要invoke的系统调用是create，然后执行。执行完毕返回库函数create的调用，库函数负责检查系统调用的执行情况(检查某些寄存器的值)，
然后库函数create根据检查的结果返回响应的值。
</p>
<p>
这里trap指令类似于一个系统中断并且是软中断，而系统调用create类似于一个中断处理函数
所有的系统调用都与上边的情况类似，靠中断机制切换到内核模式实现。
</p>
<p>
系统调用通常比库函数要慢，因为要把上下文环境切换到内核模式
</p>
</li>
</ul>
<ul>
<li id="sec-1-2-3-7">内核开发的特点<br/>
<ul>
<li>内核编程时不能访问C库，也不能访问标准的C头文件
</li>
<li>内核编程时必须使用GNU C
</li>
<li>内核编程时缺少像用户空间那样的内存保护机制
  内核中的内存都是不分页的，每用掉一个字节，物理内存就减少一个字节。
</li>
<li>内核编程时难以执行浮点运算
  不要轻易在内核中使用浮点数
</li>
<li>内核给每个进程只有一个很小的定长堆栈
  内核栈的大小是两页，32位机的内核栈是8KB，而64位机是16KB，固定不变，
  每个处理器都有自己的栈。用户空间的栈比较大，而且通常可以动态增长，
  DOS不可以。
</li>
<li>内核支持异步终端，抢占和SMP，因此必须时刻注意同步和并发
  同步和并发
  内核很容易产生竞争。和单线程的用户空间程序不同，内核的许多特性都要求
  能够并发地访问共享数据。
<ul>
<li>Linux是抢占式多任务操作系统
</li>
<li>Linux支持对称多处理器系统
</li>
<li>中断是异步到来的
    中断异步到来，完全不顾及当前正在执行的代码。如果不加以适当的保护，
    中断完全有可能在代码访问资源的时候到来，这样中断处理程序就有可能访
    问同一资源
</li>
<li>Linux内核可以抢占。所以如果不加以适当保护，内核中一段正在执行的代
    码可能会被另外一段代码抢占，从而有可能导致几段代码同时访问相同的资
    源。

<p>
    常用的解决竞争的方法是自旋锁和信号量。
</p></li>
</ul>

</li>
</ul>


</li>
</ul>
<ul>
<li id="sec-1-2-3-8">文件描述符和文件指针的区别<br/>
在linux系统中把设备和普通文件也都看做是文件，要对文件进行操作就必须先打开文件，
打开文件后会得到一个文件描述符，它是一个很小的正整数，是一个索引值。

<p>
内核会为每一个运行中的进程在进程控制块pcb中维护一个打开文件的记录表，
每一个表项都有一个指针指向打开的文件，上边的索引值是记录表的索引值。
</p>
<p>
文件描述符的优点：兼容POSIX标准，许多系统调用都依赖于它；缺点是不能移
植到unix之外的系统上去。
</p>
<p>
文件指针：c语言中使用的是文件指针而不是文件描述符来作为I/O的句柄，文件
指针指向进程的用户空间中一个FILE结构的数据结构，FILE结构里主要包括一个
I/O缓冲区和一个文件描述符，而文件描述符值是文件描述符表中的一个索引，
从某种意义上将文件指针就是句柄的句柄(在Window中文件描述符被称为文件句
柄)。
</p>
<p>
文件指针的优点：是c语言中的通用格式，便于移植。
</p>
<p>
既然FILE结构中含有文件描述符，那么可以使用fopen来获得文件指针，然后从
文件指针获取文件描述符，文件描述符应该是唯一的，而文件指针却不是唯一的，
但指向的对象是唯一的。
</p>
<p>
C语言文件指针域文件描述符之间可以相互转换
int fileno(FILE * stream)
FILE * fdopen(int fd, const char * mode)
</p>
<p>
open和fopen的区别
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">open</th><th scope="col" class="left">fopen</th></tr>
</thead>
<tbody>
<tr><td class="left">open返回一个文件描述符</td><td class="left">返回FILE *</td></tr>
<tr><td class="left">无缓冲</td><td class="left">有缓冲</td></tr>
<tr><td class="left">与write()和read()配合使用</td><td class="left">与fwrite()和fread()配合使用</td></tr>
</tbody>
</table>



<p>
FILE的结构
</p>


<pre class="example">struct _iobuf {
        char *_ptr;          //缓冲区当前指针
        int   _cnt;
        char *_base;         //缓冲区基址
        int   _flag;         //文件读写模式
        int   _file;         //文件描述符
        int   _charbuf;      //缓冲区剩余自己个数
        int   _bufsiz;       //缓冲区大小
        char *_tmpfname;
        };
typedef struct _iobuf FILE;

int fd = open("TAGS", O_RDONLY);
FILE * fp = fopen("TAGS", "r");
printf("%d %d\n", fd, fp-&gt;_file);
可以从文件指针中获取文件描述符

fileno(fp) 和fp-&gt;_file效果是一样的
FILE * fp = fdopen(fd, "r") 根据文件描述符加上访问模式可以得到文件指针
</pre>


</li>
</ul>
<ul>
<li id="sec-1-2-3-9">makefile规则<br/>
<ul>
<li id="sec-1-2-3-9-1">':='和'='的区别<br/>
':='和平时使用的赋值符号相同，'='则不同，使用'='时，函数和变量参考会留
在那儿，改变一个变量的值会导致其它变量的值也被改变，类似于指针。

</li>
</ul>
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 面试经验收集</h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> 百度某部门 java研发</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>研一小硕一枚，本科我邮计算机，玩了四年，在论坛上看到百度忘记哪个部门招java实习生，就投了简历凑了凑热闹 
先是电面，问了几个比较基础的问题，比如.equals()和==的区别，Spring中IOC和AOP什么意思，还有java中collection框架的架构..然后有人通知面试，这勉强算第一面 
下午到百度，然后先做了一个小时的笔试题，大概能做出来一半吧..发现他们问的题都很底层，比如SSH，不会问你怎么用，而是问你怎么理解它的设计思想的..貌似有个Hibernate中的懒加载..就果断不会了&hellip;Java也是很底层的，印象比较深的有个问什么叫unchecked Exception和checked Exception&hellip;.当时只知道有RuntimeException&hellip;就随便写了写.还有设计模式的东西，面java肯定要问设计模式的..后来感觉笔试仅仅是给你一个表现自己的机会，有个题不会也不要紧，把与题目相关的东西，知道多少就写多少&hellip; 
交完卷子等了半个小时然后来了个美女mm来二面&hellip;先是讲了项目上的东西，问了很多关于SSH和Flex里面的东西..看到我项目里面用过Ibatis/Mybatis..然后巴拉巴拉讨论了很多，比如Ibatis/Hibernate的区别以及Ibatis/Mybatis的区别，还有使用时的细节&hellip;然后又问了很多java基础的知识..设计模式的时候问了个单例模式，之前在一本书上看过单例模式有线程安全和线程不安全的两种写法，就巴拉巴拉讲了一大堆..还问了很多线程方面的知道。数据库方面先出了一个题让我写一个SQL语句，然后让我自己写一个我能想到最复杂的Sql语句..我的项目里面有涉及到数据库设计的，又讨论了很多.. 
二面结束了让我在原地等着..后来来了一个看着就像大牛的员工来三面..三面问的东西各种发散各种宽广..差不多五分钟一道题问了一个小时&hellip;.印象比较深的是HashMap/HashSet的内部实现原理，还好之前看过它们的源码..这个问题不要简简单单的回答散列表&hellip;看看源码就会知道里面还有好多重要知识&hellip;还有+号和append的区别..线程的实现方式以及优缺点..以及我对java中collection框架的看法..还有很多SSH方面的问题..具体的忘了&hellip;算法问了一个全排列的递归和非递归，编程之美上面有的..还有一个二分查找 
三面完了让我在那里等..一般实习生最多就是三面..我就在那里等结果..出来一个HR姐姐对我说项目头儿想面我..让我明天下午来..当时我就凌乱了..我是下午一点半开始笔试的&hellip;面到五点半.. 
第二天下午四面，面试官问的知识更发散了..有个问题是让我自己设计一套jdk我该怎么设计&hellip;当时我就凌乱了&hellip;反正也没正确答案就胡诌了一堆东西..然后问了很多代码优化的东西，问我对自己参与过的项目代码的优化经历以及有什么想法..还有对设计模式的理解和看法..反正问的都是没有正确答案的，要靠自己的经历总结和归纳，当时是能想多少就说多少&hellip;我的项目里面涉及到数据库的不少,问了一个内存数据库的问题..就是把数据库放在内存中需要注意哪些问题&hellip;问题很发散&hellip;和面试官巴拉巴拉聊了两个小时..然后让我回去等消息 
在回去的地铁上收到了HR的电话让去报道..
虽然因为某些原因最终还是没有去百度实习..这次面试获益匪浅啊..一次电面，一次笔试，然后三面.. 
java基础方面一定要扎实..能看源码最好看源码..以前学的太漂了..
框架方面主要理解思想跟设计方法..比较注重于概念..
数据库设计跟Sql的书写还是挺重要的
算法这次问的倒不多..估计跟岗位有关系吧..
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 各种有趣问题</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 用磁带机求第K小元素 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="_K___">第K大元素</span></span></h3>
<div class="outline-text-3" id="text-2-1">

<p>如果输入在磁带机上， 你的机器只有一个磁带机驱动器和几十字的内存，如何
找第K小的数
</p><ol>
<li>遍历一遍磁带，随即选择一个数M
</li>
<li>再遍历一遍磁带， 计算大于和小于M的个数，这样就可以获得数M在总序列中
   的排名，这里考虑到可能有重复元素所以要统计大于和小于的个数
</li>
<li>如果M的排名正好为所求，则结束；否则如果M的排名大于K，则下次遍历磁带
   时随即选择一个小于M的数，统计它的排名；如果M的排名小于K，下次遍历磁
   带的时候随即选择一个大于M的数，统计排名
</li>
<li>经过步骤3，所选数的范围缩小，最后就能找到所要求的数
</li>
<li>最多遍历磁带2logN次， 每次遍历时间O(n),总时间复杂度为O(nlogn)
</li>
</ol>


<p>
目前求第K小的数，比较好的算法时间复杂度为O(n),常数大概为3.4
</p>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 裁纸机程序</h3>
<div class="outline-text-3" id="text-2-2">

<p>一个字条上边印有一串数字，对字条进行切割，满足一下条件
</p><ol>
<li>每个字条上边都有字
</li>
<li>所有字条上数字的和小于给定数字
</li>
</ol>


<p>
一个长度为n的数字串，共有n-1个位置可以切割，每个位置可以切割也可以不切
割时间复杂度为o(2<sup>(n-1)</sup>)
</p>


<pre class="example">#include &lt;stdio.h&gt;
long long s = 0;
long long k, max = -1;
int flag=0;
void cutpaper(long long d, long long t)
{
    t *= 10;
    if(d &lt; t){
        s += d;
        if(s &lt;k &amp;&amp; s &gt;= max){
            if(s==max)
                flag=1;
            else{
                max=s;
                flag=0;
            }
        }
        s -= d;
        return;
    }
    cutpaper(d, t);
    long long temp = d % t;
    d = d/t;
    s += temp;
    cutpaper(d, 1);
    s -= temp;
}

int main()
{
    long long d, t;
    scanf("%ld%ld", &amp;d, &amp;k);
    cutpaper(d, 1);
    if(max &gt;= k)
        printf("not exists\n");
    else if(flag)
        printf("not service\n");
    else
        printf("%ld\n", max);
    return 0;
}
</pre>


</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 从0-N中随机生成M个数</h3>
<div class="outline-text-3" id="text-2-3">

<p>思路一：先从N个数中随机找出M个，然后对这M个数进行随机排列，时间复杂度
为O(n),空间复杂度为O(M)。
</p>


<pre class="example">#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;

int s[100];
int f=0;

int getrand(int a, int b)
{
    return a + rand() % (b - a);
}
int in(int a)
{
    for(int i=0;i&lt;f;i++)
        if(s[i]==a)
            return 1;
    return 0;
}

void swap(int i, int j)
{
    int t = s[i];
    s[i]=s[j];
    s[j]=t;
}

int main()
{
    int n,m;
    srand(time(NULL));
    scanf("%d%d", &amp;n, &amp;m);
    for(int i=n-m;i&lt;n;i++){
        int temp=getrand(0, i + 1); #注：这里是 i + 1
        if(!in(temp))
            s[f++]=temp;
        else
            s[f++]=i;
    }
    for(int i=m-1;i&gt;0;i--){
        int temp = getrand(0, i+1);
        swap(i, temp);
    }
    for(int i=0;i&lt;f;i++)
        printf("%d\n", s[i]);
    return 0;
}
</pre>


<p>
思路二：直接从N个数中生成M个随机数
</p>


<pre class="example">for(int i=1;i&lt;=N;i++)
    s[i]=i;      #这样保证了生成的数不会重复，缺点是需要O(N)的空间
for(int i =1;i&lt;=M;i++)
    int temp = RandInt(i, N);
    swap(i, temp);
</pre>


<p>
思路三：对思路一中的情况进行了修改,插入S时刻意选择插入的位置，这样可以
制造更好的随机，编程珠玑（续）
</p>


<pre class="example">initialize sequence S to empty
for J:=N-M+1 to N do
    T = RandInt(1, J)
    if T is not in S then
       prefix T to S
    else
       insert J in S after T
</pre>


</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 求平方根 求多维空间中两个点间的距离</h3>
<div class="outline-text-3" id="text-2-4">

<ol>
<li>K维空间中有两个点A和B，求它们间的距离
</li>
<li>其中最重要的是求平方根操作，使用牛顿迭代可以减小开方操作的时间
</li>
<li>先找出A到B的距离中距离最大的一维 并记该距离为M，则A到B的距离值介于M和sqrt(K) * M
   之间
</li>
<li>用二分法直到两次求的的距离值小于一定范围为止
</li>
</ol>




<pre class="example">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define exp 1.0e-7

int main()
{
    double A[16]={4,6,2,6,1,9,12,64,43};
    double B[16]={4,6,8,15,31,26,43,17,41};
    double T = A[0]-B[0];
    double max = T;
    double sum= T * T;
    for(int i=1;i&lt;10;i++){
        T =fabs(A[i]-B[i]);
        if(T &gt; max)
            max = T;
        sum += T * T;
    }
    printf("%lf\n", sum);
    if(sum - 0.0 &lt; exp)
        return 0;

    /* 现在已经知道从A到B距离最大的一维的距离max， A到B的距离介于max
     * 和 sqrt(k) * max 之间 */

    /* 方法一 ------------------------------------------------------------------------*//
    double z = max;
    double newz;
    while(1){
        newz = 0.5 * (z + sum / z); #每一步都缩小了newz和精确值的差距
        if(fabs(newz - z) &lt; z * exp)
            break;
        z = newz;
    }
    /* 改进 --------------------------------------------------------------------------*/
    max = max * 2;
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    /* ------------------------------------------------------------------------------*/
    printf("%lf\n", newz);
    return 0;
}
</pre>

</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 检测链表中是否存在循环 前提是链表中所有结点元素都不相同</h3>
<div class="outline-text-3" id="text-2-5">

<p>思路：
</p><ol>
<li>用两个指针p1和p2,p1指向链表第一个元素，p2指向链表第三个元素
</li>
<li>比较p1和p2所指向元素是否相同，如果相同则存在循环
</li>
<li>p1和p2有一个为NULL则停止
</li>
<li>p1向后移动一个元素,p2向后移动两个元素
</li>
</ol>

<p>如果存在循环最后肯定能找到，如果不存在最后p2为NULL停止
</p></div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> 如何判断一个变量时有符号数还是无符号数</h3>
<div class="outline-text-3" id="text-2-6">

<p>如果宏的参数是一个类型，其中一个方法是使用类型转换
</p></div>

</div>

<div id="outline-container-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> 一个文本文件中存入了很多字符串，如果随机的从中选中一个</h3>
<div class="outline-text-3" id="text-2-7">

<ol>
<li>最简单的方法就是读一次文件，并记录每个字符串到文件开头的偏移量，最
   后随机一个数，打印该数字对应的字符串
</li>
<li>如果限制只能读一次文件，并且不能用变量存储字符串的偏移量，该怎么办
   呢？
   1）遍历文件，首先存入第一个字符串，当读入第二个字符串的时候，随机从
   这两个字符串中选择一个保存
   2）再读入一个字符串，从保存的字符串和该字符串中再以相同的概率选择保
   存一个，丢弃另一个，直到文件末尾，则选中任意字符串的概率都是相同的。
</li>
</ol>

</div>

</div>

<div id="outline-container-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> 判定点是否在多边形内部</h3>
<div class="outline-text-3" id="text-2-8">

<p>思路：二维空间中多个点的连线构成了一个多边形，給一定点p(x, y)，判断该点是否在
多边形内部
</p><ol>
<li>沿着定点p做一条直线，判断直线与多边形的交点个数，只算从p到多边形外
   边的交点的个数。
</li>
<li>如果交点个数为偶数，则不在多边形内部，如果为奇数则在多边形内部
</li>
<li>计算交点个数的时候有一些特例。如果交点为多边形的顶点，则要分两种情
   况；与该顶点相连的两条边如果都在直线的一侧，则不算交点个数，如果在
   两侧则算作一个有效的交点；如果直线与多边形的一条边重合则算作一个有
   效交点。
</li>
<li>这里选择直线的时候，可以选择与坐标轴平行的直线。假如选择与y轴平行的
   直线，则判断直线与边是否相交，只用先判断该边的两个顶点(x1, y1),(x2,
   y2),是否有x1&lt;=x&amp;&amp;x2&gt;=x如果满足，再判断该交点的位置。
</li>
<li>注意为了防止重复计算，只当交点为多边形的边的右顶点时才算作有效交点
</li>
</ol>


</div>

</div>

<div id="outline-container-2-9" class="outline-3">
<h3 id="sec-2-9"><span class="section-number-3">2.9</span> poj1503 简单求大整数的和</h3>
<div class="outline-text-3" id="text-2-9">

<p>当输入字符串为0时表示输入结束
错误点：最后验证字符串输入结束的标志是s<sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup>='0' &amp;&amp; s<sup><a class="footref" name="fnr.1.2" href="#fn.1">1</a></sup>=0
</p></div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 工作计划</h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-4">
<h4 id="sec-3-1"><span class="section-number-4">3.1</span> <span class="todo TODO">TODO</span> 后缀树</h4>
<div class="outline-text-4" id="text-3-1">

</div>

</div>

<div id="outline-container-3-2" class="outline-4">
<h4 id="sec-3-2"><span class="section-number-4">3.2</span> <span class="todo TODO">TODO</span> 后缀数组</h4>
<div class="outline-text-4" id="text-3-2">

</div>

</div>

<div id="outline-container-3-3" class="outline-4">
<h4 id="sec-3-3"><span class="section-number-4">3.3</span> <span class="todo TODO">TODO</span> java webservice</h4>
<div class="outline-text-4" id="text-3-3">

</div>

</div>

<div id="outline-container-3-4" class="outline-4">
<h4 id="sec-3-4"><span class="section-number-4">3.4</span> <span class="todo TODO">TODO</span> Delvik虚拟机和Java虚拟机的区别  Android技术内幕</h4>
<div class="outline-text-4" id="text-3-4">

</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 图形子系统</h2>
<div class="outline-text-2" id="text-4">

</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Android编译框架</h2>
<div class="outline-text-2" id="text-5">


</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 编译框架基本概念</h3>
<div class="outline-text-3" id="text-5-1">

<p>Android编译系统是通过各种.mk文件和shell脚本建立的一个编译框架，这个框
架基于基本的make概念。换句话说Android并没有建立新的编译脚本，而是建立
了一个框架，便于给该框架添加新的子项目。
Android编译系统的源码在./build目录下，了解编译系统的本质实际上是分析这
个脚本文件之间的相互关系。
整个编译系统主要由三部分组成，分别为编译中枢、子项目及输出路径。
编译中枢：主要包括各种.mk文件，这些文件将遍历所有子项目，并生成target。
子项目：每个子项目中都有必须包含一个Android.mk文件。
输出路径：包含编译过程所保存的各种临时文件，输出路径也是在编译中枢中定
义的，默认是out目录。
</p></div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Android中的三种不同编译方式</h3>
<div class="outline-text-3" id="text-5-2">

<p>make mm mmm
make：最常规的编译，通常用来编译整个Android源码
mm：用来编译当前目录下的所有子项目
mmm： 用来编译指定目录下的所有子项目
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> DEFINITION NOT FOUND: 1
</p>

<p class="footnote"><sup><a class="footnum" name="fn.2" href="#fnr.2">2</a></sup> DEFINITION NOT FOUND: 0
</p>

</div>
</div>
</div>

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-10-26 17:44:30 中国标准时间</p>
<p class="author">Author: </p>
<p class="creator">Org version 7.8.11 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
