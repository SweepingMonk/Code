* 1. 面试试题
** 面试心得
*** 2012百度某部门 java研发
研一小硕一枚，本科我邮计算机，玩了四年，在论坛上看到百度忘记哪个部门招java实习生，就投了简历凑了凑热闹
先是电面，问了几个比较基础的问题，比如.equals()和==的区别，Spring中IOC和AOP什么意思，还有java中collection框架的架构..然后有人通知面试，这勉强算第一面
下午到百度，然后先做了一个小时的笔试题，大概能做出来一半吧..发现他们问的题都很底层，比如SSH，不会问你怎么用，而是问你怎么理解它的设计思想的..貌似有个Hibernate中的懒加载..就果断不会了...Java也是很底层的，印象比较深的有个问什么叫unchecked Exception和checked Exception....当时只知道有RuntimeException...就随便写了写.还有设计模式的东西，面java肯定要问设计模式的..后来感觉笔试仅仅是给你一个表现自己的机会，有个题不会也不要紧，把与题目相关的东西，知道多少就写多少...
交完卷子等了半个小时然后来了个美女mm来二面...先是讲了项目上的东西，问了很多关于SSH和Flex里面的东西..看到我项目里面用过Ibatis/Mybatis..然后巴拉巴拉讨论了很多，比如Ibatis/Hibernate的区别以及Ibatis/Mybatis的区别，还有使用时的细节...然后又问了很多java基础的知识..设计模式的时候问了个单例模式，之前在一本书上看过单例模式有线程安全和线程不安全的两种写法，就巴拉巴拉讲了一大堆..还问了很多线程方面的知道。数据库方面先出了一个题让我写一个SQL语句，然后让我自己写一个我能想到最复杂的Sql语句..我的项目里面有涉及到数据库设计的，又讨论了很多..
二面结束了让我在原地等着..后来来了一个看着就像大牛的员工来三面..三面问的东西各种发散各种宽广..差不多五分钟一道题问了一个小时....印象比较深的是HashMap/HashSet的内部实现原理，还好之前看过它们的源码..这个问题不要简简单单的回答散列表...看看源码就会知道里面还有好多重要知识...还有+号和append的区别..线程的实现方式以及优缺点..以及我对java中collection框架的看法..还有很多SSH方面的问题..具体的忘了...算法问了一个全排列的递归和非递归，编程之美上面有的..还有一个二分查找
三面完了让我在那里等..一般实习生最多就是三面..我就在那里等结果..出来一个HR姐姐对我说项目头儿想面我..让我明天下午来..当时我就凌乱了..我是下午一点半开始笔试的...面到五点半..
第二天下午四面，面试官问的知识更发散了..有个问题是让我自己设计一套jdk我该怎么设计...当时我就凌乱了...反正也没正确答案就胡诌了一堆东西..然后问了很多代码优化的东西，问我对自己参与过的项目代码的优化经历以及有什么想法..还有对设计模式的理解和看法..反正问的都是没有正确答案的，要靠自己的经历总结和归纳，当时是能想多少就说多少...我的项目里面涉及到数据库的不少,问了一个内存数据库的问题..就是把数据库放在内存中需要注意哪些问题...问题很发散...和面试官巴拉巴拉聊了两个小时..然后让我回去等消息
在回去的地铁上收到了HR的电话让去报道..
虽然因为某些原因最终还是没有去百度实习..这次面试获益匪浅啊..一次电面，一次笔试，然后三面..
java基础方面一定要扎实..能看源码最好看源码..以前学的太漂了..
框架方面主要理解思想跟设计方法..比较注重于概念..
数据库设计跟Sql的书写还是挺重要的
算法这次问的倒不多..估计跟岗位有关系吧..

*** 百度三面
今天让同学帮查了百度面试结果，倒在三面上，写点东西纪念下吧。
百度一直是我最想进的公司。应该是四月份开始吧，就到处寻找百度的实习信息投简历，也让师兄帮忙内推，但每一次都是石沉大海，毫无音讯。直至迎来了暑期实习招聘。当时前两面地挺顺利，但是由于时间太晚，HR就让先回去了。之后等了好久才等来电话三面，直接拿手机做算法题被搞死了。
实习招聘结束后，我又开始进入散投的状态。但发现这时百度似乎实习生已经招满了。不过我还是坚持每天投几份。直到某一天收到回信，兴奋地打开邮件，赫然几个大字“你好，你的简历未通过筛选，谢谢。”也许这种行为已经使他们反感了吧，我只得安心去别的地方了。
实习的日子果然不出自己所料，做自己不想做的工作是一件很不开心的事，枯燥无味。我能做的只有等待。也怪自己不争气，那段时间没有把握住机会好好学一点东西，否则也不会导致现在的结果。现在想想，实习仅有的收获也许就是那几千块钱工资吧。
临近百度校招时，百度实习招聘也渐渐多了起来。当时觉得如果不是实习生去面试会吃亏，所以一有机会就找人内推，只是依然无果。
时间过的很快，10月20号转眼就到了。由于时间很近，很多记忆还没有消退。顺便把面经写一下，一来攒RP，二来让各位来指出我的不足之处。
一面的时候被HR分配到一个胖子那里。胖子首先让我写个单链表逆置，结果表头没有返回。被他指了出来。也许就是这道题给了他不好的印象，接下来的面试很不顺利，几乎没有说过完整的话，以下的省略号全是被他打断的内容。
“自我介绍一下吧。”
“我叫XX，北邮计算机专业硕士。研究生期间…”
“这个项目你在里面做什么的？”他指着简历说。
“负责工作流引擎和一些mapreduce算法的开发”。
“mapreduce的运行过程是什么样的？”
“比如一个大文件…”
“mapreduce分为哪三个阶段？”
“map，shuffle，reduce。”
“一堆url和一堆site，找出现在url里的site。用mapreduce做，只写reduce。”
我有点莫名奇妙，reduce的输入都不知道呢，怎么写啊。说了下，然后他同意先写map，再写reduce。我在纸上画了画。
“map以site为key，文件来源为value；reduce端value同时包含两个文件来源的就输出。”
“这是什么东西？” 他指着我的纸上问reduce输入问。
“相同key的value作为一个iterator输入啊!”
“你确定？”
“恩。”
“你好好回去看一下mapreduce吧。不过你的思路是对的。”说道这里我真不懂了，难道不是iterator吗？
“常用的分类算法有哪些？”
“贝叶斯啊，决策树啊…”
“两个有什么区别？”
“贝叶斯是基于贝叶斯定理，假定属性都是独立的…”
“不用说那些，有什么区别？”
我想了想，除了都是分类算法，满眼都是区别啊。
“如果输入有十个维度，怎么做”
“决策树的话，比如…”
“不用比如，怎么做？你这理工科基础要加强，你作为一个硕士生，对吧。你太浮躁了。”
“我看你简历里有很多前端的东西啊，以后写简历，这些东西不要写，像个大杂烩。我们不知道招什么人。”
“这是什么？”他指着简历问。
“是一个预测模型…”
“BG是什么，NBD是什么？”
“NBD是…”
“是NBD，不是MBD”他声音严厉起来。
“我念的就是NBD。不过我还真忘了这个缩写的具体含义，我给您说下原理…”
“我知道，但是你得对自己的简历负责。”
“你这个流失预测的算法是用clementine内置的是吧?”
“对，不过…”
他示意我不要说话了，然后拿着笔在空中悬了悬，往桌上一拍，在电脑打起字来，边打边说：“你是我面试中见过非常差的，我可以让你过，但是保底的，明白我的意思吧。”
我木然的点了点头。
“SVM知道吗？”
“恩。是个分类算法，就是找到一个超平面…”
“所有分类算法都是企图解决这个问题”
“脚本语言懂吗？”
“会点Python，在贴吧上抓点邮箱，然后…”
“一个链表，只给指向该节点的指针，怎么删除？五分钟换题。”
“如果不是最后一个节点，直接把后一个赋值给前一个，然后删除后一个节点。否则得重新遍历。”
“16瓶药水，一瓶不一样。放在一起发生化学反应。最少用几个试管可检测。还是五分钟。”
“4个，用二进制解决。一试管代表一位…”
“你看过这道题对吧？”
“恩。”
“不错，很诚实。”
然后他在纸上写着char *s=”abcde”。Sizeof(s)和strlen(s)有什么区别。
“strlen会比sizeof小1”。说完我看到他嘴角浮起得意的笑容。我定睛一看，忙说“不对不对，s是指针，sizeof就是4。”可惜的是他嘴角的笑容仍然挂在那，没有消失。回想起之前还在看虚继承内存布局，RTTI这些内容，面试却是这样一个结果。
“之前说的reduce输入…”
“我面试是考察你的能力，不是跟你探讨问题”他又变得严厉起来。
“笔试那道计算字符串相似性的题目你做出来了吗？”
“做出来了。”
“怎么做的？”
“用动态规划。”然后我在纸上把状态转移方程写了出来。
“你这个空间复杂度…”
“用滚动数组。因为状态i+1只跟i相关…”
“好了，怎么计算两个网页的相似性？”
“给他们分词，建立向量…”
“分词?比如一个div里一堆内容，一个table里一堆内容，两个内容相同，这两个网页是相似的吗？你回去好好想想吧。”
一面就这样结束了。二面是自己选的面试官，我特意找了一个长得比较帅的，把简历递给他了。这面比较成功，就不用对话的形式描述了。
第一道是给一个循环有序数组，用logn算法求一个数的位置。我就说第一次二分查找临界点，第二次利用临界点位置再二分查找那个数。然后他让我把查找临界点的代码写一下。
写好之后，被他找出一个bug，当数组长度为1的时候有问题。
接着他让我介绍一个项目。我bla bla说了一通，他很认真的听着，估计也没怎么听懂。实验室的项目就是玩具，只能靠概念忽悠了。
第二道题是一堆村庄，输入这些村庄哪几对是可达的，然后查询两个村庄是否可达。我说用并查集。接着把merge的代码写好，find的思路跟他说下，他表示认可。然后又问如果只查询一次该怎么做，我说宽搜或者深搜。把宽搜的思路说下，这个比较简单。
第三道题是用mapreduce实现表连接，也比较简单。
第四道题是一个人1/2的概率去酒馆，1/2呆家里。酒馆有8个，去的概率都是一样的。另一个人去酒馆找他，发现前7个酒馆都不在，问在第8个酒馆的概率。我想的时间略长，然后他问该怎么做。我说用贝叶斯定理，他说对，就换题了。
第五道题是给10亿个数去重，我就说分段用bitmap。他说bitmap怎么做，我就说用STL啊。然后让我自己实现，简单地写了个代码。
二面差不多就是这样。离开的时候，我向面试官摆了摆手说再见，他诡异地笑了笑。
三面等待的时候，心中忐忑不已。最后实在坐不住了，就主动去三面了。三面的面试官一看就不是好对付的角色，顿时觉得有些紧张。旁边坐着一个女人玩手机，应该是他的妻子。只是他笑着跟我连说了三声Hi，我才轻松下来，找了份简历递给他。
*** 2012微软面试心得
注：没太多规划便写了，想到哪写到哪，有些乱，望见谅……
注2：上传程序员面试题精选100题-何海涛 电子版~

趁着大多互联网校招的正式面试还没全面开展，分享一些自己找实习/工作的经验心得，也适当给明年找工作的师弟师妹们一些信息，攒攒RP。

个人背景简介
我邮计算机本科和网研小硕，计算机专业。
本科期间，前两年学习成绩中等偏上，主要精力放在学生工作和业余兴趣中。大三之后决意读研，好好学习，然后考研顺利，在网研院交换中心读研。研究生在苏老师组进行项目工作，参与过几个工程项目，基本都是Java Web方面的实践。
总体而言，技术上知识面略广，深度一般，有过实际的工程实践经验（虽说做的东西还是粗糙了些），综合素质方面良好但没出众之处或特长。


找实习/工作经历

简述
通过官方途径网申的有腾讯、ADOBE、MS、百度和有道，其中被有道无情BS了。托师兄内推人搜，自己没网申，不知为何连笔试都木有就被BS了。在大街网上也投过AMAZON等，一点消息都没有（大街略不靠谱）。最后拿到MS和百度的实习offer，最后去了MS的SDE intern，放弃了百度的互联网数据处理的offer；然后通过MS的转正面试，之后就没投简历了。

笔试流水帐
参加过的笔试都顺利通过，从身边朋友们的情况看，也没见笔试刷了多少人。笔试题考得都不深，但面的确挺广的，有些题不懂，比如操作系统和计组的，基本就是忘了。所以适当准备准备即可。主要精力还是放在面试题上好些。

面试流水帐
腾讯的技术面试一般有3轮。自己一面就跪了，虽说自我感觉面得还行。有些郁闷，但听到一些朋友更加悲催和无语的面试过程，也就释然了。
ADOBE的面试一般就一面，的确面得不好，同时面试官挺nice的，所以跪得舒服。得出的经验教训是  1）面外企做好全程英文面试的准备；2）要花些时间回忆和总结过往做过的项目，万一面试官对某个项目的某个细节感兴趣，至少得想得起来。
S面试有两轮，一轮一小时，不多不少。据我所知，只有MS能做到面试不推迟不延长，不由感叹做操作系统的就是不同，对时间片的理解就是深刻些。问的内容偏基础，最后一题都跟大数据处理相关。面完之后，其实感觉并不良好，因为二面有一道操作系统时间片的问题答得不好，最后在面试官的提示下才明白。
百度面试经过了三轮，第一轮现场面，后两轮尤其安排不过来，直接来了两轮电话面试。第二轮还是面技术，觉得比现场面试麻烦，比如口述代码。最后一轮，主要就问问具体工作的意向，没什么考验性的问题。
S转正面试，两轮技术面和一轮终面（亦有部分人是三轮技术面，也有直接推免的）。技术面一般就说说研究生做过的项目工作、在微软做的工作，1道简单的编码题和1道左右的大题，可能是智力题，可能是概率题，等等。由于有外藉员工参加面试（包括终面；自己有幸在第二轮遇着了），所以面微软还是做好英文面试技术的准备。终面的面试内容，因面试官而异，有的一直面技术，有的面其他的，自己这边具体说明微软的实习工作，接着回答了一道统计题，之后跟面试官交流些问题就结束了。

PS：基本上4月上旬就有投的了，微软、ADOBE、AMAZON等比较早（想走金融IT的注意一下大摩，也很早就能网申了），百度相对晚些。5月初面试多起来，最早拿到offer的也在5月初，比如大摩。6月初大多都能定了。

简历之我见
觉得简练突出为好。内容简练，无无关内容，关键部分突出。关键部分一般是实习经历、项目经历（非实习期间做的）和技能介绍等。其中实习经历和项目经历要说明清楚工作职责和内容。技能介绍突出自己擅长的即可，一般了解的往后排甚至为了篇幅不写之。其余，比如社会活动、竞赛经历，获奖情况，自我评论，都扼要介绍突出部分。比如获奖情况和社会活动一般都会有好些，根据剩余篇幅挑最重要的几个列一下即可，比如英文简历的社会活动，我就只留下奥残志愿者助理和院会部长，获奖就留优秀研究生、研究生国家一等，奥运会先进个人、校优秀干部，三好学习、优秀团员和其他奖学金没必要提。其实面技术的话，这些信息都不会被问到的。
最后提醒一点，简历上任何一点，都必须能详细地给面试官解释，如果解释不了，建议别写。

笔试之我见
笔试面试题面广，但不深，一般所有内容复习一遍周期太长，至少我没见身边有朋友这样干的。一般在网上或其他途径找些题练练，热热身即可。不过，具体还是得看个人情况，如果对OS，计组，计网基本不了解，那还是去翻翻吧。
节省笔试准备时间，其实主要为了腾多些时间准备面试。毕竟，从身边朋友们的情况看，因为笔试成绩被刷掉的概率实在是太小了，大家都答得差不多的烂，被刷掉往往是RP问题（如笔腾讯的时候，大家挨着坐，有位大牛朋友的答案和我们一样被刷了）。

面试之我见
首先，好好准备面试题，除非你是技术大牛。其中主要精力一般都放在技术题，尤其是算法题。一般大家都是看编程之美，个人觉得也可以看看面试100题（何海涛整理的，或者v_july_v整理的http://blog.csdn.net/v_july_v），听说现在好多面试官看的是剑指offer。时间充实的话甚至可以去oj上刷刷题（http://bbs.byr.cn/#!article/ACM_ICPC/11777 每几天刷刷这里的题，相信你就不怎么怕算法题了。对今年找工作的朋友，也许有些晚了，我找实习的时候也就刷了最前面的水题= =，明年找工作的师弟师妹可以刷了）。
其次，对有项目实践经验的朋友，除了简单整理项目做过的内容，个人认为还是应该挖掘更多有价值的问题，比如思考一下当初为什么那样做，换作现在的自己有什么地方可以改进，等等。
其次，有一个良好的面试心理状态很关键。个人觉得至少得经历处女面才有可能进入状态。所以对于特别想去的公司，建议提前面面其他公司，找状态。面试过程中，保持谦虚自信为好，别自悲，别骄傲。
除此之外，在面试过程中清晰表达自己的思路比直接给出答案更为重要。个人认为有经验的面试官更看重考察面试者的思维。无论是会做的还是不会做的，都要努力简要说明你的思路，让面试官能清楚了解你的思路。比如，被问到一个问题，别急着解答，先把一些没提及的条件问一遍，确保自己真正了解题意。一道好的面试题，往往是能从浅至深的增加难度的，或能从多方向解答的，或考察思考的全面性的题目。比如，考二分比考快排有价值，因为前者变形多，而且能考察面试者对具体场景的边界条件是否考虑周全。有经验的面试官也许还有私人题库，这类题目很多源于实际工程，遇着这类题目也许刚开始找不到方向，但一般面试官会给点思路，以考察面试者的快速学习能力等。
做好全面的准备后，剩下的就看RP。面试特别考验RP的，也许遇着的面试官就不喜欢自己，或者面试组织得特别混乱，或者自己面试时被安排得特别晚，面试官都没心思面了。所以，得做好心理准备，凡事处变不惊。

最后，总结一下面试各环节最好做到的地方：
1）自我介绍。如同简历，简练突出即可。
2）项目经验和实习经验；工作内容和个人职责需说清楚，如果有个人创新的地方，建议提一下。
3）编码题。个人觉得一般编码题都不难，写出来是基本要求。个人认为让面试官看到良好的代码习惯更重要。
4）其他主观技术题，或者智力题、统计题等，思路清晰最关键。

面试的内容便大概说到这里。
在此一直故意地没具体描述自己遇过的面试题，因为觉得具体说面试题没太大的意义，反而可能有反作用。经常看其他人的解题思路，多少也会剥夺自己的思考过程。比如以前看july博客里的海量数据题，当真正在面试中遇到类似的题，有些在博客上表述不是很清晰的细节部分，往往解释不好。而且，一些大公司二轮往后的面试官都是身经百战的，一般很容易看出你是否见过此题。如果你坦诚看过此题，会换题；如果不坦诚被发现了，那就是诚信问题了。

PS：想找面试题，其实去v_july_v的博客就够了，资料多到也许没法看完。

工作选择之我见
在做出工作选择之前，首先必须权衡自己的需求。比如，你觉得没户口不行，那像百度等基本解决不了户口的就可以pass了，全力向银行IT或国企央企或其他很有机会解决户口的公司努力吧。
每个人的情况差别挺大的，所以很难就权衡哪个offer最好，比如有朋友特别喜欢AMAZON，看不上其他offer。再比如我，实在对电信无爱，所以就没考虑过要投运营商或者其他电信行业的公司。同时，对国企央企也没太大的兴趣。而且，GF的工作已经属于稳定型的了，我得去外边努力打拼啊。
就本人而言，自己倾向第一份工作是大企业的技术岗；初始待遇中等偏高；在技术能力和岗位晋升方向有较良好的发展空间；做的东西略前沿至少不过时；有学习的欲望，能有户口最好，没对我关系也不大；等等。
现在不投简历，一来觉得自己没必要投其他国内互联网公司了，虽说待遇也许会略高些，但除此之外没其他内容能打击自己；而且自己一直对国内互联网有一个偏见——重视具体的skill过于talent，而在具体的skill上，我自认优势不大。二来在MS实习感觉还是挺良好的，环境各种好，同事也nice，主观上便很喜欢这里了，这样奋斗起来应该也会起劲些。
从小至今，在方向的选择上自己一直挺明确的，初升高、高考志愿（不包括专业志愿）和考研志愿基本上就一个志愿，一直也挺顺利的，这回继续相信第一感觉了。

PS：权衡offer还有许多方法。比如，将自己重视的feature列一下，针对offer每一项打个分，比较总分。如果是pairwise的比较，比如A公司和B公司，有一种粗略的权衡方法是比较去了一家公司后三年踢到另一家公司的机率。

关于待遇
只计薪酬，应该是比不过人搜C++岗、有道、网易游戏等，但也不算低。具体情况不方便公开，毕竟是保密信息，勿站内咨询。
户口，其实像MS、IBM等跟政府关系不错的外企解决率还是挺高的，对于北京生源的研究生以上学历的学生。但HR也透露，现在每年北京市的户口在收紧（昨天一BYR HR也发贴说过此事 http://bbs.byr.cn/#!article/Job/1213249），甚至以后改制，像上海般需要申请，以让户口优先分配给有工作经验或者说对社会做出贡献更大的人。我觉得这个方向挺合理的，虽说对应届生不利。


其他
对于还有时间好好准备的师弟师妹们，建议平时做好积累。各种计算机理论基础（如http://book.douban.com/doulist/1228111/
）或通用的计算机方法论（如http://book.douban.com/doulist/1584195/
），多学些百利无害。而具体技术至少有一门得有具体的实践经验，哪一门技术便不推荐了，本人也不偏爱任何一种具体的技术。除此之外，有时间建议亦去简单学习 数据挖掘、机器学习等高级领域的基础知识，比如看看公开课什么的。

平时关注一些技术博客或技术人员的微博也挺好的，比如：
@陈利人 http://www.weibo.com/lirenchen Google工程师，最近特别活跃，每天分享G的面试题和一些技术资料。
@左耳朵耗子 http://weibo.com/haoel Amazon工程师，CoolShell的博主，推荐其“职场生涯”相关的博文 http://coolshell.cn/category/career

听说在国外，对技术人员的招聘亦逐渐看重面试者在StackOverflow，Github等的贡献。虽说现在在国内还是太geek了，但整体而言应该是一个趋势。有时间关注一下总是好事。

找工作的时候多组团，要相信团体的力量远胜于个人的力量。


祝每一个BYR都能找到理想的工作！


更新于2012.10.13

关于工作抉择的补充

在论坛上比较offer，除了户口之外，往往第一关心的因素是入职年薪。而传闻的各种年薪，个人觉得都不尽真实，虽说在当事人心里应该都是真实的。入职待遇，尤其是福利等不在offer写明的内容，每年不一样，同一个公司不同部门也不一样，故不必尽信，大概知道个范围即可。

据我听说的和NB的前辈们灌输的观念，大公司间的整体待遇一般相差不大，而且很难量化成一个数值去比较差异，故粗略地用本身可能就不太靠谱的入职年薪去权衡工作间的好坏自然更没什么可信度。

入职时待遇差异小，但工作几年之后便开始有显著的差别，主要原因在于发展的差异。所以发展空间是值得考虑亦更重要的一个因素。但这个因素，如果排除人的个性化差异，无法衡量。比如说“私企更锻炼人，肯定比大公司发展空间要好！”，在此“更锻炼人”更准确地说往往是更能全方面地锻炼能力，而得出“发展空间更好”的观点往往是“更全面的人发展前途更好！”。这些观点都带有片面性，在好些场景下往往不成立，比如想往在某个技术领域做专的技术人，也许更全方面的锻炼机会直接剥夺了其投入专业领域的时间。

没有一份工作对于所有人都是绝对的好，公司往往也不会考虑针对不同的人提供不同的环境，它只是根据自己的价值观为符合自己公司文化和价值观的员工提供了一个良好的环境。考虑适合不适合，完全是个人的判断，要根据自己本身的情况去考虑，不可一概一论。

作为一名保守份子，我认为选择一份适合自己发展而且自己有能力发展好的工作最重要。首先知己——得有自知之明，知道自己有几斤几两，拿得住什么程度的offer。企业不会白给你这么多钱的，给你多少就期望更大地剥夺你多少的剩余价值。其次知彼——尽可能了解能提供的条件，比如绩效和晋升信息、补充的保险、福利、办公环境、等等等等。根据自己的情况判断是否满足自身需求，适合自身发展。

同时，在同一家公司，不同部门间的待遇、发展空间亦可能巨大。找工作只关注公司不关注部门和将来做的工作，犹如考研只关注学院和专业方向不关注报考导师一般，真没啥意义。上过研的能理解吧！

选择一份工作只是职业生涯的开始，以后发展得如何本质上还是看个人，不取决
于公司能给予的外界条件。可以类比高考或考研后对高校、学院、专业的选择。
** java相关
*** final finally finalize
final  finally   finalize
-----------------------------------------------------------
final可以用于控制成员、方法、或者是一个类是否可以被覆写或继承等功能
final用于成员时，这个变量一旦被初始化，便不可改变。它的初始化可以放在
两个地方一个是变量定义出，另一个是在构造函数中。
final用于参数时，可以防止在函数中改变它的值
final用于函数时不允许子类来覆写这个方法
final用于类时，这个类不能被继承，因此一个类不能即被声明为abstract又被
声明为final

finally是对java异常处理模型的最佳补充，无论有无异常发生，finally里的代
码总会执行，如果在try块里边有return语句，则在return语句执行之前会先执
行finally中的语句

finalize是垃圾回收器删除对象之前对这个对象调用的
-----------------------------------------------------------

*** sleep()和wait()区别
sleep()是使线程停止一段时间的方法，在sleep时间间隔期满以后，线程不一定
立即回复执行，这是因为在那个时刻，其它线程可能正在运行，而且没有被调度
为放弃执行，除非醒来的线程具有更高的优先级，或者正在运行的线程因为其它
原因阻塞。
wait() 线程交互时，如果线程对一个同步对象发出一个wait()调用，该线程会
暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到。
*** 参数的传值和传引用
可以说java中的参数传递都是传值，传递引用其实也是传值。
基本的数据类型都是传值，对象类型传递引用。

这里有一点要注意： String类型

String是对象类型， 但是由于String不可改变，每次赋新值的时候先在内存中分
配一个新的空间并赋予给定的值，并返回新地址的引用，所以String类型虽然是
传递引用但是效果和传值是一样的
#+BEGIN_EXAMPLE
String name = "hello";
String who = name;
who = "world";
System.out.print(name +" " + who);   hello world
#+END_EXAMPLE
迪米特法则：开放封闭原则，对扩展开放对修改封闭。  面向接口编程
里氏代换原则：一个软件实体中，可以把父类都替换成它的子类，程序行为没有变化


创建模式、结构模式、行为模式

单一职责原则：仅有一个可以引起对象发生变化的原因

单例模式：在整个应用中仅含有一个该类的实例

工厂模式根据抽象程度的不同分为三种，简单工厂模式、工厂方法模式、抽象工厂模式

简单工厂模式：所有的该类对象都由一个工厂来生产
工厂方法模式：有四个要素。工厂接口、工厂实现、产品接口、产品实现。降低了耦合度，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。也就是说，工厂方法模式将简单工厂内部的逻辑判断移到了客户端来进行
抽象工厂模式：核心工厂不再负责具体对象的构造，而是根据传入的参数，返回一个对应的工厂对象，然后由该工厂对象来构造具体对象


门面模式(外观模式)：感觉是Service层的一个翻版，为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口

策略模式：策略模式指定一组算法，将每一个算法封装到具有公共接口的独立的类中，从而使它们可以相互替换。

迭代器模式：提供一种方式访问容器对象中的各个元素，而又不需要暴露该对象的内部细节

适配器模式：在原型不做任何改变的情况下，扩展了新的接口。可以采用继承或者聚合的方式来实现适配器模式

装饰模式：为已有功能动态地添加更多功能的一种方式，I/O里用的最多

聚合表示一种弱的拥有关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样

合成模式(组合模式)：将众多对象组合成树形结构

观察者模式：一个Subject可以有多个Observer，Subject内部用一个变量存储了所有依附于它的Observer，当Subject状态发生改变的时候，就遍历通知所有观察者来自动更新自己

原型模式：通过原型类克隆自身从而创建一个新的对象

模版方法模式：先定义好逻辑处理的框架，然后将一些步骤放到子类中来实现，具体就是在一个抽象类中定义好框架，在具体子类中实现这些抽象方法，并且不同的子类有不同的实现

享元模式：

代理模式：不让客户端直接访问目标对象，而是通过一个代理，把客户端的请求通过该代理对象传递给目标对象

责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接 起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请。用户发出一个请求，同时有多个handler可以处理该请求，将这些handler连成一条链，请求沿着传递该请求，知道有一个对象处理它为止

命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化

调停者模式(中介者模式)：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示的互相调用，从而使其耦合松散

备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态

桥梁模式：

创建模式：用来创建对象的实例。如单例模式
结构模式：用于帮助将多个对象组织成更大的结构，如适配器模式、桥接模式、组合器模式等
行为模式：维护多个对象间复杂的逻辑关系，如命令行模式
** 其它知识点
*** 基本知识点
-----------------------------------------------------------
private 在类内部可以访问本类私有的成员变量和函数，注意main方法也属于类
的内部方法，是一个public的静态方法

main方法是静态方法不能访问非静态的方法和变量
-----------------------------------------------------------
布尔类型的默认值是false，整形默认是0

-----------------------------------------------------------
java test abc def    在java中使用java命令执行程序的时候程序的名字并不
作为参数，在这里总共有两个参数， 第一个参数是abc， 第二个是def

c语言中，程序名字作为第一个参数传递到程序中，真正的参数从第二个开始

-----------------------------------------------------------
静态方法不能被覆写
-----------------------------------------------------------
抽象类中可以没有抽象方法，可以是个空类，也可以都是具体方法
-----------------------------------------------------------
进入目录时需要获得目录的执行权限
-----------------------------------------------------------
所有32位应用程序都有4GB的进程地址空间，对于window应用程序可以访问2GB的
进程地址空间，Linux32位操作系统下，一个应用程序可以访问3GB的内存空间，
剩余的虚拟地址空间由操作系统内核使用，被称为内核模式的虚拟空间。
-----------------------------------------------------------

*** 线程安全和线程不安全
线程安全和不安全通常针对的是方法或者函数，函数执行过程中不会造成资源冲突的就是线程安全，即使有多个线程也没有关系

线程不安全就是会造成数据错误或者崩溃

如何处理线程不安全情况： 做好互斥与同步，对异常处理要完善。

*** 进程的生命周期
进程的开始与终止程是一个动态的实体，从创建到消亡，是一个进程的整个生命周期。进程可能
会经历各种不同的状态，一般来说有三种状态。
+ 就绪态： 进程已经获得了除cpu以外的所有其它资源，在就绪队列中等待cpu调度
+ 执行状态： 已经获得cpu以及所有需要的资源正在运行
+ 阻塞状态(等待状态)： 进程因等待所需要的资源而放弃处理器，或者进程本
  来就不拥有处理器，且其它资源也没有满足

[[file:pic/procedure.gif]]
状态转换： 就绪态的进程得到cpu调度就会变为执行状态，执行态的进程如果因
为休眠或等待某种资源就会变为等待状态，执行态的进程如果时间片到了就会重
新变为就绪状态放入就绪队列末尾，等待状态的进程如果得到除cpu以外的资源
就会变为就绪状态

*注意处于等待状态的进程不能直接转变为执行状态，而首先要变为就绪状态，哪怕系统中只有一个进程*

*** 数据库范式
数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简
洁的、结构明晰的，同时，不会发生插入（insert）、删除（delete）和更新
（update）操作异常。反之则是乱七八糟，不仅给数据库的编程人员制造麻烦，
而且面目可憎，可能存储了大量不需要的冗余信息。

第一范式1NF
所谓第一范式是指数据库表中的每一列都是不可分割的基本数据项

第二范式2NF
如果关系模式为第一范式，并且每一个非主属性完全函数依赖于某个候选键，则
称为第二范式

第三范式3NF
如果关系模式是第二范式，并且每个非主属性都不传递依赖于R的候选键，则称
为第三范式  消除了传递依赖

BCNF
若关系模式R是第一范式，并且每个属性都不传递依赖于R的候选键。称为BCNF，
在第三范式的基础上，数据库表中不存在任何字段对任一候选关键字段的传
递函数依赖

四种范式之间存在如下关系：

BCNF 属于 3NF 属于 2NF 属于 1NF
[[file:pic/NF.gif]]

*** tcp/ip协议
四类ip地址
|     A |       B |       C |       D |       E |
|-------+---------+---------+---------+---------|
| 1-126 | 128-191 | 192-223 | 224-239 | 240-254 |

*** tcp三次握手和四次挥手
连接建立：三次握手
1. 客户端发送tcp报文syn j到服务器
2. 服务器发送对syn j的确认报文ack j+1，同时发送报文syn k
3. 客户端发送对报文syn k的确认报文ack k+1
连接建立，服务器处于ESTABLISHED状态

连接释放：四次挥手
由于tcp连接时全双工的，因此每个方形都必须单独进行关闭，当一方完成它的
数据发送任务后就能发送一个FIN来终止这个方向的连接，这样它就不再发送数
据了，但是仍然呢可以接收数据，首先进行关闭的一方将进行主动关闭，而另一
方执行被动关闭

1. tcp客户端发送一个FIN j， 用来关闭客户到服务器的数据传送。
2. 服务器收到这个FIN j，发回一个ack k
3. 服务器关闭客户端的连接，发送一个FIN i给客户端
4. 客户端发挥ack i+1确认报文

CLOSED表示初始状态
LISTEN表示服务器端的某个socket处于监听状态，可以接受连接
SYN_RECV在建立tcp连接时的三次握手过程中，在收到客户端的syn请求报文之后
处于此状态
SYN_SENT当客户端发送完syn请求报文之后就处于这个状态
ESTABLISHED表示连接已经建立

FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。
FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。
TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。
CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。
CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。
LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。

*** c/c++内存分配以及区别
申请了内存空间后，必须检查是否分配成功。
当不需要再使用申请的内存时，必须记得释放，释放后应该把指向这块内存的指
针指向NULL，防止后边不小心使用了它。

已经释放了的指针，再次被释放的时候会报错，但是释放空指针不会出错，所以释
放了的指针需要赋值为NULL

malloc和new的区别
1. new返回指定类型的指针，并且可以自动计算所需要的大小
2. malloc必须要由我们计算字节数，在返回后强制转换我实际类型的指针
3. malloc只管分配内存，并不能对所得的内存进行初始化，new分配的内存如何
   是对象类型，则会调用类的构造函数初始化

注意用delete释放malloc分配的内存会出错，用free释放用new分配的内存就不
能调用析构函数
*** fgets函数
fgets总结
line[MAXLINE];
fgets(line, 100, stdin);
其行为方式如下：
1. 遇到换行或文件结束EOF则返回
2. 按行读取
3. 对于大小为size的buf，最多只读取size-1个字符
4. 自动把buf中最后一个字符的后面一个字节填充零结束

注意通过fgets读取的字符个数只与函数中传递的读取个数有关，这里为100，与
MAXLINE毫无关系，当输入的字符数超过99的时候也最多只能读取99个字符，但
是如果读取的字符数少于99，那么会自动在字符串后边加上换行符

如果一个文件的当前位置的文本如下
Love ,I Have
但是，如果用　fgets(str1,4,file1);
则执行后str1="Lov"，读取了4-1=3个字符，
而如果用fgets(str1,23,file1);
则执行str1="Love ,I Have"，读取了一行(包括行尾的'\n',并自动加上字符串
结束符'\0')。

*** ssh验证机制
比较详细的认证过程
http://tech.idv2.com/2006/10/21/ssh-rsa-auth/

传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们
在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和
数据。而且，这些服务程序的安全验证方式也是有其弱点的，就是很容易受到
“中间人”(man-in-the-middle)这种方式的攻击。所谓 “中间人”的攻击方式，
就是“中间人”冒充真正的服务器接收你的传给服务器的数据，然后再冒充你把
数据传给真正的服务器。服务器和你之间的数据传送被“中间人”一转手做了手
脚之后，就会出现很严重的问题。

SSH的英文全称是Secure SHell。通过使用SSH，你可以把所有传输的数据进行加
密，这样“中间人”这种攻击方式就不可能实现了，而且也能够防止DNS和IP欺
骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速
度。SSH有很多功能，它既可以代替telnet，又可以为ftp、pop、甚至ppp提供一
个安全的“通道”。

从客户端来看，SSH提供两种级别的安全验证。

第一种级别(基于口令的安全验证)只要你知道远程服务器的用户的帐号和口令，
就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接
的服务器就是你想连接的服务器，可能会有别的服务器在冒充真正的服务器，也
就是受到“中间人”这种方式的攻击。

第二种级别(基于密匙的安全验证)需要依靠密匙，也就是你必须在本地为自己创
建一对密匙，并把公用密匙放在需要访问的远程服务器上。如果你要从本地连接
到远程的SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进
行安全验证。服务器收到请求之后，先在你在该服务器上面的用户的家目录下寻
找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一
致，服务器就用公用密匙加密“质询”(challenge)并把它发送给客户端软件。
客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。
用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级
别不需要在网络上传送口令。

第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能
的(因为他没有你的私人密匙)。但是整个登录的过程可能需要10秒。

两个服务节点直接如何进行验证：
p1作为服务节点，用来接受数据，p2和p3作为客户端节点，向p1节点发送数据。

首先p2和p3分别在本地生成一对密钥，公钥和私钥，并把公钥上传到p1服务器上，
当p2向p1发送数据的时候，会首先进行连接验证。
1. p2发送自己的公钥给p1
2. p1在自己存放公钥的目录中检索是否有p2的密钥，如果有就和发送过来的密
   钥进行对比，如果一致，就进行后续操作，如果不一致连接失败
3. p1随机选取一个字串"hello world"，并用p2的公钥进行加密，然后把加密后
   果的数据发送给p2
4. p2对收到的信息用自己的私钥进行解密，然后把解密信息发送给p1
5. p1接收到信息，然后和原来的字串进行比较，如果相同就说用这个字串是用
   p2的私钥进行解密的，那么发送信息的客户端节点确实是p2,验证结束，建立
   了ssh连接。

** 算法相关
*** 哈希表的尴尬
由于cache命中率的原因，哈希表的性能通常好于红黑树。即使只有32个元素，
也要进行5次随机内存访问。随机内存访问对cpu cache是不友好的。

hash表最大的缺陷是当数据量难以估计时，没法设置合适的bucket，元素可能是
10个也可能是10000个
这里有几种思路：
1. 设置缺省bucket值为100左右，然后让hash表自动扩容，缺点是扩容的时候性
   能要受到影响。
2. 结合业务，每次给10000的bucket，缺点是浪费内存，而且无法处理100W这样
   的极端情况。
3. 把hash表的list变成哈希表，缺点是结构复杂，多次哈希速度慢。
综合来看方案一是比较好的这种。

*** 用磁带机求第K小元素                                                       :第K大元素:
如果输入在磁带机上， 你的机器只有一个磁带机驱动器和几十字的内存，如何
找第K小的数
1. 遍历一遍磁带，随即选择一个数M
2. 再遍历一遍磁带， 计算大于和小于M的个数，这样就可以获得数M在总序列中
   的排名，这里考虑到可能有重复元素所以要统计大于和小于的个数
3. 如果M的排名正好为所求，则结束；否则如果M的排名大于K，则下次遍历磁带
   时随即选择一个小于M的数，统计它的排名；如果M的排名小于K，下次遍历磁
   带的时候随即选择一个大于M的数，统计排名
4. 经过步骤3，所选数的范围缩小，最后就能找到所要求的数
5. 最多遍历磁带2logN次， 每次遍历时间O(n),总时间复杂度为O(nlogn)

目前求第K小的数，比较好的算法时间复杂度为O(n),常数大概为3.4

*** 裁纸机程序
一个字条上边印有一串数字，对字条进行切割，满足一下条件
1. 每个字条上边都有字
2. 所有字条上数字的和小于给定数字

一个长度为n的数字串，共有n-1个位置可以切割，每个位置可以切割也可以不切
割时间复杂度为o(2^(n-1))
#+BEGIN_EXAMPLE
#include <stdio.h>
long long s = 0;
long long k, max = -1;
int flag=0;
void cutpaper(long long d, long long t)
{
    t *= 10;
    if(d < t){
        s += d;
        if(s <k && s >= max){
            if(s==max)
                flag=1;
            else{
                max=s;
                flag=0;
            }
        }
        s -= d;
        return;
    }
    cutpaper(d, t);
    long long temp = d % t;
    d = d/t;
    s += temp;
    cutpaper(d, 1);
    s -= temp;
}

int main()
{
    long long d, t;
    scanf("%ld%ld", &d, &k);
    cutpaper(d, 1);
    if(max >= k)
        printf("not exists\n");
    else if(flag)
        printf("not service\n");
    else
        printf("%ld\n", max);
    return 0;
}
#+END_EXAMPLE

*** 从0-N中随机生成M个数
思路一：先从N个数中随机找出M个，然后对这M个数进行随机排列，时间复杂度
为O(n),空间复杂度为O(M)。
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int s[100];
int f=0;

int getrand(int a, int b)
{
    return a + rand() % (b - a);
}
int in(int a)
{
    for(int i=0;i<f;i++)
        if(s[i]==a)
            return 1;
    return 0;
}

void swap(int i, int j)
{
    int t = s[i];
    s[i]=s[j];
    s[j]=t;
}

int main()
{
    int n,m;
    srand(time(NULL));
    scanf("%d%d", &n, &m);
    for(int i=n-m;i<n;i++){
        int temp=getrand(0, i + 1); #注：这里是 i + 1
        if(!in(temp))
            s[f++]=temp;
        else
            s[f++]=i;
    }
    for(int i=m-1;i>0;i--){
        int temp = getrand(0, i+1);
        swap(i, temp);
    }
    for(int i=0;i<f;i++)
        printf("%d\n", s[i]);
    return 0;
}
#+END_EXAMPLE

思路二：直接从N个数中生成M个随机数
#+BEGIN_EXAMPLE
for(int i=1;i<=N;i++)
    s[i]=i;      #这样保证了生成的数不会重复，缺点是需要O(N)的空间
for(int i =1;i<=M;i++)
    int temp = RandInt(i, N);
    swap(i, temp);
#+END_EXAMPLE

思路三：对思路一中的情况进行了修改,插入S时刻意选择插入的位置，这样可以
制造更好的随机，编程珠玑（续）
#+BEGIN_EXAMPLE
initialize sequence S to empty
for J:=N-M+1 to N do
    T = RandInt(1, J)
    if T is not in S then
       prefix T to S
    else
       insert J in S after T
#+END_EXAMPLE

*** 0-1背包问题                                                               :动态规划:
给定一个整数K和n个不同大小的物品，第i个物品的大小为整数Ki，寻找一个物
品的子集，它们的大小之和为K，或者确定不存在这样的子集。

解题思路：对于n个物品判断是否有几个物品的大小之和为k，如果前n-1个物品
中可以找到几个物品的大小之和为k,则n个物品必然也满足条件，如果前n-1个物
品中不存在几个物品的大小之和为k，假设先把第n个物品放入，则如果前n-1个
物品中可以找到几个物品大小之和为K-Kn，那么也满足条件。

用一个结构体记录，q[i][j]表示当有i个物品的时候，是否可以找到物品的大小
之和为j，同时记录当前物品是否存在于结果中。
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <string.h>

struct node
{
    int exist;
    int belong;
}q[20][50];

int s[20];

void manager(int n,int k)
{
    /* init */
    q[0][0].exist=1;
    for(int i=1;i<=k;i++)
        q[0][i].exist=0;        #初始化
    for(int i=1;i<=n;i++)
        for(int j=0;j<=k;j++) {
            if(q[i-1][j].exist) {
                q[i][j].exist=1;
                q[i][j].belong=0;
            } else if(j>=s[i]) {
                if(q[i-1][j-s[i]].exist) {
                    q[i][j].exist=1;
                    q[i][j].belong=1;
                }
            }
        }
}

int main()
{
    int n,k;
    freopen("plank.in","r",stdin);
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
        scanf("%d",&s[i]);
    memset(q,0,sizeof(q));
    manager(n,k);
    if(q[n][k].exist)
        printf("exist\n");
    else
        printf("not exist\n");
}
return 0;
}
#+END_EXAMPLE

*** 乘法操作 以及用移位实现的乘法操作
解题思路： 对于两个整数97 * 61, 61的二进制形式是0111101
97 * 61 = 97 * （32 + 16 + 8 + 4 + 1）
#+BEGIN_EXAMPLE
#include <iostream>
using namespace std;

int multiple(int a, int b)
{
    int d=0;
    int c=0;                    #代表移位的位数
    while(b){
        if(b%2)                 #判断最低位是0还是1
            d+=a<<c;
        b=b>>1;
        c++;
    }
    return d;
}

int main()
{
    int in, out;
    cin>>in>>out;
    cout<<multiple(in, out)<<endl;
    return 1;
}
#+END_EXAMPLE
*** N次方问题，当N很大时，把N转换为二进制
2的N次方问题：当N很大时，由31 = 16 + 8 + 4 + 2 + 1可以得到启发，2 ^ 31
= 2 ^ 16 * 2 ^ 8 * 2 ^ 4 * 2 ^ 2 * 2 ^ 1.
#+BEGIN_EXAMPLE
#include <stdio.h>

int main()
{
    long N;
    long result = 1;
    long temp = 2;
    int s[128];
    int t = 0;
    scanf("%ld", &N);
    while(N) {
        s[t++]=N%2;
        N/=2;
    }
    for(int i=0;i<t;i++) {
        if(s[i])
            result *= temp;
        temp = temp * temp;
    }
    printf("%ld\n", result);
    return 0;
}
#+END_EXAMPLE
*** 求平方根 求多维空间中两个点间的距离
1. K维空间中有两个点A和B，求它们间的距离
2. 其中最重要的是求平方根操作，使用牛顿迭代可以减小开方操作的时间
3. 先找出A到B的距离中距离最大的一维 并记该距离为M，则A到B的距离值介于M和sqrt(K) * M
   之间
4. 用二分法直到两次求的的距离值小于一定范围为止
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <math.h>
#define exp 1.0e-7

int main()
{
    double A[16]={4,6,2,6,1,9,12,64,43};
    double B[16]={4,6,8,15,31,26,43,17,41};
    double T = A[0]-B[0];
    double max = T;
    double sum= T * T;
    for(int i=1;i<10;i++){
        T =fabs(A[i]-B[i]);
        if(T > max)
            max = T;
        sum += T * T;
    }
    printf("%lf\n", sum);
    if(sum - 0.0 < exp)
        return 0;

    /* 现在已经知道从A到B距离最大的一维的距离max， A到B的距离介于max
     * 和 sqrt(k) * max 之间 */

    /* 方法一 ------------------------------------------------------------------------*//
    double z = max;
    double newz;
    while(1){
        newz = 0.5 * (z + sum / z); #每一步都缩小了newz和精确值的差距
        if(fabs(newz - z) < z * exp)
            break;
        z = newz;
    }
    /* 改进 --------------------------------------------------------------------------*/
    max = max * 2;
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    /* ------------------------------------------------------------------------------*/
    printf("%lf\n", newz);
    return 0;
}
#+END_EXAMPLE
*** 检测链表中是否存在环，并找到相遇点

1. 用两个指针p1和p2都指向链表第一个元素
2. p1向后移动一个元素,p2向后移动两个元素，比较两者是否相等，如果相等表
   明存在环，两个指针相遇
3. p1和p2有一个为NULL则停止
如果存在循环最后肯定能找到，如果不存在最后p2为NULL停止

p1移动距离为s，p2移动距离为2s，链表长度为L，假设相遇点到环入口点距离为
x，链表头到环入口点距离为a，环长度为r，则满足
# 2s = s + nr           s = nr
# a + x = s = nr = (n-1)r + L - a
# a = (n-1)r + L - a -x
# L - a - x 表示相遇点到环入口的距离
# 用两个指针b1 , b2, b1指向链表头， b2指向相遇点，同时开始移动，每次移
# 动一步，最后两个指针必然相遇，并且相遇点就是环的入口点
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <math.h>

void FindLoop(list * head)
{
    list * p1, * p2;
    p1 = p2 = head;
    while(p2 && p2 -> next){
        p1 = p1->next;
        p2 = p2->next->next;
        if(p1 == p2) break;
    }
    if(p2 == NULL || p2->next == NULL)
        return;
    list * t = head;
    while(t != p2){
        t= t->next;
        p2 = p2->next;
    }
    return t;
}
#+END_EXAMPLE
*** 检测两个链表是否相交
方法一：将其中一个链表的首位相连，判断另外一个链表是否有环，如果有则两
个链表相交，否则不想交
方法二： 分别遍历两个链表，获得两个链表的长度n和m，如果两个链表相交，则它们的最
后一部分肯定是相同的，只用判断最后一个元素是否相同，如果相同则表明两个
链表相交，让长度比较长的链表先移动n-m步，然后两个链表再同时移动，第一
次相遇时就到了相交点。

*** 如何判断一个变量时有符号数还是无符号数
#define ISUNSIGNED(a) (a>=0 && ~a>=0)
如果宏的参数是一个类型，其中一个方法是使用类型转换
#define ISUNSIGNED(type) ((type)0 - 1 > 0)
*** 一个文本文件中存入了很多字符串，如何随机的从中选中一个
1. 最简单的方法就是读一次文件，并记录每个字符串到文件开头的偏移量，最
   后随机一个数，打印该数字对应的字符串
2. 如果限制只能读一次文件，并且不能用变量存储字符串的偏移量，该怎么办
   呢？
   1）遍历文件，首先存入第一个字符串，当读入第二个字符串的时候，随机从
   这两个字符串中选择一个保存
   2）再读入一个字符串，从保存的字符串和该字符串中再以相同的概率选择保
   存一个，丢弃另一个，直到文件末尾，则选中任意字符串的概率都是相同的。
*** 判定点是否在多边形内部
思路：二维空间中多个点的连线构成了一个多边形，給一定点p(x, y)，判断该点是否在
多边形内部
1. 沿着定点p做一条直线，判断直线与多边形的交点个数，只算从p到多边形外
   边的交点的个数。
2. 如果交点个数为偶数，则不在多边形内部，如果为奇数则在多边形内部
3. 计算交点个数的时候有一些特例。如果交点为多边形的顶点，则要分两种情
   况；与该顶点相连的两条边如果都在直线的一侧，则不算交点个数，如果在
   两侧则算作一个有效的交点；如果直线与多边形的一条边重合则算作一个有
   效交点。
4. 这里选择直线的时候，可以选择与坐标轴平行的直线。假如选择与y轴平行的
   直线，则判断直线与边是否相交，只用先判断该边的两个顶点(x1, y1),(x2,
   y2),是否有x1<=x&&x2>=x如果满足，再判断该交点的位置。
5. 注意为了防止重复计算，只当交点为多边形的边的右顶点时才算作有效交点

*** poj1503 简单求大整数的和
当输入字符串为0时表示输入结束
错误点：最后验证字符串输入结束的标志是s[0]='0' && s[1]=0

*** B·ellman_ford算法
Bellman-ford算法用来求解最短路径，还可以检测是否存在负环，算法的核心思想是：对每一条边进行n-1次松弛操作，时间复杂度是O(NE),其中N是顶点的个数，E是边的个数。最后检测每一条边是否还可以松弛，如果可以就表明存在负环，否则已经求出了最短路径。
#+BEGIN_EXAMPLE
/**
 * @file   acm.c
 * @author  <kong@kong>
 * @date   Sun Aug 26 22:05:07 2012
 *
 * @brief   Bellman-ford算法 spfa是用队列优化的Bellman-ford算法
 * 对所有边进行n-1次松弛
 *
 */
#include <stdio.h>

int s[10][10];
int dis[20];

struct vedge
{
    int u,v,w;
}vt[20];

int main()
{
    int n,m;
    struct vedge temp;
    int b,t;
    int MAX=1000;
    int point=0;
    freopen("plank.in","r",stdin);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            s[i][j]=MAX;
    for(int i=0;i<m;i++)
    {
        scanf("%d%d%d", &temp.u,&temp.v,&temp.w);
        s[temp.u][temp.v]=temp.w;
        vt[point++]=temp;
    }
    scanf("%d%d",&b,&t);
    for(int i=1;i<=n;i++)
        dis[i]=s[b][i];
    for(int i=0;i<n-1;i++)
        for(int j=0;j<m;j++){
            temp=vt[j];
            if(dis[temp.v]>dis[temp.u]+s[temp.u][temp.v])
                dis[temp.v]=dis[temp.u]+s[temp.u][temp.v];
        }
    /* 检验是否存在负环 */
    for(int j=0;j<m;j++)
    {
        temp=vt[j];
        if(dis[temp.v]>dis[temp.u]+s[temp.u][temp.v])
        {
            printf("false\n");
            break;
        }
    }
    /* for(int i=1;i<=n;i++) */
    /*     printf("%d ", dis[i]); */
    /* printf("\n"); */
    return 0;
}
#+END_EXAMPLE
*** Spfa算法
spfa算法是用队列优化过的Bellman_ford算法，在Bellman_ford算法中对每一
条边都进行了n-1次松弛，时间复杂度是O(NE), 而spfa算法的时间复杂度通常是
O(KE)，通常情况下k<=2,但是spfa算法的稳定性较差，对于稀疏图和稠密图，时
间复杂度变化较大，还有注意spfa算法检测负环的方法是判断是否有顶点进队列
次数超过N次
http://blog.csdn.net/v_july_v/article/details/6181485
#+BEGIN_EXAMPLE
/**
 * @file   spfa.c
 * @author  <kong@kong>
 * @date   Fri Sep 14 23:39:55 2012
 *
 * @brief  spfa算法是用队列优化的Bellman-ford算法,时间复杂度为O(KE)其中K通常不大于2,Bellman-ford算法的时间复杂度为O(VE)
 * Bellman-ford判断是否有负环:  对于每一条边,如果dis[v]>dis[u]+c[u][v]则有负环
 * spfa判断是否有负环的方法是,记录每个顶点进队次数,超过顶点个数V表示有负环,  注意:有负环存在时,spfa算法没法正常结束,因为边距不断在收敛,顶点不停进队
 */
#include <iostream>
#include <fstream>
using namespace std;

#define MAX 1000
int s[101][101];
int dis[101];
int n,b,t;
int exis[101];
int vect[101];

void spfa()
{
    int head,tail;
    for(int i=0;i<101;i++)
    {
        exis[i]=0;
        vect[i]=0;
        dis[i]=MAX;
    }
    head=0;
    tail=1;
    vect[tail]=b;
    exis[b]=1;
    dis[b]=0;
    while(head!=tail)
    {
        head=(head+1)%(n+1);
        /* 出队列 */
        exis[head]=0;
        for(int i=1;i<=n;i++)
        {
            if(dis[i]>dis[vect[head]]+s[vect[head]][i])
            {
                dis[i]=dis[vect[head]]+s[vect[head]][i];
                if(!exis[i])
                {
                    tail=(tail+1)%(n+1);
                    vect[tail]=i;
                    exis[i]=1;
                }
            }
        }
    }
}

int main()
{
    ifstream in("plank.in");
    in>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            in>>s[i][j];
    in>>b>>t;
    spfa();
    for(int i=1;i<=n;i++)
        cout<<dis[i]<<endl;
    return 0;
}
#+END_EXAMPLE
*** 汇率转换问题，判断是否能赚到更多的钱
poj 1806
题意：已知有n种货币，编号为1~n，以及它们之间的瑞换比例。现在Nick有第fir种货币meney元，问你Nick能不能通过这些货币的瑞换规则，使自己拿到更多的fir货币。

思路：bellman_ford。判断有没有正环，有的话Nick就可以无限次使用这个正环使自己的货币增值。
#+BEGIN_EXAMPLE
/**
 * @file   code.c
 * @author  <kong@KONG-PC>
 * @date   Sun Nov 04 21:54:40 2012
 *
 * @brief  求汇率转换问题
 *         采用Bellman_ford算法求是否存在正环，和求最短路径相反，这里
 *         要求最长路径，可以和典型的Bellman_ford一样，对每条边进行V-1
 *         次松弛，然后判断是否存在正环，如果存在则表明可以增加钱数。
 *         这里做了改进，当对每一条边进行V-1次松弛后，所得的钱数不一定
 *         满足要求，所以需要不断松弛，结束条件有两个
 *         1. 所有边都不能再松弛了，表明不存在正环，判断钱数是否满足条
 *         件，返回
 *         2. 经过不断的松弛，满足要求后，返回。
 */
#include <stdio.h>
#include <string.h>
struct{
    int beg, end;
    double r, c;
}edge[204];

int money, m, t;
double value;
double dis[104];

int bell_man()
{
    memset(dis, 0, sizeof(dis));
    dis[t] = value;
    while(dis[t] <= value){
        int change=0;
        for(int i=0;i< 2 * m; i++){
            if(dis[edge[i].end] < (dis[edge[i].beg] - edge[i].c) * edge[i].r){
                dis[edge[i].end] = (dis[edge[i].beg] - edge[i].c) * edge[i].r;
                change=1;
            }
        }
        if(!change)
            return dis[t] > value;
    }
    return 1;
}

int main()
{
    freopen("in", "r", stdin);
    int begin, end;
    double rn, cn, rern, recn;
    int p=0;
    while(scanf("%d%d%d%lf", &money, &m, &t, &value) != -1){
        for(int i=1;i<=m;i++){
            scanf("%d%d%lf%lf%lf%lf", &begin, &end, &rn, &cn, &rern, &recn);
            edge[p].beg=begin;
            edge[p].end=end;
            edge[p].r=rn;
            edge[p++].c=cn;
            edge[p].beg=end;
            edge[p].end=begin;
            edge[p].r=rern;
            edge[p++].c=recn;
        }
        if(!bell_man())
            printf("NO\n");
        else
            printf("YES\n");
    }
    return 0;
}
#+END_EXAMPLE

*** DP动态规划问题
1. 转移方程
2. 初始值
*** 动态规划求RMQ(区间最值问题Range Minimum/Maximum Query) 有点小问题，代码中注释之处
求RMQ最简单的方法是遍历区间，时间复杂度O(n), 但是当查询次数很多的时候，
时间效率并不高。可以用线段树把算法优化到O(logn) (在线段树中保存线段的
最值)，不过sparse_table算法是较好的，用O(nlogn)的时间进行预处理，然后
用O(1)时间进行查询。
预处理:
预处理使用DP的思想，f(i, j)表示[i, i+2^j - 1]区间中的最小值，我们可以开辟一个数组专门来保存f(i, j)的值。
例如，f(0, 0)表示[0,0]之间的最小值,就是num[0], f(0, 2)表示[0, 3]之间的最小值, f(2, 4)表示[2, 17]之间的最小值
注意, 因为f(i, j)可以由f(i, j - 1)和f(i+2^(j-1), j-1)导出, 而递推的初值(所有的f(i, 0) = i)都是已知的
所以我们可以采用自底向上的算法递推地给出所有符合条件的f(i, j)的值。
查询:
假设要查询从m到n这一段的最小值, 那么我们先求出一个最大的k, 使得k满足2^k <= (n - m + 1).
于是我们就可以把[m, n]分成两个(部分重叠的)长度为2^k的区间: [m, m+2^k-1], [n-2^k+1, n];
而我们之前已经求出了f(m, k)为[m, m+2^k-1]的最小值, f(n-2^k+1, k)为[n-2^k+1, n]的最小值
我们只要返回其中更小的那个, 就是我们想要的答案, 这个算法的时间复杂度是O(1)的.
例如, rmq(0, 11) = min(f(0, 3), f(4, 3))
注意：这里空间复杂度为 O(n * n),可以采用动态数组的方法，只用两列.
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <string.h>
#include <math.h>
#define max(a,b) ((a)>(b)?(a):(b))

int map[100][100];
/**
 * 花费O(nlogn)的时间进行预处理 递推公式
 * f[i,j]=max(f[i, j-1], f[i + 2^(j-1), j-1])
 * @param m 存储数值的数组
 * @param n 数组长度
 */
void pre_handle(int * m , int n)
{
    memset(map, 0, sizeof(map));
    for(int i=0;i<n;i++)
        map[i][0]=m[i];
    int k = (int)(log(n) / log(2));
    for(int i=1;i<=k;i++)       /* i表示列，j表示行, 每一列的结果只依赖于前一列 */
        for(int j = 0; j + pow(2,i-1) < n; j++)
            /* 注意因为每列都限制j + pow(2,i-1) < n，而除了第一列以外
             * 其它都不到n-1，所有每一行的最后一个数有可能是不对的，但
             * 是不影响最后结果 */
            map[j][i]=max(map[j][i-1], map[j+(int)pow(2, i-1)][i-1]);
}

int RMQ(int a, int b)
{
    int k = (int)(log(b-a+1)/log(2)); /* 区间长度为b-a+1 */
    /* 两个区间之间有重合 */
    return max(map[a][k], map[b+1-(int)pow(2, k)][k]);
}

int main()
{
    freopen("in", "r", stdin);
    int n;
    int m[100];
    scanf("%d", &n);
    for(int i=0;i<n;i++)
        scanf("%d", &m[i]);
    pre_handle(m, n);
    printf("%d\n", RMQ(2, 10));
    printf("%d\n", RMQ(20, 30));
    return 0;
}
#+END_EXAMPLE
*** 树的公共祖先问题LCA
树的公共祖先问题可以分为在线法和离线法,在线法就是来一个请求就处理一次，
离线法就是收集所有请求然后统一给出回复。

**** 1. 在线法。LCA可以转换为RMQ
1） 对树进行dfs，访问每个节点时要记录节点的层次，同时要记录每个节点第一次出现的位置，对于节点个数为n的树，最后会形成一个2n-1长度的序列
2） 如果要查询节点a和节点b的公共祖先，只需找出a和b节点在在序列中第一次
出现的位置，形成了一个从a到b的子序列， 对应序列中层数最小的节点即为公
共祖先。
3） 因此把LCA转化为RMQ问题。对于给定序列求出指定区间中的最小值
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <malloc.h>

#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)>(b)?(b):(a))

struct tree{
    int n;
    int left, right;
}p[100];

int first[9];
int sequence[20];
int dep[20];
int point=0;
int deep=0;

/* 建树 */
int createTree()
{
    int temp[8]={1,2,7,3,4,8,5,6};
    for(int i=0;i<8;i++)
        p[i].n=temp[i];
    p[0].left=1;p[0].right=2;
    p[1].left=3;p[1].right=4;
    p[2].left=-1;p[2].right=5;
    p[3].left=-1;p[3].right=-1;
    p[4].left=6;p[4].right=7;
    p[5].left=-1;p[5].right=-1;
    p[6].left=-1;p[6].right=-1;
    p[7].left=-1;p[7].right=-1;
    return 0;
}

/* 结点访问顺序是: 1 2 3 2 4 5 4 6 4 2 1 7 8 7 1 共2n-1个值 */
/* 结点对应深度是: 0 1 2 1 2 3 2 3 2 1 0 1 2 1 0 */
void dfs(int root)
{
    if(p[root].n < 0)
        return;
    sequence[point]=p[root].n;
    dep[point]=deep;
    if(first[p[root].n] < 0)
        first[p[root].n]=point;
    point++;
    if(p[root].left > 0){
        deep++;
        dfs(p[root].left);
        deep--;
        sequence[point]=p[root].n;
        dep[point]=deep;
        point++;
    }
    if(p[root].right > 0){
        deep++;
        dfs(p[root].right);
        deep--;
        sequence[point]=p[root].n;
        dep[point]=deep;
        point++;
    }
}

int map[100][100];
/**
 * 花费O(nlogn)的时间进行预处理 递推公式
 * f[i,j]=max(f[i, j-1], f[i + 2^(j-1), j-1])
 * @param m 存储数值的数组
 * @param n 数组长度
 */
void pre_handle(int * m , int n)
{
    memset(map, 0, sizeof(map));
    for(int i=0;i<n;i++)
        map[i][0]=dep[i];
    int k = (int)(log(n) / log(2));
    for(int i=1;i<=k;i++)       /* i表示列，j表示行, 每一列的结果只依赖于前一列 */
        for(int j = 0; j + pow(2,i-1) < n; j++)
            /* 注意因为每列都限制j + pow(2,i-1) < n，而除了第一列以外
             * 其它都不到n-1，所有每一行的最后一个数有可能是不对的，但
             * 是不影响最后结果 */
            map[j][i]=min(map[j][i-1], map[j+(int)pow(2, i-1)][i-1]);
}

int RMQ(int a, int b)
{
    int k = (int)(log(b-a+1)/log(2)); /* 区间长度为b-a+1 */
    /* 两个区间之间有重合 */
    return min(map[a][k], map[b+1-(int)pow(2, k)][k]);
}


int main()
{
    int root = createTree();
    memset(first, -1, sizeof(first));
    dfs(root);
    pre_handle(sequence, point);
    printf("%d\n", RMQ(4, 11));
    return 0;
}
#+END_EXAMPLE
**** 2. 离线法。Tarjan
算法主要是采用dfs+并查集
#+BEGIN_EXAMPLE
/**
 * @file   code.c
 * @author  <kong@KONG-PC>
 * @date   Mon Dec 03 20:52:03 2012
 *
 * @brief  Tarjan算法，基本思想是深度优先遍历+并查集，利用并查集可以将
 * 查询两个数字是否在一个集合中的操作变为O(1)
 */

#include <stdio.h>
#include <vector>
using namespace std;
#define N 100

vector<int> tree[N],request[N]; /* 用来记录子节点和对应节点的询问信息 */
int ancestor[N];                /* 记录节点的祖先节点 */

int visit[N];                   /* 记录节点的访问情况 */
int p[N];                  /* 临时记录并查集中的父亲节点，在遍历的过程
                            * 中它的值会不断变化 */
int rank[N];

void init(int n)
{
    for(int i=0;i<n;i++)
    {
        rank[i]=1;              /* 初始化所在集合的节点个数 */
        p[i]=i;
        visit[i]=0;
        ancestor[i]=-1;          /* 把所有节点的祖先节点先初始化为-1 */
        tree[i].clear();
        request[i].clear();
    }
}

/* 返回并查集的根节点 */
int find(int t)
{
    if(p[t]==t)
        return t;
    return p[t]=find(p[t]);     /* 在查询的过程中对并查集进行优化，使
                                 * 用路径压缩 */
}
/* 合并两个集合，使用启发算法，将深度较小的树指到深度较大的树的根上，
 * 可以防止树的退化 */
int unionSet(int a, int b)
{
    int m=find(a);              /* 首先获取m,n所在集合的根元素 */
    int n=find(b);
    if(m==n)
        return 0;
    if(rank[m]>=rank[n])        /* 判断两个集合的rank值，并把值小的并
                                 * 到值大的集合中 */
    {
        p[n]=m;
        rank[m]+=rank[n];
    }
    else
    {
        p[m]=n;
        rank[n]+=rank[m];
    }
    return 1;
}
/* 深度优先遍历+并查集 */
void LCS(int t)
{
    ancestor[t]=t;
    for(int i=0;i<(int)tree[t].size();i++)
    {
        LCS(tree[t][i]);
        unionSet(tree[t][i],t);
        ancestor[p[t]]=t;
    }
    visit[t]=1;
    for(int i=0;i<(int)request[t].size();i++)
        if(visit[request[t][i]]==1)
            printf("%d %d  %d\n", t, request[t][i],ancestor[p[request[t][i]]]); /* 这里需要知道request[t][i]所在集合的祖先节点 */
}

int main()
{
    freopen("in","r",stdin);
    int n,t,r;                  /* 分别表示节点个数、边的个数和询问个
                                 * 数 */
    int a,b;
    scanf("%d%d%d",&n,&t,&r);
    init(n);                    /* 初始化结构 */
    while(t--)                  /* 读入树结构 */
    {
        scanf("%d%d",&a,&b);
        tree[a].push_back(b);
    }
    while(r--)                  /* 读入询问并存入对应的列表中 */
    {
        scanf("%d%d",&a,&b);
        request[a].push_back(b);
        request[b].push_back(a);
    }
    LCS(0);
    return 0;
}
#+END_EXAMPLE
*** 求最大子序列和
问题描述：有一串数字，可正可负也可为0，连续两个或多个数字组成了一个子
序列，每个子序列都有一个和，求出所有子序列中和最大的一个。
例如输入的数组为3 6 -7 -1 4 3 -2 -5 10 -3,则和最大的子序列为3 6 -7 -1
4 3 -2 -5 10,最大和为11

分析： 这个问题容易想到的方法是计算出任意两点之间的序列和，取出它们中的最大值，
时间复杂度为O(n^2)

程序员编程艺术上提到一种二分的方法，将序列分成左右两个部分，分别计算出
左右两个部分的连续最长子序列，再求出端点分别在左右两边的连续最长子序列，
它们三个中的最大值就是整个序列上的最长连续子序列，时间复杂度是O(nlogn)
#+BEGIN_EXAMPLE
#include <stdio.h>
#define M 100

int a[M];

int max_sum(int left,int right)
{
    int leftmax,rightmax;       /* 左边和右边的最大值 */
    int leftside,rightside;     /* 暂时从中间到左边和右边的最大值 */
    int leftsidemax, rightsidemax; /* 记录从中间到左边和右边的最大值 */

    if(left==right)

        return a[left]>0?a[left]:0;
    leftside=leftsidemax=0;
    rightside=rightsidemax=0;

    int middle=(left+right)/2;
    leftmax=max_sum(left,middle);
    rightmax=max_sum(middle+1,right);

    /* 求出从中间到左边的最大连续和 */
    for(int i=middle;i>=left;i--)
    {
        leftside+=a[i];
        if(leftside>leftsidemax)
            leftsidemax=leftside;
    }
    /* 求出从中间到右边的最大连续和 */
    for(int i=middle+1;i<=right;i++)
    {
        rightside+=a[i];
        if(rightside>rightsidemax)
            rightsidemax=rightside;
    }
    int maxside=leftmax>rightmax?leftmax:rightmax;
    int middleside=leftsidemax+rightsidemax;
    int max=maxside>middleside?maxside:middleside;
    return max;
}

int main()
{
    freopen("in","r",stdin);
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    int max = max_sum(0, n-1);
    printf("%d\n", max);
}
#+END_EXAMPLE

将数字存放在数组中，下标从0到n-1，假如已经求出以i为末尾的最大连续子序
列之和为sum[i],则如果要求以i+1为结尾的最大连续子序列的和sum[i+1],有
sum[i+1]=sum[i]>0 ? sum[i]+a[i+1] : a[i+1];找出它们中的最大值
#+BEGIN_EXAMPLE
int a[M];
int sum[M];

int max_sum(int left, int right)
{
    int max=0;            #考虑全是负数的情况改为max=a[left]
    sum[left]=a[left];
    for(int i=left+1;i<=right;i++)
    {
        sum[i]=sum[i-1]>0?sum[i-1]+a[i]:a[i];
        if(sum[i]>max)
            max=sum[i];
    }
    return max;
}
#+END_EXAMPLE

条件：只有1M可用内存空间，磁盘空间足够大

归并排序：但是题目限制只有1M可用内存空间
位图：由于题目的特殊性每个数都不超过10^7，并且没有重复整数，可以用10^7
位来表示每个整数，如果存在这个整数就把改为置为1，否则置为0，然后再顺序
遍历数组，检测每一位是否存在，如果存在就打印输出，这样最后所有数都有序。
但是使用的内存空间为10^7/8，大概是1.25MB，因此需要分两次读取数据，第
一次读取小于10^7/2的整数，有序输出，第二次再读取大于10^7的整数，内存也
够用。

#+BEGIN_EXAMPLE
#include <stdio.h>
#include <stdlib.h>
#define width 5000000

int bit[(width>>5)+1];          /* 注意:移位操作符优先级比算术操作符低 */

void clear(int i)
{
    bit[i>>5] &= ~(1<<(i%32));
}

void set(int i)
{
    bit[i>>5] |= 1 <<(i & 31);
}
int test(int i)
{
    return bit[i>>5]&(1<<(i & 31));
}
int main()
{
    FILE * fpin, *fpout;
    int d;
    fpin=fopen("in","r");
    if(fpin==NULL)
        exit(1);
    for(int i=0;i<width;i++)
        clear(i);
    /* 由于内存容量限制，将磁盘文件分两批排序，第一匹先排序前半部分 */
    while(fscanf(fpin,"%d", &d)!=EOF)
        if(d < width)
            set(d);

    fpout=fopen("out","w");
    if(fpout==NULL)
        exit(1);

    for(int i=0;i<width;i++)
        if(test(i))
            fprintf(fpout,"%d\n",i);

    int length=fseek(fpin,0,SEEK_SET);
    if(length)                  /* 定位正确返回0 */
        exit(1);

    for(int i=0;i<width;i++)
        clear(i);
    while(fscanf(fpin,"%d", &d)!=EOF)
        if(d >= width && d < 10000000)
            set(d-width);

    for(int i=0;i<width;i++)
        if(test(i))
            fprintf(fpout,"%d\n",i+width);
    return 0;
}
#+END_EXAMPLE
*** 给定a b两个文件，各存在50亿个URL，每个URL各占64字节，内存限制是4G，让你找出a b文件中共同的URL
看到要找两个文件的共同元素，想到要使用Hashset,把一个文件中的内容映射入
Hashset中，然后遍历另外一个文件的每一个元素，判断是否在Hashset中存在，
如果存在，表明是两个文件共有的。
但是这种方法需要内存容量大约为5G * 64 = 320G,显然无法放入内存，一个通
用的方法是想办法把一个不能放入内存中的大文件分成小文件，然后分别对小文
件进行处理之后再进行合并。

至于如何把大文件分成小文件，通常采用hash的方法，对于这题使用hash() % 1000把大文件分为1000个小文件，每个小文件的大小大概为330MB,使用同样的hash()把a b分别分
为1000个小文件，这样a b中共同出现的URL就出现在1000对小文件中，不对应的小文件，不可能存在相同的URL

用hashset分别找出这1000对小文件中相同的URL即可

*** 积水问题
有这样一块土地，可以被划分为M*N块正方形小块，每块面积是一平方英寸，第i行第j列的小块可以表示成P(i,j)，这块土地高低不平，每一小块地P(i,j)都有自己的高度H(i,j),一场倾盆大雨后，由于这块地地势高低不同，许多低洼的地方都积存了不少降水，如果已经知道了这块土地的详细信息，求出它最多能积存多少立方英寸的降水
分析：先分析一些比较容易求出的格子，例如边界，边界上积水上一定为0，从边
界上最低的格子x开始，它就像是一个有洞的水桶，桶的容量取决于最低的那个
洞，假设这个格子的高度为h，那么它相邻格子y的水位不会超过h，如果y的高度
小于h，那么y的水位将是h，可以继续对y周围的格子进行灌水，直到这块水全部
被高度大于h的地势包围起来，实际上是把高度大于h的地方和已经确定水位的地
方看做是障碍物，然后从格子x开始做一次floodfill,则填好的格子水位全是h，
并且这个格子周围的土地全部应该标记为已访问过，并把这些位置放入堆中。这
样每次从堆中取出一个位置最低的点，处理它周围的点，直到堆的大小减为0。
每个格子最多被访问一次，每次调整堆的操作时间复杂度为O(logmn),因此总的
时间复杂度为O(mnlogmn)
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <string.h>
#define M 10
#define N 10

int map[M][N];                  /* 存储每块正方形的高度 */
int flag[M][N];                 /* 表示禁止积水 */
int treenode=0;                 /* 表示堆中节点个数 */
int water=0;                    /* 记录注入的水量 */
int m,n;
struct node
{
    int i,j;
    int height;                 /* 表示土地的高度 */
    node(){}
    node(int a, int b, int h){
        i=a;
        j=b;
        height=h;
    }
};

struct node tree[M*N];          /* 用来表示堆中节点 */

void swap(node * a, node * b)
{
    node t = *a;
    *a=*b;
    *b=t;
}
void siftdown(int i)
{
    int c=i;
    if(2*i<=treenode)
        c=2*i+1;
    if(2*i+1<treenode && tree[2*i+1].height<tree[c].height)
        c=2*i+1;
    if(tree[i].height>tree[c].height)
    {
        swap(&tree[i],&tree[c]);
        siftdown(c);
    }
}
void siftup(int i)
{
    while(i/2>0)
    {
        if(tree[i].height<tree[i/2].height)
            swap(&tree[i],&tree[i/2]);
        i/=2;
    }
}

void createTree()
{
    for(int i=treenode/2;i>0;i--)
        siftdown(i);
}

/* 返回堆顶最小元素，并用最后一个元素替换，调整堆 */
node deleteNode()
{
    struct node temp=tree[1];
    tree[1]=tree[treenode--];
    siftdown(1);
    return temp;
}
/* 插入节点 */
void insert(node t)
{
    tree[++treenode]=t;
    siftup(treenode);
}

void slove()
{
    /* 每次从堆中取出一个节点，并处理它周围的节点，直到堆的大小为0 */
    while(treenode>0)
    {
        node t = deleteNode();
        int a = t.i;
        int b = t.j;
        /* 处理上下左右四个方向的点 */
        if(a-1>=1 && !flag[a-1][b])
        {
            if(map[a-1][b]<t.height)
            {
                water+=t.height-map[a-1][b];
                map[a-1][b]=t.height;
            }
            /* 对位置进行标记 */
            flag[a-1][b]=1;
            insert(node(a-1,b,map[a-1][b]));
        }
        if(a+1<=m && !flag[a+1][b])
        {
            if(map[a+1][b]<t.height)
            {
                water+=t.height-map[a+1][b];
                map[a+1][b]=t.height;
            }
            flag[a+1][b]=1;
            insert(node(a+1,b,map[a+1][b]));
        }
        if(b-1>=1 && !flag[a][b-1])
        {
            if(map[a][b-1]<t.height)
            {
                water+=t.height-map[a][b-1];
                map[a][b-1]=t.height;
            }
            flag[a][b-1]=1;
            insert(node(a,b-1,map[a][b-1]));
        }
        if(b+1<=n && !flag[a][b+1])
        {
            if(map[a][b+1]<t.height)
            {
                water+=t.height-map[a][b+1];
                map[a][b+1]=t.height;
            }
            flag[a][b+1]=1;
            insert(node(a,b+1,map[a][b+1]));
        }
    }
}

int main()
{
    freopen("in","r",stdin);
    memset(flag,0,sizeof(flag));
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&map[i][j]);
    for(int i=1;i<=m;i++)
    {
        insert(node(i,1,map[i][1]));
        flag[i][1]=1;
        insert(node(i,n,map[i][n]));
        flag[i][n]=1;
    }

    for(int i=2;i<n;i++)
    {
        insert(node(1,i,map[1][i]));
        flag[1][i]=1;
        insert(node(m,i,map[m][i]));
        flag[m][i]=1;
    }
    slove();
    printf("%d\n", water);
    return 0;
}
#+END_EXAMPLE

*** Bloom filter/Bitmap
使用范围：实现数据字典，进行数据的判重，集合求交集
基本原理：基于bitmap，bitmap中用一个bit位来表示一个数字，而Bloom
filter是用多个bit位是否同时存在来判定元素是否存在。它的实现用到了位数
组和k个hash函数，存入一个元素时，用k个hash函数分别求值，并将响应的bit
位置1，当查找的时候，根据k个hash值，到k个位置查找，如果k个位置都存在，
表明该元素存在，如果有一个bit位不存在表明元素不存在。很明显这个过程并
不保证查找结果是百分百正确。同时它也不支持删除一个已经插入的关键字，因
为该关键字对应的位会牵动其它的关键字，一个简单的改进是使用counting
bloom filter,用一个counter数组来替换位数组，就可以支持删除了。

还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小以及
hash函数个数k

当hash函数个数k=(ln2)*(m/n)时错误率最小，在错误率不大于E的情况下，m至
少要等于n*lg(1/E)才能表示任意n个元素的集合，因为要保证bit数组里至少一
半为0，则应该满足m>=n*lg(1/E) * lge,大概就是n*lg(1/E)的1.44倍(lg表示以
2为底的对数)

举个例子，我们假设错误率为0.01，则此时m应该大概是n的13倍，k大概是8个

注意m是以bit为单位，而n则是以元素个数为单位，通常单个元素的长度都是有
很多bit的，所以使用Bloom filter通常很节省内存

扩展：Counting bloom filter将数组中的每一位扩展为一个counter，从而支持
了元素的删除操作，而Spectral Bloom Filter将其与几何元素的出现次数惯量，
SBF采用counter中的最小值来近似表示元素出现的频率

*** 一个很好的字符串hash函数
这是一个很有用的hash函数，它对长短字符串都很有用，推荐作为字符串的hash
函数。

#+BEGIN_EXAMPLE
int ElFhash(char * key)
{
    unsigned long h=0;
    while(*key)
    {
        h=(h<<4) + *key++;
        unsigned long g=h & 0Xf0000000L;
        if(g)
            h^=g>>24;
        h&=~g;
    }
    return h%M
}
#+END_EXAMPLE
*** 从Hadoop框架与MapRebduce模式中谈海量数据处理
1. Mapreduce是一种模式
2. Hadoop是一种框架
3. Hadoop是一个实现了mapreduce模式的开源的分布式并行编程框架

Hadoop是一个实现了mapreduce计算模型的的开源分布式并行编程框架，程序员
可以借助于Hadoop编写程序，将所编写的程序运行于计算机集群上，从而实现对
海量数据的处理。

此外Hadoop还提供了一个分布式文件系统HDFS及分布式数据库HBase用来将数据
存储或部署到各个节点上。所以可以大致认为：Hadoop=HDFS (文件系统)+
HBase（数据库） + MapReduce(数据处理)。

借助Hadoop 框架及云计算核心技术MapReduce 来实现数据的计算和存储，并且将HDFS 分布式文件系统和HBase 分布式数据库很好的融入到云计算框架中，从而实现云计算的分布式、并行计算和存储，并且得以实现很好的处理大规模数据的能力。

# Hadoop HDFS是Google GFS存储系统的开源实现，主要应用场景是作为并行计算
环境（MapReduce）的基础组件，同时也是BigTable（如HBase、HyperTable）的
底层分布式文件系统。HDFS采用master/slave架构。一个HDFS集群是有由一个
Namenode和一定数目的Datanode组成。Namenode是一个中心服务器，负责管理文
件系统的namespace和客户端对文件的访问。Datanode在集群中一般是一个节点
一个，负责管理节点上它们附带的存储。在内部，一个文件其实分成一个或多个
block，这些block存储在Datanode集合里。

Hadoop MapReduce是一个使用简易的软件框架，基于它写出来的应用程序能够运行在由上千个商用机器组成的大型集群上，并以一种可靠容错的方式并行处理上TB级别的数据集。

# 一个MapReduce作业（job）通常会把输入的数据集切分为若干独立的数据块，由 Map任务（task）以完全并行的方式处理它们。框架会对Map的输出先进行排序，然后把结果输入给Reduce任务。通常作业的输入和输出都会被存储在文件系统中。整个框架负责任务的调度和监控，以及重新执行已经失败的任务。

注意: reduce过程前会先对数据进行排序，这里使用的排序方法是归并排序。

# Hive是基于Hadoop的一个数据仓库工具，处理能力强而且成本低廉。

主要特点：

存储方式是将结构化的数据文件映射为一张数据库表。提供类SQL语言，实现完
整的SQL查询功能。可以将SQL语句转换为MapReduce任务运行，十分适合数据仓
库的统计分析。

*** 从B 树、B+ 树、B* 树谈到R 树
动态查找树主要有：二叉查找树、平衡二叉查找树、红黑树、B树/B树的变形。
前三者是典型的二叉查找树结构，其查找的时间复杂度O(logn)与树的深度相关，
降低树的深度自然会提高查找效率

在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取/写
入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘
中的数据，需要一种合理高效的外存数据结构,这就用到了B-tree结构，以及相
关变种结构:B+树结构和B*树结构

1. B-树 又叫平衡多路查找树
B树是为了磁盘或者其它存储设备而设计的一种多叉平衡查找树，与红黑树相似，
但在降低磁盘I/O操作方面要更好一些。许多数据库系统都一般使用B树或者B树
的各种变形结构来存储信息

B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个。然
而和红黑树一样，一颗含有n个结点的B树的高度也为O(logn)，但可能比红黑树
的高度小许多，因为它的分支因子比较大。B树可以再O(logn)时间内，实现各种
如插入、删除等动态集合操作。

一颗m阶的B树的定义如下：
1. 每个节点最多有m个孩子
2. 除了根节点每个节点最少有m/2个孩子
3. 若根节点不是叶子节点那么最少有两个孩子
4. 一个非叶子节点如果包含k-1个关键字，那么就拥有k个孩子节点
5. 所有的叶子节点都在同一层

注意：真正的数据信息都存储在叶子节点中，所有叶子节点都在同一层中。

** 面试资料
*** binder简介
client server services manager

server向services manager注册服务，client向services manager发出请求，services manager返回给
客户端一个binder的引用

android启动过程中，会生成一个services manager进程，它通过ioctl向binder进行注册，以后每生成
一个新的进程都会拥有一个默认的句柄指向services manager，默认值是0

ServiceManager进程通过ioctl告诉内核自己是ServiceManager，这时驱动会为它建立一个Binder节点
。假设某个服务想要被系统内其它进程访问到，那它必须先去ServiceManager注册，他知道
ServiceManager的句柄是0，所以通过系统调用告诉Binder驱动他想要和ServiceManager通信，驱动看
到他引用的是0就知道他想访问ServiceManager，就会为该Service建立一个指向ServiceManager的
Binder节点的Binder引用。
这样Service就可以向ServiceManager发数据，ServiceManager也可以通过刚刚获得的句柄主动向
service发数据，但ServiceManager获得的句柄并不止这个用处。ServiceManager分析收到的数据包里
的其它数据，知道对方service想要注册成服务，就调用自身的addService方法，把对方发过来的服务
名和接受到的handle值填入一张映射表，服务名和handle值一一对应。

注册成功以后，servicemanager就可以主动向Services发送消息了。

当某个Client通过名字向ServiceManager请求获得某个Service的句柄时，他们的建立通信的过程和前
面Service与ServiceManager的过程一样，ServiceManager得到数据中的服务名，调用自己的
getService得到指定服务的句柄，并返回给客户端，客户端获得了服务的句柄之后就可以和server通信
了
*** 启动过程
init进程
解析init.rc文件
启动本地服务 zygote servicesamanger mediaserver

AndroidRuntime.c
zygote:
建立java运行环境
建立java虚拟机
创建socket
预加载类和资源
创建systemserver
轮询监听socket   接收ActivityManangerService的请求，Fork应用程序

systemserver:
启动java服务  并且注册到ServiceManager上

ActivityManagerService.systemReady()
startHomeActivityLocked()
*** 设计模式
迪米特法则：开放封闭原则，对扩展开放对修改封闭。  面向接口编程
里氏代换原则：一个软件实体中，可以把父类都替换成它的子类，程序行为没有变化

创建模式、结构模式、行为模式


单例模式：在整个应用中仅含有一个该类的实例

工厂模式根据抽象程度的不同分为三种，简单工厂模式、工厂方法模式、抽象工厂模式

简单工厂模式：所有的该类对象都由一个工厂来生产

工厂方法模式：有四个要素。工厂接口、工厂实现、产品接口、产品实现。降低了耦合度，定义一个用
于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。也就是说
，工厂方法模式将简单工厂内部的逻辑判断移到了客户端来进行

抽象工厂模式：核心工厂不再负责具体对象的构造，而是根据传入的参数，返回一个对应的工厂对象，
然后由该工厂对象来构造具体对象

门面模式(外观模式)：感觉是Service层的一个翻版，为子系统中的一组接口提供一个一致的界面，此
模式定义了一个高层接口

策略模式：策略模式指定一组算法，将每一个算法封装到具有公共接口的独立的类中，从而使它们可以
相互替换。

迭代器模式：提供一种方式访问容器对象中的各个元素，而又不需要暴露该对象的内部细节

适配器模式：在原型不做任何改变的情况下，扩展了新的接口。可以采用继承或者聚合的方式来实现适
配器模式

装饰模式：为已有功能动态地添加更多功能的一种方式，I/O里用的最多
具体实现
#+BEGIN_EXAMPLE
class A{
   void insert(){
        ....
   }
}

class B{
    private A a;
    private AnotherObject o = new AnotherObject();
    public B(A a){
        this.a=a;
    }

    void insert(){
         o.dosomething();
         a.insert();
    }

    public static void main(String args[]){
         A a = new A();
         B b = new B(a);
         b.insert();
    }
}
在不改变原有类的情况下动态增加功能，并且将多出来的功能用对象封装起来
#+END_EXAMPLE

聚合表示一种弱的拥有关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一
种强的拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样

合成模式(组合模式)：将众多对象组合成树形结构

观察者模式：一个Subject可以有多个Observer，Subject内部用一个变量存储了所有依附于它的
Observer，当Subject状态发生改变的时候，就遍历通知所有观察者来自动更新自己

原型模式：通过原型类克隆自身从而创建一个新的对象

模版方法模式：先定义好逻辑处理的框架，然后将一些步骤放到子类中来实现，具体就是在一个抽象类
中定义好框架，在具体子类中实现这些抽象方法，并且不同的子类有不同的实现

享元模式：

代理模式：不让客户端直接访问目标对象，而是通过一个代理，把客户端的请求通过该代理对象传递给
目标对象

责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接 起来形成一条链。请求在
这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个
请。用户发出一个请求，同时有多个handler可以处理该请求，将这些handler连成一条链，请求沿着传
递该请求，直到有一个对象处理它为止

命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化

调停者模式(中介者模式)：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示的互
相调用，从而使其耦合松散

备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样
以后就可以将该对象恢复到原先保存的状态

单一职责原则：仅有一个可以引起对象发生变化的原因

桥梁模式：


创建模式：用来创建对象的实例。如单例模式
结构模式：用于帮助将多个对象组织成更大的结构，如适配器模式、桥接模式、组合器模式等
行为模式：维护多个对象间复杂的逻辑关系，如命令行模式

*** hashset和hashmap的区别
HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。

对于 HashSet 而言，它是基于 HashMap 实现的，HashSet 底层采用 HashMap 来保存所有元素，
HashSet的绝大部分方法都是通过调用 HashMap 的方法来实现的，因此 HashSet 和 HashMap 两个集合在实现本质上是相同的

对于HashSet中保存的对象，请注意正确重写其equals和hashCode方法，以保证放入的对象的唯一性

注意HashMap是哈希表的链地址法实现，用key得到hash值，然后找到在数组中的相应位置，在链表中查找指定的key值，如果不存在就在链表头部插入

*** +和append的区别
两个字符串相加操作的时候，+号会被编译器优化成stringbuilder的append操作，stringBuffer的append也会被优化成 stringbuilder的append操作，使用两个string相加的时候会多创建两个对象，也没有append操作安全
*** linux的通信方式
File
Signal
Socket
Message queue
Pipe
Named pipe
Semaphore
Shared memory
Message passing
Memory-mapped file

*** session.get和session.load
get不支持lazy,load支持lazy, get如果不存在数据,返回null,load如果不存在返回异常
*** hibernate管理对象的生命周期
transient Persistent Detached

Transient save persist或者saveorupdate之后变成Persistent
session关闭之后变成Detached状态
*** 操作系统知识
http://blog.csdn.net/hackbuteer1/article/details/6787354
*** STL知识
**** hash_map
http://blog.csdn.net/sdhongjun/article/details/4517325
**** hash_set
http://blog.csdn.net/morewindows/article/details/7330323
*** sed命令以及对应的perl命令
sed命令替换，删除
比如，要将目录/modules下面所有文件中的zhangsan都修改成lisi，这样做：
sed -i 's/zhangsan/list/g' `grep zhangsan -rl /modules`

-i表示inplace edit，就地修改文件
-r表示搜索子目录
-l表示输出匹配的文件名

（1）sed 'y/1234567890/ABCDEFGHIJ/' test_sed
sed 'y/1234567890/ABCDEFGHIJ/' filename
ABCDEFGHIJ
BCDEFGHIJA
CDEFGHIJAB
DEFGHIJABC
注意变换关系是按两个list的位置对应变换
其中：test_sed的内容是：
1234567890
2345678901
3456789012
4567890123

(2)替换每行所有匹配
sed 's/01/Ab/g' test_sed
1234567890
23456789Ab
3456789Ab2
456789Ab23
注意：第一行的0，1没有分别替换为A,b


删除：d命令
     $ sed '2d' example-----删除example文件的第二行。
     $ sed '2,$d' example-----删除example文件的第二行到末尾所有行。
     $ sed '$d' example-----删除example文件的最后一行。
     $ sed '/test/'d example-----删除example文件所有包含test的行。

替换：s命令
     $ sed 's/test/mytest/g' example-----在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。
     $ sed -n 's/^test/mytest/p' example-----(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。
     $ sed 's/^192.168.0.1/&localhost/'example-----&符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加localhost，变成192.168.0.1localhost。
     $ sed -n 's/\(love\)able/\1rs/p' example-----love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。
     $ sed 's#10#100#g' example-----不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。

选定行的范围：逗号
     $ sed -n '/test/,/check/p' example-----所有在模板test和check所确定的范围内的行都被打印。
     $ sed -n '5,/^test/p' example-----打印从第五行开始到第一个包含以test开始的行之间的所有行。
     $ sed '/test/,/check/s/$/sed test/' example-----对于模板test和west之间的行，每行的末尾用字符串sed test替换。

多点编辑：e命令
$ sed -e '1,5d' -e 's/test/check/'example-----(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。
     $ sed --expression='s/test/check/' --expression='/love/d' example-----一个比-e更好的命令是--expression。它能给sed表达式赋值。

从文件读入：r命令
     $ sed '/test/r file' example-----file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。

写入文件：w命令
     $ sed -n '/test/w file' example-----在example中所有包含test的行都被写入file里。

追加命令：a命令
     $ sed '/^test/a\\--->this is a example' example<-----'this is a example'被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。

插入：i命令 $ sed '/test/i\\
new line
-------------------------' example
如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。
下一个：n命令
     $ sed '/test/{ n; s/aa/bb/; }' example-----如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。

变形：y命令
     $ sed '1,10y/abcde/ABCDE/' example-----把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。

退出：q命令
     $ sed '10q' example-----打印完第10行后，退出sed。

保持和获取：h命令和G命令
$ sed -e '/test/h' -e '$Gexample-----在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。

保持和互换：h命令和x命令
     $ sed -e '/test/h' -e '/check/x' example -----互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。

      7. 脚本

Sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。

     8. 小技巧

     在sed的命令行中引用shell变量时要使用双引号，而不是通常所用的单引号。下面是一个根据name变量的内容来删除named.conf文件中zone段的脚本：
     name='zone\ "localhost"'
sed "/$name/,/};/d" named.conf

sed -i "s/oldstring/newstring/g" `grep oldstring -rl yourdir`

例如：替换/home下所有文件中的www.itbbs.cn为chinafar.com

sed -i "s/www.itbbs.cn/chinafar.com/g" `grep www.itbbs.cn -rl /home`

二、下面这条命令：
perl -pi -e 's|ABCD|Linux|g' `find ./ -type f`
将调用perl执行一条替换命令，把find命令找到的所有文件内容中的ABCD替换为Linux

find ./ -type f
此命令是显示当前目录下所有的文件

上面的“s|ABCD|Linux| g”是perl要执行的脚本，即把所有ABCD替换为Linux
如果不写最后的那个g，“s|ABCD|Linux| ”将只替换每一行开头的ABCD


当编辑指令(参照[section2.2])在命令列上执行时,其前必须加上选项-e。其命令格式如下:

sed-e'编辑指令1'-e'编辑指令2'...文件档

其中,所有编辑指令都紧接在选项-e之後,并置於两个"'"特殊字元间。另外,命令上编辑指令的执行是由

左而右。

一般编辑指令不多时,使用者通常直接在命令上执行它们。

例如,删除yel.dat内1至10行资料,并将其馀文字中的"yellow"字串改成"black"字串。此时,可将编辑指令直接在命令上执行,其命令如下:

sed-e'1,10d'-e's/yellow/black/g'yel.dat

在命令中,编辑指令'1,10d'(解[5])执行删除1至10行资料;编辑指令's/yellow/black/g'(解[6]),

"yellow"字串替换(substuite)成"black"字串。

2.2sed的编辑指令

sed编辑指令的格式如下:

[address1[,address2]]function[argument]

其中,位址参数address1、address2为行数或regularexpression字串,表示所执行编辑的资料行;函数参

数function[argument]为sed的内定函数,表示执行的编辑动作。

下面两小节,将仔细介绍位址参数的表示法与有哪些函数参数供选择。

2.2.1位址(address)参数的表示法

实际上,位址参数表示法只是将要编辑的资料行,用它们的行数或其中的字串来代替表示它们。下面举几个例子

说明(指令都以函数参数d(参照[section4.2])为例):

删除档内第10行资料,则指令为10d。

删除含有"man"字串的资料行时,则指令为/man/d。

删除档内第10行到第200行资料,则指令为10,200d。

删除档内第10行到含"man"字串的资料行,则指令为10,/man/d。

接下来,以位址参数的内容与其个数两点,完整说明指令中位址参数的表示法(同样也以函数参数d为例)。

位址参数的内容:

位址为十进位数字:此数字表示行数。当指令执行时,将对符合此行数的资料执行函数参数指示的编辑动作。例如,

删除资料档中的第15行资料,则指令为15d(参照[section4.2])。其馀类推,如删除资料档中的第m行资料,则

指令为md。

位址为regularexpression(参照[附录A]):

当资料行中有符合regularexpression所表示的字串时,则执行函数参数指示的编辑动作。另外,在

regularexpression前後必须加上"/"。例如指令为/t.*t/d,表示删除所有含两"t"字母的资料行。其中,"."

表示任意字元;"*"表示其前字元可重任意次,它们结合".*"表示两"t"字母间的任意字串。

位址参数的个数:在指令中,当没有位址参数时,表示全部资料行执行函数参数所指示的编辑动作;当只有一位址

参数时,表示只有符合位址的资料行才编辑;当有两个位址参数,如address1,address2时,表示对资料区执行

编辑,address1代表起始资料行,address2代表结束资料行。对於上述内容,以下面例子做具说明。

例如指令为

d

其表示删除档内所有资料行。

例如指令为

5d

其表示删除档内第五行资料。

例如指令为

1,/apple/d

其表示删除资料区,由档内第一行至内有"apple"字串的资料行。

例如指令为

/apple/,/orange/d

其表示删除资料区,由档内含有"apple"字串至含有"orange"字串的资料行

2.2.2有那些函数(function)参数

下页表中介绍所有sed的函数参数(参照[chapter4])的功能。

函数参数功能

:label建立scriptfile内指令互相参考的位置。

** 总结
1. linux中如何查找一个命令 find whereis which locate

find：在磁盘中搜索，功能最强大，但是由于要遍历搜索，效率比较低

whereis：命令只能用于程序名的搜索,找不到的时候可能与搜索路径有关系

locate：linux系统会将系统内的所有文件都记录在一个数据库文件中/var/lib/mlocate/mlocate.db，当使用locate时，不用搜索具体目录，而是从数据库中查找数据，但是该数据库并不是实时更新，默认情况下是一天更新一次，因此使用locate查找文件时，会找到已经被删除的文件，刚刚建立文件可能没有被数据库收录无法查找到，可以使用updatedb命令,手动更新数据库

which：在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令

简单的说：
locate是在数据库中查找，数据库有一定的更新周期
whereis可以找到可执行命令和man page
find就是根据条件查找文件
which通过PATH环境变量到该路径内查找可执行文件，基本功能是查找可执行文件

2. 如何强制杀死一个进程
kill -9 pid 或者
kill -KILL
可以强制杀死

3. System.out.print中的out是PrintStream类型
但是System.in里边的in是InputStream类型

public class PrintStream extends FilterOutputStream implements Appendable, Closeable

public class FilterOutputStream extends OutputStream

可见PrintStream也是OutputStream类型
-----------------------------------------------------------
Scanner in = new Scanner(System.in);
public Scanner(InputStream source) {
        this(new InputStreamReader(source), WHITESPACE_PATTERN);
}
在scanner是用InputStreamReader对InputSteam进行了包装


PrintWriter writer = new PrintWriter(System.out);
public PrintWriter(OutputStream out) {
	this(out, false);
}

public PrintWriter(OutputStream out, boolean autoFlush) {
	this(new BufferedWriter(new OutputStreamWriter(out)), autoFlush);

	// save print stream for error propagation
	if (out instanceof java.io.PrintStream) {
	    psOut = (PrintStream) out;
	}
}
可见PrintWriter是用OutPutStreamWriter和BufferedWriter对OutputStream进行了封装

4. string str = new String();编译不通过
5. <?xml version="1.0" encoding="utf-8" ?>
6. 查看路由表的两种方式
   route -e
   netstat -r

7. $? 是显示最后命令的退出状态，0表示没有错误，其它表示有错误
   $$是脚本运行的当前进程ID号
   $@是传给脚本的所有参数列表
   $#是传给脚本的参数个数
   $0是脚本本身的名字
   $1是传递给该shell脚本的第一个参数
   $2是传递给该shell标本的第二个参数

8.  查看内核版本命令
    cat /proc/version
    uname -a

    查看linux版本号
    cat /etc/issue
    lsb_release -a

9. 如何创建同名文件

10. linux中文件类型
- 表示普通文件
d 表示目录
p 表示命名管道
l 表示符号链接

* 2. Android知识
** 编译框架基本概念
Android编译系统是通过各种.mk文件和shell脚本建立的一个编译框架，这个框
架基于基本的make概念。换句话说Android并没有建立新的编译脚本，而是建立
了一个框架，便于给该框架添加新的子项目。
Android编译系统的源码在./build目录下，了解编译系统的本质实际上是分析这
个脚本文件之间的相互关系。
整个编译系统主要由三部分组成，分别为编译中枢、子项目及输出路径。
编译中枢：主要包括各种.mk文件，这些文件将遍历所有子项目，并生成target。
子项目：每个子项目中都有必须包含一个Android.mk文件。
输出路径：包含编译过程所保存的各种临时文件，输出路径也是在编译中枢中定
义的，默认是out目录。
** Android中的三种不同编译方式
make mm mmm
make：最常规的编译，通常用来编译整个Android源码
mm：用来编译当前目录下的所有子项目
mmm： 用来编译指定目录下的所有子项目

* 3. 零碎笔记
1. c中
char  一个字节
int   四个字节
long  四个字节
long long 八个字节

2. 简单的把较小的浮点数和较大的浮点数相加可能会丢失精度。一种较好的算法是把集合中最小的两个数相加，类似于构建哈夫曼码的算法。

3. printf("%.*s\n", len, s); 这里len限制了要输出的字符长度。

4. 注意建堆的时间复杂度是O(n)不是O(nlogn)

5. jvm为了效率问题，并没有把long和double当做一个64位的长整形来使用，而
   是把它分为两个32-bit，分别交付
   x.high_word=value.high_word;
   x.low_word=value.low_word;
   一次存在一个线程设置了高位之后被另外一个线程交换出去，而改变了其高
   位或者低位的值，存在同步问题，需要synchronized关键字

* 4. 错误记录
** 0298E Unable to allocate remote transaction program: Descriptive message
解决方法：首先查看端口8044-8047，如果端口监听正常，那么查看所使用参数
是否正常，如果get file，请使用REMOTE_FILE_FR LOCALE_FILE_FR 和
REMOTE_SYSTEM_RF选项。

如果是send job那么请使用参数LOCAL_FILE_
** 0286E Error setting local user id
这种情况下，首先对可执行文件a.out进行以下操作
chrgp xcomadm a.out
chmod 6555 a.out
如果对于java可执行文件，需要把相应的java和.so文件都使用上述命令进行权
限修改

如果以上操作仍不奏效，查看源文件中的queue参数是否被显式的赋值为yes，如
果没有请修改参数

** 发送文件的大小为0
解决方法：修改codeflag参数，如果为binary修改为ascii
* 5. 网页收集
http://wenjun.in/?p=84

* 6. 工作计划
** TODO 后缀树
** TODO 后缀数组
** TODO java webservice
** TODO Delvik虚拟机和Java虚拟机的区别 Android技术内幕
** TODO 一致性哈希表 布隆过滤器
** TODO select 和 poll有什么区别
** TODO RMI远程方法调用 SOAP简单对象访问协议 CORBA通用对象请求代理架构
** TODO JNDI java命名目录服务接口
** TODO 迷宫生成算法http://maskray.me/posts/2012-11-02-perfect-maze-generation.html
http://bbs.byr.cn/#!article/ACM_ICPC/23147
** TODO STL
