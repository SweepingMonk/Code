* 笔记
** 个人笔记
*** 配置emacs
 **** emacs快捷键
 | 命令类型                           | 快捷键          | 快捷键描述                             |
 |------------------------------------+-----------------+----------------------------------------|
 | 查找                               | C-s C-w         | 在查找模式下，查找光标指定位置处的单词 |
 | 指定目录下查找文件                 | find-name-dired |                                        |
 | 指定目录下查找只包含指定内容的文件 | find-grep-dired |                                        |
 | 与上边两个类似但自由度最高         | find-dired      | gre                                    |
**** 10.16 ecb 和 全屏显示 
配置ecb   darkroom 和 win32fullscreen
其中darkroom和win32fullscreen都可以实现全屏显示
主要用到了四个文件w32-fullscreen.el w32toggletitle.exe
darkroom-mode.el frame-local-vars.el
将w32toggletitle.exe放在path目录中，其它三个el文件都配置在init.el文件
中
**** 10.17 sr-speedbar
新增sr-speedbar功能，使speedbar可以在同一个frame中显示，不用重新开启一
个frame
下载sr-speedbar.el文件，在init.el文件中添加 (require 'sr-speedbar)
**** 10.17 查看历史打开文件 和历史编辑记录
recentf-open-files命令  C-c o按键
goto-last-change        C-c k 查看立即编辑记录
**** 10.17 查看历史编辑记录
使用goto-last-change命令回到上次编辑的位置，快捷键是C-c k   快捷键C-c
h被ecb占用
**** 10.17 用iexp命令在org模式插入括号
C-x p  you may try.
**** 10.18 emacs打开文件的字符编码问题
使用命令revert-buffer-with-coding-system手动选择打开文件的字符编码，
在保存的时候还可以指定文件的保存编码，使用命令
set-buffer-file-coding-system
**** 10.18 emacs配置etags
find -name "*.[chCH]" -print | etags - 命令用来生成TAGS
visit-tags-table 用来查找指定的TAGS
成功配置etags 
f5可以查找TAG，f6可以查找当前TAG,C-f6可以回跳
*** 学习Lisp
**** List命令
| 关键字 | 简介                                 |
|--------+--------------------------------------|
| first  | 返回列表的第一个元素                 |
| rest   | 返回列表中除了第一个元素外的其它元素 |
| car    | 作用同first，区别不详                |
| cdr    | 作用同rest，区别不详                 |
| cons   | 构造函数，两个参数                   |
| append | 连接两个列表                         |
| List   | 返回一个由所有参数组成的列表         |
**** Lisp推荐书籍
SICP 麻省理工的本科教材，实例以schema表示
On Lisp 是迄今为止讲Lisp的书籍里最深的一本，适合有一定基础的人看，有一
定难度。
Successful Lisp 适合做入门教材
Practical Common Lisp 提供了很多面向对象的实例，但不推荐
**** Lisp特性
自动内存回收 显示类型 闭包
Lisp凌驾于面向对象程序设计 动态的面向对象语言
**** 学习Lisp 基本操作符
Lisp 的 7 个公理（基本操作符）
操作符一： quote
(quote x) 返回x
操作符二： atom
(atom x) 当 x 是一个原子或者空表时返回原子 t，否则返回NIL
操作符三： eq
(eq x y) 当 x 和y 指向相同的对象的时候返回t，否则返回NIL，值得注意的是
在Common Lisp中，原子对象在内存中只会有一份拷贝，所以(eq 'a 'a)返回t
操作符四： car
(car x) 要求 x 是一个表，它返回 x 中的第一个元素
操作符五： cdr
(cdr x) 同样要求 x 是一个表，它返回x中除第一个元素之外的所有元素组成的
表
操作符六： cons
(cons x y) 返回一个cons cell (x y)，如果y不是一个list，将会一dotted
pair形式展现这个cons cell

*多重的cons cell就构成了表*
(cons 'a (cons 'b (cons 'c ())))
(a b c)

操作符七： cond
(cond (p1 e1) ...(pn en)) 的求值规则如下. 对“条件表达式p”依次求值直
到有一个返回t. 如果能找到这样的p表达式,相应的“结果表达式e”的值作为整
个cond表达式的返回值.
(cond ((eq 'a 'b) 'first)  ((atom 'a)  'second))

**** Lisp高级属性
*构造函数*
cons
(cons 'lions '(tigers bears)) cons带有两个参数，一个原子和一个列表，
cons将原子作为第一个原子添加到该列表中。
append
(append '(lisons) '(tigers bears)) append连接两个列表
list
(list 'lions 'tigers 'bears) list包含一个有所有参数组成的列表

使用cons和first rest可以构建任何列表或者列表片段

*循环操作*
数循环
(dotimes (i 10) (print i))
打印列表
(dolist (i '(0 1 2 3 3 4 5 6)) (print i))
常见的do操作
(do ((i 0 (+ 1 i))) ((> i 10)) (print i))

** 学习笔记
*** java编程
**** 面向对象的三个基本特征
封装、继承和多态
封装：把客观的数据和操作封装成抽象的类，只暴露一些对外的接口，具体实现
对外不可见。
继承：通过继承，它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这
些功能进行扩展。
多态：对于同一个调用，父类的不同子类执行不同的操作。
多态的实现方式有两种，覆盖和重载。覆盖就是覆盖父类中的同名函数，参数
列表和返回值都必须相同。重载就是存在多个同名函数，参数列表不同，包括参
数个数不同或者参数类型不同，或者两者都不同，返回值随意。
**** 网络通信
***** java获取本机地址的方式
InetAddress.getByName("localhost") #结果总是127.0.0.1
InetAddress.getLocalHost();     #得到本机的有效网络地址
***** java中创建socke超时的解决办法
Socket s = new Socket("time....", 13); #创建一个Socket连接
s.setSoTimeOut(1000);                  #设置socket获取信息的超时时间

这里有一个问题，创建socket也有一个时间，如果连接不到服务器就会一直阻塞，
这里哟一个办法，先创建一个未连接的套接字，然后把该套接字连接到给定的地
址。
Socket s = new Socket();   #设置创建socket的超时时间
s.connect(new InetSocketAddress("time...", 13), 1000);
s.setSoTimeOut(1000;        #设置获取信息的超时时间
**** 数据库操作
***** 数据库连接
注意在使用mysql时，要首先加载mysql驱动程序类
Class.forName("com.mysql.jdbc.Driver");
或者使用System.setProperty("jdbc.drivers", "com.mysql.jdbc.Driver");
***** 数据库设计自增操作
如果要在某一列上设置自增操作，该列绝大多数时间必须是主键
#+BEGIN_EXAMPLE
create table student(id int(4) primary key auto_increment,name
varchar(20), age int)
创建一个student表，并且设置主键自增

对于自增字段插入时，如果指定要插入的列则不需要特殊处理，否则自增的列插
入null即可
insert into student values(null, 'xiaoming', 20)
#+END_EXAMPLE

***** 存储过程
sql语句执行的时候要先编译，然后执行。存储过程（Stored Procedure）是一
组为了完成特定功能的SQL语句集，经编译后存储在数据库中。用户通过指定存
储过程的名字并给出参数（如果该存储过程带有参数）来执行它。

数据库存储过程的实质就是部署在数据库端的一组定义代码以及SQL。

mysql存储过程实现过程
（1）MySQL存储过程是在“命令提示符”下创建的，所以首先应该打开“命令提示符”窗口。
（2）进入“命令提示符”窗口后，首先应该登录MySQL数据库服务器，在“命令提示符”下输入如下命令：
mysql –u用户名 –p用户密码
（3）更改语句结束符号，本实例将语句结束符更改为“//”。代码如下：
delimiter //
说明:存储过程用以;作为结束符，而;又是命令行下sql语句的结束符，所以要进
行更改
（4）创建存储过程前应首先选择某个数据库。代码如下：
use 数据库名
（5）delimiter ;
（6）创建存储过程。
（7）通过call语句调用存储过程。

存储过程示例:
#+BEGIN_EXAMPLE
create procedure pr_add
(
a int,
b int
)
begin
declare c int;
-- 用来声明局部变量
-- DECLARE仅被用在BEGIN ... END复合语句里，并且必须在复合语句的开头，在任何其它语句之前。
if a is null then
set a = 0;
end if;
if b is null then
set b = 0;
end if;
set c = a + b;
select c as sum;
/*
return c;
不能在 MySQL 存储过程中使用。return 只能出现在函数中。
*/
end;

#执行：
set @a = 10;
set @b = 20;
call pr_add(@a, @b);

create procedure pro_sort(a int)
begin
if a=0
then
select * from student order by age desc;   -- 降序排列
else
select * from student order by age asc;    -- 升序排列
end if;
end;

#创建 MySQL 存储过程的简单语法为：

create procedure 存储过程名字()
(
[in|out|inout] 参数 datatype
)
begin
MySQL 语句;
end;
#+END_EXAMPLE
删除存储过程
DROP PROCEDURE  IF  EXISTS存储过程名
不能在一个存储过程中删除另一个存储过程，只能调用另一个存储过程

***** 存储过程参数的三种形态
见示例
http://www.exampledepot.com/egs/java.sql/CallProcedure.html
*** c编程
**** 类型提升 不怎么准  在ANSI C中已经取消了
整型提升，就是char,short,int和位段类型(无论signed或unsigned)以及枚举类
型将被提升为int，前提是int能够完整的容纳原先的数据，否则将被转换为
unsigined int。float将被转换为double类型，任何数组将被转换为相应类型的
指针。
char c1,c2;
c1 = c1 + c2;
运算的时候，把每个变量的值提升为int的长度，然后对int执行加法，然后对运
算结果进行裁剪。
试试sizeof('c')的值
注意：另一个会发生隐式类型转换的地方就是参数传递，由于函数的参数也是表
达式，所以也会发生类型提升，在被调用函数的内部，提升后的参数被裁剪为原
先声明的大小。

**** fgets()函数
fgets(s, n, stdin);
函数最多接收n-1个字符，并自动在字符串最后加上结束符号，如果输入字符个
数少于n-1，会接收回车符，然后在后边加上字符串结束标志，所以如果输入字
符个数少于n-1的时候，后边多了一个回车符号，注意手动去除.
s[strlen(s)-1]=0
**** swap交换两个元素 注意情况
*a ^= *b;
*b ^= *a;
*a ^= *b;
当a,b指向同一个元素时，该元素最后会被置为0，如果不是同一个元素，可以正
常交换
*** 系统编程
**** 可执行文件的内存布局
可执行文件内部主要包括文本端text，数据段data，和BSS段，用size命令可以
查看可执行文件a.out的大小。
数据段主要放置的是经过初始化的全局变量和静态变量，注意是经过初始化的，
如果没有被初始化则会放在BSS段，文本段主要放置可执行程序的指令。
局部变量并不进入a.out，它们在运行时创建。

**** 进程的地址空间
注意：进程的地址空间和可执行程序的内存空间不太一样。
它除了包括上边的文本段，数据段和BSS段之外，还需要保存堆栈段，用于保存
局部与函数的数据。
同时，注意虚拟地址空间的最低部分未被映射，它位于进程的地址空间中，但并未赋予
物理地址，所有对它的引用都是非法的，在典型情况下，它是地址零开始的几K
字节，用于捕获使用空指针和小整形值的指针引用内存的情况。
堆栈段占据进程空间的最高地址，并向下增长。
**** 段错误和BUS错误
常见的段错误和BUS错误，BUS错误通常是由于数据在内存中不对齐引起的
#+BEGIN_EXAMPLE
union{ char a[10];
       int i;
}u;
int * p = (int *)&(u.a[1]);
*p = 17;
#+END_EXAMPLE
在实例中，数组a在共用体中是和int对齐的，所以a[1]必然不和int对齐，然后
在这个地方放入一个4字节的数据会引发BUS错误。

段错误比较常见，通常是
1. 坏指针值错误。在指针赋值前就用它来引用内存，指针释放后再将它置为空
   值。
2. 改写错误。 数组越界。
3. 释放链表出错。
**** 捕捉信号signal
使用头文件signal.h,使用句柄函数signal(SIGSGEV, handler)
常见的错误信号值SIGBUS,SIGSGEV,SIGILL
**** unix系统中逐字符输入的两种实现
一种是把I/O设置为raw状态，可以实现阻塞式读入，如果终端没有字符输入，进
程就一直等待，直到有字符输入为止。
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int c;
    /* 中断驱动原来处于普通的一次一行模式*/
    /* 把终端设置为raw状态可以实现阻塞式读入*/
    system("stty raw");
    while(1){
        /*现在驱动处于一次一字符的模式*/
        c=getchar();
        putchar(c);
        if(c=='q')
            break;
    }
    /* 终端驱动又处于一次一字符的方式 */
    system("stty cooked");
    return 0;
}
#+END_EXAMPLE

另外一种方式是使用ioctl(),这样只有当一个字符等待被读入时，进程才进行读
取，这种类型的I/O被称为轮询，就好像你不断地询问设备的状态，看看它是否
有字符要传给你。

#+BEGIN_EXAMPLE
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/ioctl.h>

int kbhit()
{
    int i;
    /* 设置I/O轮询 */
    ioctl(0, FIONREAD, &i);
    return i;
}

int main()
{
    int i=0;
    int c=' ';
    system("stty raw -echo");
    printf("enter 'q' to quit \n");
    for(;c!='q';i++){
        if(kbhit()){
            c=getchar();
            printf("\n got %c, on iteration %d", c, i);
        }
    }
    system("stty cooked echo");
}
#+END_EXAMPLE
**** 函数库调用和系统调用的区别
system是一个库函数 strlen并不调用任何系统调用
函数库调用是语言或应用程序的一部分，而系统调用是操作系统的一部分
系统调用时用户程序和内核交互的接口
| 函数库调用                                  | 系统调用                                     |
|---------------------------------------------+----------------------------------------------|
| 在所有的ansi c编译器版本中，c库函数是相同的 | 各个操作系统的系统调用时不同的               |
| 它调用函数库中的一个程序                    | 它调用系统内核的服务                         |
| 与用户程序相联系           important        | 是操作系统的一个入口点                       |
| 在用户地址空间执行         important        | 在内核地址空间执行                           |
| 它的运行时间属于用户时间    important       | 它的运行时间属于系统时间                     |
| 属于过程调用，开销较小      important             | 需要切换到内核上下文环境然后再切换回来开销大 |
| 在C函数库libc中有大约300个程序              | 在unix中有大约90个系统调用(MS-DOS)中少一些   |

自己总结
| 函数库调用             | 系统调用             |
|------------------------+----------------------|
| 通常提供比较复杂的功能 | 通常提供一种最小界面 |

#+BEGIN_EXAMPLE
int main()

{
    int fd = create("filename",0666);

    exit(0);
}
#+END_EXAMPLE
在执行main函数时，是在user mode下执行，当遇到create函数时，继续在user
mode下执行，然后将filename和0666两个参数压入栈中寄存器，接着调用库函数
create，系统仍然处于user mode。
这里的库函数create实际上调用了内核的系统调用create，执行到这里后，系统将create系统调用的unique number压入寄
存器，然后执行指令trap使系统进入kernel mode(执行int $0x80产生中断)。
这时系统意识到要进行系统调用的invoke，于是从刚才的寄存器中取出create系统调用的unique number，从系统调用表中得知要invoke的系统调用是create，然后执行。执行完毕返回库函数create的调用，库函数负责检查系统调用的执行情况(检查某些寄存器的值)，
然后库函数create根据检查的结果返回响应的值。

这里trap指令类似于一个系统中断并且是软中断，而系统调用create类似于一个中断处理函数
所有的系统调用都与上边的情况类似，靠中断机制切换到内核模式实现。

系统调用通常比库函数要慢，因为要把上下文环境切换到内核模式

**** 内核开发的特点
+ 内核编程时不能访问C库，也不能访问标准的C头文件
+ 内核编程时必须使用GNU C
+ 内核编程时缺少像用户空间那样的内存保护机制
  内核中的内存都是不分页的，每用掉一个字节，物理内存就减少一个字节。
+ 内核编程时难以执行浮点运算
  不要轻易在内核中使用浮点数
+ 内核给每个进程只有一个很小的定长堆栈
  内核栈的大小是两页，32位机的内核栈是8KB，而64位机是16KB，固定不变，
  每个处理器都有自己的栈。用户空间的栈比较大，而且通常可以动态增长，
  DOS不可以。
+ 内核支持异步终端，抢占和SMP，因此必须时刻注意同步和并发
  同步和并发
  内核很容易产生竞争。和单线程的用户空间程序不同，内核的许多特性都要求
  能够并发地访问共享数据。
  + Linux是抢占式多任务操作系统
  + Linux支持对称多处理器系统
  + 中断是异步到来的
    中断异步到来，完全不顾及当前正在执行的代码。如果不加以适当的保护，
    中断完全有可能在代码访问资源的时候到来，这样中断处理程序就有可能访
    问同一资源
  + Linux内核可以抢占。所以如果不加以适当保护，内核中一段正在执行的代
    码可能会被另外一段代码抢占，从而有可能导致几段代码同时访问相同的资
    源。

    常用的解决竞争的方法是自旋锁和信号量。

**** 文件描述符和文件指针的区别
在linux系统中把设备和普通文件也都看做是文件，要对文件进行操作就必须先打开文件，
打开文件后会得到一个文件描述符，它是一个很小的正整数，是一个索引值。

内核会为每一个运行中的进程在进程控制块pcb中维护一个打开文件的记录表，
每一个表项都有一个指针指向打开的文件，上边的索引值是记录表的索引值。

文件描述符的优点：兼容POSIX标准，许多系统调用都依赖于它；缺点是不能移
植到unix之外的系统上去。

文件指针：c语言中使用的是文件指针而不是文件描述符来作为I/O的句柄，文件
指针指向进程的用户空间中一个FILE结构的数据结构，FILE结构里主要包括一个
I/O缓冲区和一个文件描述符，而文件描述符值是文件描述符表中的一个索引，
从某种意义上将文件指针就是句柄的句柄(在Window中文件描述符被称为文件句
柄)。

文件指针的优点：是c语言中的通用格式，便于移植。

既然FILE结构中含有文件描述符，那么可以使用fopen来获得文件指针，然后从
文件指针获取文件描述符，文件描述符应该是唯一的，而文件指针却不是唯一的，
但指向的对象是唯一的。

C语言文件指针域文件描述符之间可以相互转换
int fileno(FILE * stream)
FILE * fdopen(int fd, const char * mode)

open和fopen的区别

| open                      | fopen                       |
|---------------------------+-----------------------------|
| open返回一个文件描述符    | 返回FILE *                  |
| 无缓冲                    | 有缓冲                      |
| 与write()和read()配合使用 | 与fwrite()和fread()配合使用 |


FILE的结构
#+BEGIN_EXAMPLE
struct _iobuf {
        char *_ptr;          //缓冲区当前指针
        int   _cnt;
        char *_base;         //缓冲区基址
        int   _flag;         //文件读写模式
        int   _file;         //文件描述符
        int   _charbuf;      //缓冲区剩余自己个数
        int   _bufsiz;       //缓冲区大小
        char *_tmpfname;
        };
typedef struct _iobuf FILE;

int fd = open("TAGS", O_RDONLY);
FILE * fp = fopen("TAGS", "r");
printf("%d %d\n", fd, fp->_file);
可以从文件指针中获取文件描述符

fileno(fp) 和fp->_file效果是一样的
FILE * fp = fdopen(fd, "r") 根据文件描述符加上访问模式可以得到文件指针
#+END_EXAMPLE

** 面试经验收集
*** 百度某部门 java研发
研一小硕一枚，本科我邮计算机，玩了四年，在论坛上看到百度忘记哪个部门招java实习生，就投了简历凑了凑热闹 
先是电面，问了几个比较基础的问题，比如.equals()和==的区别，Spring中IOC和AOP什么意思，还有java中collection框架的架构..然后有人通知面试，这勉强算第一面 
下午到百度，然后先做了一个小时的笔试题，大概能做出来一半吧..发现他们问的题都很底层，比如SSH，不会问你怎么用，而是问你怎么理解它的设计思想的..貌似有个Hibernate中的懒加载..就果断不会了...Java也是很底层的，印象比较深的有个问什么叫unchecked Exception和checked Exception....当时只知道有RuntimeException...就随便写了写.还有设计模式的东西，面java肯定要问设计模式的..后来感觉笔试仅仅是给你一个表现自己的机会，有个题不会也不要紧，把与题目相关的东西，知道多少就写多少... 
交完卷子等了半个小时然后来了个美女mm来二面...先是讲了项目上的东西，问了很多关于SSH和Flex里面的东西..看到我项目里面用过Ibatis/Mybatis..然后巴拉巴拉讨论了很多，比如Ibatis/Hibernate的区别以及Ibatis/Mybatis的区别，还有使用时的细节...然后又问了很多java基础的知识..设计模式的时候问了个单例模式，之前在一本书上看过单例模式有线程安全和线程不安全的两种写法，就巴拉巴拉讲了一大堆..还问了很多线程方面的知道。数据库方面先出了一个题让我写一个SQL语句，然后让我自己写一个我能想到最复杂的Sql语句..我的项目里面有涉及到数据库设计的，又讨论了很多.. 
二面结束了让我在原地等着..后来来了一个看着就像大牛的员工来三面..三面问的东西各种发散各种宽广..差不多五分钟一道题问了一个小时....印象比较深的是HashMap/HashSet的内部实现原理，还好之前看过它们的源码..这个问题不要简简单单的回答散列表...看看源码就会知道里面还有好多重要知识...还有+号和append的区别..线程的实现方式以及优缺点..以及我对java中collection框架的看法..还有很多SSH方面的问题..具体的忘了...算法问了一个全排列的递归和非递归，编程之美上面有的..还有一个二分查找 
三面完了让我在那里等..一般实习生最多就是三面..我就在那里等结果..出来一个HR姐姐对我说项目头儿想面我..让我明天下午来..当时我就凌乱了..我是下午一点半开始笔试的...面到五点半.. 
第二天下午四面，面试官问的知识更发散了..有个问题是让我自己设计一套jdk我该怎么设计...当时我就凌乱了...反正也没正确答案就胡诌了一堆东西..然后问了很多代码优化的东西，问我对自己参与过的项目代码的优化经历以及有什么想法..还有对设计模式的理解和看法..反正问的都是没有正确答案的，要靠自己的经历总结和归纳，当时是能想多少就说多少...我的项目里面涉及到数据库的不少,问了一个内存数据库的问题..就是把数据库放在内存中需要注意哪些问题...问题很发散...和面试官巴拉巴拉聊了两个小时..然后让我回去等消息 
在回去的地铁上收到了HR的电话让去报道..
虽然因为某些原因最终还是没有去百度实习..这次面试获益匪浅啊..一次电面，一次笔试，然后三面.. 
java基础方面一定要扎实..能看源码最好看源码..以前学的太漂了..
框架方面主要理解思想跟设计方法..比较注重于概念..
数据库设计跟Sql的书写还是挺重要的
算法这次问的倒不多..估计跟岗位有关系吧..

* 各种有趣问题
** 用磁带机求第K小元素                                                         :第K大元素:
如果输入在磁带机上， 你的机器只有一个磁带机驱动器和几十字的内存，如何
找第K小的数
1. 遍历一遍磁带，随即选择一个数M
2. 再遍历一遍磁带， 计算大于和小于M的个数，这样就可以获得数M在总序列中
   的排名，这里考虑到可能有重复元素所以要统计大于和小于的个数
3. 如果M的排名正好为所求，则结束；否则如果M的排名大于K，则下次遍历磁带
   时随即选择一个小于M的数，统计它的排名；如果M的排名小于K，下次遍历磁
   带的时候随即选择一个大于M的数，统计排名
4. 经过步骤3，所选数的范围缩小，最后就能找到所要求的数
5. 最多遍历磁带2logN次， 每次遍历时间O(n),总时间复杂度为O(nlogn)

目前求第K小的数，比较好的算法时间复杂度为O(n),常数大概为3.4

** 裁纸机程序
一个字条上边印有一串数字，对字条进行切割，满足一下条件
1. 每个字条上边都有字
2. 所有字条上数字的和小于给定数字

一个长度为n的数字串，共有n-1个位置可以切割，每个位置可以切割也可以不切
割时间复杂度为o(2^(n-1))
#+BEGIN_EXAMPLE
#include <stdio.h>
long long s = 0;
long long k, max = -1;
int flag=0;
void cutpaper(long long d, long long t)
{
    t *= 10;
    if(d < t){
        s += d;
        if(s <k && s >= max){
            if(s==max)
                flag=1;
            else{
                max=s;
                flag=0;
            }
        }
        s -= d;
        return;
    }
    cutpaper(d, t);
    long long temp = d % t;
    d = d/t;
    s += temp;
    cutpaper(d, 1);
    s -= temp;
}

int main()
{
    long long d, t;
    scanf("%ld%ld", &d, &k);
    cutpaper(d, 1);
    if(max >= k)
        printf("not exists\n");
    else if(flag)
        printf("not service\n");
    else
        printf("%ld\n", max);
    return 0;
}
#+END_EXAMPLE

** 从0-N中随机生成M个数
思路一：先从N个数中随机找出M个，然后对这M个数进行随机排列，时间复杂度
为O(n),空间复杂度为O(M)。
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int s[100];
int f=0;

int getrand(int a, int b)
{
    return a + rand() % (b - a);
}
int in(int a)
{
    for(int i=0;i<f;i++)
        if(s[i]==a)
            return 1;
    return 0;
}

void swap(int i, int j)
{
    int t = s[i];
    s[i]=s[j];
    s[j]=t;
}

int main()
{
    int n,m;
    srand(time(NULL));
    scanf("%d%d", &n, &m);
    for(int i=n-m;i<n;i++){
        int temp=getrand(0, i + 1); #注：这里是 i + 1
        if(!in(temp))
            s[f++]=temp;
        else
            s[f++]=i;
    }
    for(int i=m-1;i>0;i--){
        int temp = getrand(0, i+1);
        swap(i, temp);
    }
    for(int i=0;i<f;i++)
        printf("%d\n", s[i]);
    return 0;
}
#+END_EXAMPLE

思路二：直接从N个数中生成M个随机数
#+BEGIN_EXAMPLE
for(int i=1;i<=N;i++)
    s[i]=i;      #这样保证了生成的数不会重复，缺点是需要O(N)的空间
for(int i =1;i<=M;i++)
    int temp = RandInt(i, N);
    swap(i, temp);
#+END_EXAMPLE

思路三：对思路一中的情况进行了修改,插入S时刻意选择插入的位置，这样可以
制造更好的随机，编程珠玑（续）
#+BEGIN_EXAMPLE
initialize sequence S to empty
for J:=N-M+1 to N do
    T = RandInt(1, J)
    if T is not in S then
       prefix T to S
    else
       insert J in S after T
#+END_EXAMPLE

** 求平方根 求多维空间中两个点间的距离
1. K维空间中有两个点A和B，求它们间的距离
2. 其中最重要的是求平方根操作，使用牛顿迭代可以减小开方操作的时间
3. 先找出A到B的距离中距离最大的一维 并记该距离为M，则A到B的距离值介于M和sqrt(K) * M
   之间
4. 用二分法直到两次求的的距离值小于一定范围为止
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <math.h>
#define exp 1.0e-7

int main()
{
    double A[16]={4,6,2,6,1,9,12,64,43};
    double B[16]={4,6,8,15,31,26,43,17,41};
    double T = A[0]-B[0];
    double max = T;
    double sum= T * T;
    for(int i=1;i<10;i++){
        T =fabs(A[i]-B[i]);
        if(T > max)
            max = T;
        sum += T * T;
    }
    printf("%lf\n", sum);
    if(sum - 0.0 < exp)
        return 0;

    /* 现在已经知道从A到B距离最大的一维的距离max， A到B的距离介于max
     * 和 sqrt(k) * max 之间 */

    /* 方法一 ------------------------------------------------------------------------*//
    double z = max;
    double newz;
    while(1){
        newz = 0.5 * (z + sum / z); #每一步都缩小了newz和精确值的差距
        if(fabs(newz - z) < z * exp)
            break;
        z = newz;
    }
    /* 改进 --------------------------------------------------------------------------*/
    max = max * 2;
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    /* ------------------------------------------------------------------------------*/
    printf("%lf\n", newz);
    return 0;
}
#+END_EXAMPLE
** 检测链表中是否存在循环 前提是链表中所有结点元素都不相同
思路：
1. 用两个指针p1和p2,p1指向链表第一个元素，p2指向链表第三个元素
2. 比较p1和p2所指向元素是否相同，如果相同则存在循环
3. p1和p2有一个为NULL则停止
4. p1向后移动一个元素,p2向后移动两个元素
如果存在循环最后肯定能找到，如果不存在最后p2为NULL停止
** 如何判断一个变量时有符号数还是无符号数
#define ISUNSIGNED(a) (a>=0 && ~a>=0)
如果宏的参数是一个类型，其中一个方法是使用类型转换
#define ISUNSIGNED(type) ((type)0 - 1 > 0)
** 一个文本文件中存入了很多字符串，如果随机的从中选中一个
1. 最简单的方法就是读一次文件，并记录每个字符串到文件开头的偏移量，最
   后随机一个数，打印该数字对应的字符串
2. 如果限制只能读一次文件，并且不能用变量存储字符串的偏移量，该怎么办
   呢？
   1）遍历文件，首先存入第一个字符串，当读入第二个字符串的时候，随机从
   这两个字符串中选择一个保存
   2）再读入一个字符串，从保存的字符串和该字符串中再以相同的概率选择保
   存一个，丢弃另一个，直到文件末尾，则选中任意字符串的概率都是相同的。
** 判定点是否在多边形内部
思路：二维空间中多个点的连线构成了一个多边形，給一定点p(x, y)，判断该点是否在
多边形内部
1. 沿着定点p做一条直线，判断直线与多边形的交点个数，只算从p到多边形外
   边的交点的个数。
2. 如果交点个数为偶数，则不在多边形内部，如果为奇数则在多边形内部
3. 计算交点个数的时候有一些特例。如果交点为多边形的顶点，则要分两种情
   况；与该顶点相连的两条边如果都在直线的一侧，则不算交点个数，如果在
   两侧则算作一个有效的交点；如果直线与多边形的一条边重合则算作一个有
   效交点。
4. 这里选择直线的时候，可以选择与坐标轴平行的直线。假如选择与y轴平行的
   直线，则判断直线与边是否相交，只用先判断该边的两个顶点(x1, y1),(x2,
   y2),是否有x1<=x&&x2>=x如果满足，再判断该交点的位置。
5. 注意为了防止重复计算，只当交点为多边形的边的右顶点时才算作有效交点


* 工作计划
*** TODO 存储过程
*** TODO 后缀树
*** TODO 后缀数组
*** TODO java webservice
