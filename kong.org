* 笔记
** 个人笔记
*** 配置emacs
**** 10.16 ecb 和 全屏显示 
配置ecb   darkroom 和 win32fullscreen
其中darkroom和win32fullscreen都可以实现全屏显示
主要用到了四个文件w32-fullscreen.el w32toggletitle.exe
darkroom-mode.el frame-local-vars.el
将w32toggletitle.exe放在path目录中，其它三个el文件都配置在init.el文件
中
**** 10.17 sr-speedbar
新增sr-speedbar功能，使speedbar可以在同一个frame中显示，不用重新开启一
个frame
下载sr-speedbar.el文件，在init.el文件中添加 (require 'sr-speedbar)
**** 10.17 查看历史打开文件 和历史编辑记录
recentf-open-files命令  C-c o按键
goto-last-change        C-c k 查看立即编辑记录
**** 10.17 查看历史编辑记录
使用goto-last-change命令回到上次编辑的位置，快捷键是C-c k   快捷键C-c
h被ecb占用
**** 10.17 用iexp命令在org模式插入括号
C-x p  you may try.
**** 10.18 emacs打开文件的字符编码问题
使用命令revert-buffer-with-coding-system手动选择打开文件的字符编码，
在保存的时候还可以指定文件的保存编码，使用命令
set-buffer-file-coding-system
**** 10.18 emacs配置etags
find -name "*.[chCH]" -print | etags - 命令用来生成TAGS
成功配置etags 
f5可以查找TAG，f6可以查找当前TAG,C-f6可以回跳
** 学习笔记
*** 可执行文件的内存布局
可执行文件内部主要包括文本端text，数据段data，和BSS段，用size命令可以
查看可执行文件a.out的大小。
数据段主要放置的是经过初始化的全局变量和静态变量，注意是经过初始化的，
如果没有被初始化则会放在BSS段，文本段主要放置可执行程序的指令。
局部变量并不进入a.out，它们在运行时创建。

*** 进程的地址空间
注意：进程的地址空间和可执行程序的内存空间不太一样。
它除了包括上边的文本段，数据段和BSS段之外，还需要保存堆栈段，用于保存
局部与函数的数据。
同时，注意虚拟地址空间的最低部分未被映射，它位于进程的地址空间中，但并未赋予
物理地址，所有对它的引用都是非法的，在典型情况下，它是地址零开始的几K
字节，用于捕获使用空指针和小整形值的指针引用内存的情况。
堆栈段占据进程空间的最高地址，并向下增长。

*** java中创建socke超时的解决办法
Socket s = new Socket("time....", 13); #创建一个Socket连接
s.setSoTimeOut(1000);                  #设置socket获取信息的超时时间

这里有一个问题，创建socket也有一个时间，如果连接不到服务器就会一直阻塞，
这里哟一个办法，先创建一个未连接的套接字，然后把该套接字连接到给定的地
址。
Socket s = new Socket();   #设置创建socket的超时时间
s.connect(new InetSocketAddress("time...", 13), 1000);
s.setSoTimeOut(1000;        #设置获取信息的超时时间
*** java获取本机地址的方式
InetAddress.getByName("localhost") #结果总是127.0.0.1
InetAddress.getLocalHost();     #得到本机的有效网络地址

*** 段错误和BUS错误
常见的段错误和BUS错误，BUS错误通常是由于数据在内存中不对齐引起的
#+BEGIN_EXAMPLE
union{ char a[10];
       int i;
}u;
int * p = (int *)&(u.a[1]);
*p = 17;
#+END_EXAMPLE
在实例中，数组a在共用体中是和int对齐的，所以a[1]必然不和int对齐，然后
在这个地方放入一个4字节的数据会引发BUS错误。

段错误比较常见，通常是
1. 坏指针值错误。在指针赋值前就用它来引用内存，指针释放后再将它置为空
   值。
2. 改写错误。 数组越界。
3. 释放链表出错。
*** 捕捉信号signal
使用头文件signal.h,使用句柄函数signal(SIGSGEV, handler)
常见的错误信号值SIGBUS,SIGSGEV,SIGILL
*** 类型提升 不怎么准
整型提升，就是char,short,int和位段类型(无论signed或unsigned)以及枚举类
型将被提升为int，前提是int能够完整的容纳原先的数据，否则将被转换为
unsigined int。float将被转换为double类型，任何数组将被转换为相应类型的
指针。
char c1,c2;
c1 = c1 + c2;
运算的时候，把每个变量的值提升为int的长度，然后对int执行加法，然后对运
算结果进行裁剪。
试试sizeof('c')的值
* 各种有趣问题
** 用磁带机求第K小元素                                                         :第K大元素:
如果输入在磁带机上， 你的机器只有一个磁带机驱动器和几十字的内存，如何
找第K小的数
1. 遍历一遍磁带，随即选择一个数M
2. 再遍历一遍磁带， 计算大于和小于M的个数，这样就可以获得数M在总序列中
   的排名，这里考虑到可能有重复元素所以要统计大于和小于的个数
3. 如果M的排名正好为所求，则结束；否则如果M的排名大于K，则下次遍历磁带
   时随即选择一个小于M的数，统计它的排名；如果M的排名小于K，下次遍历磁
   带的时候随即选择一个大于M的数，统计排名
4. 经过步骤3，所选数的范围缩小，最后就能找到所要求的数
5. 最多遍历磁带2logN次， 每次遍历时间O(n),总时间复杂度为O(nlogn)

目前求第K小的数，比较好的算法时间复杂度为O(n),常数大概为3.4

** 裁纸机程序
一个字条上边印有一串数字，对字条进行切割，满足一下条件
1. 每个字条上边都有字
2. 所有字条上数字的和小于给定数字

一个长度为n的数字串，共有n-1个位置可以切割，每个位置可以切割也可以不切
割时间复杂度为o(2^(n-1))
#+BEGIN_EXAMPLE
#include <stdio.h>
long long s = 0;
long long k, max = -1;
int flag=0;
void cutpaper(long long d, long long t)
{
    t *= 10;
    if(d < t){
        s += d;
        if(s <k && s >= max){
            if(s==max)
                flag=1;
            else{
                max=s;
                flag=0;
            }
        }
        s -= d;
        return;
    }
    cutpaper(d, t);
    long long temp = d % t;
    d = d/t;
    s += temp;
    cutpaper(d, 1);
    s -= temp;
}

int main()
{
    long long d, t;
    scanf("%ld%ld", &d, &k);
    cutpaper(d, 1);
    if(max >= k)
        printf("not exists\n");
    else if(flag)
        printf("not service\n");
    else
        printf("%ld\n", max);
    return 0;
}
#+END_EXAMPLE

** 从0-N中随机生成M个数
思路一：先从N个数中随机找出M个，然后对这M个数进行随机排列，时间复杂度
为O(n),空间复杂度为O(M)。
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int s[100];
int f=0;

int getrand(int a, int b)
{
    return a + rand() % (b - a);
}
int in(int a)
{
    for(int i=0;i<f;i++)
        if(s[i]==a)
            return 1;
    return 0;
}

void swap(int i, int j)
{
    int t = s[i];
    s[i]=s[j];
    s[j]=t;
}

int main()
{
    int n,m;
    srand(time(NULL));
    scanf("%d%d", &n, &m);
    for(int i=n-m;i<n;i++){
        int temp=getrand(0, i + 1); #注：这里是 i + 1
        if(!in(temp))
            s[f++]=temp;
        else
            s[f++]=i;
    }
    for(int i=m-1;i>0;i--){
        int temp = getrand(0, i+1);
        swap(i, temp);
    }
    for(int i=0;i<f;i++)
        printf("%d\n", s[i]);
    return 0;
}
#+END_EXAMPLE

思路二：直接从N个数中生成M个随机数
#+BEGIN_EXAMPLE
for(int i=1;i<=N;i++)
    s[i]=i;      #这样保证了生成的数不会重复，缺点是需要O(N)的空间
for(int i =1;i<=M;i++)
    int temp = RandInt(i, N);
    swap(i, temp);
#+END_EXAMPLE

思路三：对思路一中的情况进行了修改,插入S时刻意选择插入的位置，这样可以
制造更好的随机，编程珠玑（续）
#+BEGIN_EXAMPLE
initialize sequence S to empty
for J:=N-M+1 to N do
    T = RandInt(1, J)
    if T is not in S then
       prefix T to S
    else
       insert J in S after T
#+END_EXAMPLE

** 求平方根 求多维空间中两个点间的距离
1. K维空间中有两个点A和B，求它们间的距离
2. 其中最重要的是求平方根操作，使用牛顿迭代可以减小开方操作的时间
3. 先找出A到B的距离中距离最大的一维 并记该距离为M，则A到B的距离值介于M和sqrt(K) * M
   之间
4. 用二分法直到两次求的的距离值小于一定范围为止
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <math.h>
#define exp 1.0e-7

int main()
{
    double A[16]={4,6,2,6,1,9,12,64,43};
    double B[16]={4,6,8,15,31,26,43,17,41};
    double T = A[0]-B[0];
    double max = T;
    double sum= T * T;
    for(int i=1;i<10;i++){
        T =fabs(A[i]-B[i]);
        if(T > max)
            max = T;
        sum += T * T;
    }
    printf("%lf\n", sum);
    if(sum - 0.0 < exp)
        return 0;

    /* 现在已经知道从A到B距离最大的一维的距离max， A到B的距离介于max
     * 和 sqrt(k) * max 之间 */

    /* 方法一 ------------------------------------------------------------------------*//
    double z = max;
    double newz;
    while(1){
        newz = 0.5 * (z + sum / z); #每一步都缩小了newz和精确值的差距
        if(fabs(newz - z) < z * exp)
            break;
        z = newz;
    }
    /* 改进 --------------------------------------------------------------------------*/
    max = max * 2;
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    max = 0.5 * (max + sum / max);
    /* ------------------------------------------------------------------------------*/
    printf("%lf\n", newz);
    return 0;
}
#+END_EXAMPLE





* 时间表                                                                        :工作计划:
 [[file:../arrange.gif][ 基本流程]]
** TODO 后缀数组
** TODO 后缀树
** TODO java webservice
** TODO bitmap位图
** TODO 爬虫程序
** 快捷键
*** todo 常用快捷键
| 快捷键      | 功能               |
|-------------+--------------------|
| C-c C-t     | 在定义的状态中循环 |
| C-u C-c C-t | 指定一个状态       |
| S-right     | 在定义的状态中循环 |
| S-Left      | 在定义的状态中循环 |
| C-c C-q     | 为当前状态插入标签 |

