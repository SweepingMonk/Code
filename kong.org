* 笔记
** 个人笔记
*** 配置emacs
**** 10.16 ecb 和 全屏显示 
配置ecb   darkroom 和 win32fullscreen
其中darkroom和win32fullscreen都可以实现全屏显示
主要用到了四个文件w32-fullscreen.el w32toggletitle.exe
darkroom-mode.el frame-local-vars.el
将w32toggletitle.exe放在path目录中，其它三个el文件都配置在init.el文件
中
**** 10.17 sr-speedbar
新增sr-speedbar功能，使speedbar可以在同一个frame中显示，不用重新开启一
个frame
下载sr-speedbar.el文件，在init.el文件中添加 (require 'sr-speedbar)
**** 10.17 查看历史打开文件
recentf-open-files命令
**** 10.17 查看历史编辑记录
使用goto-last-change命令回到上次编辑的位置，快捷键是C-c k   快捷键C-c
h被ecb占用

** 学习笔记
*** 可执行文件的内存布局
可执行文件内部主要包括文本端text，数据段data，和BSS段，用size命令可以
查看可执行文件a.out的大小。
数据段主要放置的是经过初始化的全局变量和静态变量，注意是经过初始化的，
如果没有被初始化则会放在BSS段，文本段主要放置可执行程序的指令。
局部变量并不进入a.out，它们在运行时创建。

*** 进程的地址空间
注意：进程的地址空间和可执行程序的内存空间不太一样。
它除了包括上边的文本段，数据段和BSS段之外，还需要保存堆栈段，用于保存
局部与函数的数据。
同时，注意虚拟地址空间的最低部分未被映射，它位于进程的地址空间中，但并未赋予
物理地址，所有对它的引用都是非法的，在典型情况下，它是地址零开始的几K
字节，用于捕获使用空指针和小整形值的指针引用内存的情况。
堆栈段占据进程空间的最高地址，并向下增长。


* 各种有趣问题
** 用磁带机求第K小元素                                                         :第K大元素:
如果输入在磁带机上， 你的机器只有一个磁带机驱动器和几十字的内存，如何
找第K小的数
1. 遍历一遍磁带，随即选择一个数M
2. 再遍历一遍磁带， 计算大于和小于M的个数，这样就可以获得数M在总序列中
   的排名，这里考虑到可能有重复元素所以要统计大于和小于的个数
3. 如果M的排名正好为所求，则结束；否则如果M的排名大于K，则下次遍历磁带
   时随即选择一个小于M的数，统计它的排名；如果M的排名小于K，下次遍历磁
   带的时候随即选择一个大于M的数，统计排名
4. 经过步骤3，所选数的范围缩小，最后就能找到所要求的数
5. 最多遍历磁带2logN次， 每次遍历时间O(n),总时间复杂度为O(nlogn)
   
目前求第K小的数，比较好的算法时间复杂度为O(n),常数大概为3.4

** 裁纸机程序
一个字条上边印有一串数字，对字条进行切割，满足一下条件
1. 每个字条上边都有字
2. 所有字条上数字的和小于给定数字

一个长度为n的数字串，共有n-1个位置可以切割，每个位置可以切割也可以不切
割时间复杂度为o(2^(n-1))
#+BEGIN_EXAMPLE
#include <stdio.h>
long long s = 0;
long long k, max = -1;
int flag=0;
void cutpaper(long long d, long long t)
{
    t *= 10;
    if(d < t){
        s += d;
        if(s <k && s >= max){
            if(s==max)
                flag=1;
            else{
                max=s;
                flag=0;
            }
        }
        s -= d;
        return;
    }
    cutpaper(d, t);
    long long temp = d % t;
    d = d/t;
    s += temp;
    cutpaper(d, 1);
    s -= temp;
}

int main()
{
    long long d, t;
    scanf("%ld%ld", &d, &k);
    cutpaper(d, 1);
    if(max >= k)
        printf("not exists\n");
    else if(flag)
        printf("not service\n");
    else
        printf("%ld\n", max);
    return 0;
}
#+END_EXAMPLE

** 从0-N中随机生成M个数
思路一：先从N个数中随机找出M个，然后对这M个数进行随机排列，时间复杂度
为O(n),空间复杂度为O(M)。
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int s[100];
int f=0;

int getrand(int a, int b)
{
    return a + rand() % (b - a);
}
int in(int a)
{
    for(int i=0;i<f;i++)
        if(s[i]==a)
            return 1;
    return 0;
}

void swap(int i, int j)
{
    int t = s[i];
    s[i]=s[j];
    s[j]=t;
}

int main()
{
    int n,m;
    srand(time(NULL));
    scanf("%d%d", &n, &m);
    for(int i=n-m;i<n;i++){
        int temp=getrand(0, i + 1); #注：这里是 i + 1
        if(!in(temp))
            s[f++]=temp;
        else
            s[f++]=i;
    }
    for(int i=m-1;i>0;i--){
        int temp = getrand(0, i+1);
        swap(i, temp);
    }
    for(int i=0;i<f;i++)
        printf("%d\n", s[i]);
    return 0;
}
#+END_EXAMPLE

思路二：直接从N个数中生成M个随机数
#+BEGIN_EXAMPLE
for(int i=1;i<=N;i++)
    s[i]=i;      #这样保证了生成的数不会重复，缺点是需要O(N)的空间
for(int i =1;i<=M;i++)
    int temp = RandInt(i, N);
    swap(i, temp);
#+END_EXAMPLE

思路三：对思路一中的情况进行了修改,插入S时刻意选择插入的位置，这样可以
制造更好的随机，编程珠玑（续）
#+BEGIN_EXAMPLE
initialize sequence S to empty
for J:=N-M+1 to N do
    T = RandInt(1, J)
    if T is not in S then
       prefix T to S
    else
       insert J in S after T
#+END_EXAMPLE

** 求平方根 求多维空间中两个点间的距离
1. K维空间中有两个点A和B，求它们间的距离
2. 其中最重要的是求平方根操作，使用牛顿迭代可以减小开方操作的时间


