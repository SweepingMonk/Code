* 系统编程
** 可执行文件的内存布局
可执行文件内部主要包括文本端text，数据段data，和BSS段，用size命令可以
查看可执行文件a.out的大小。
数据段主要放置的是经过初始化的全局变量和静态变量，注意是经过初始化的，
如果没有被初始化则会放在BSS段，文本段主要放置可执行程序的指令。
局部变量并不进入a.out，它们在运行时创建。

** 进程的地址空间
注意：进程的地址空间和可执行程序的内存空间不太一样。
它除了包括上边的文本段，数据段和BSS段之外，还需要保存堆栈段，用于保存
局部与函数的数据。
同时，注意虚拟地址空间的最低部分未被映射，它位于进程的地址空间中，但并未赋予
物理地址，所有对它的引用都是非法的，在典型情况下，它是地址零开始的几K
字节，用于捕获使用空指针和小整形值的指针引用内存的情况。
堆栈段占据进程空间的最高地址，并向下增长。
** 段错误和BUS错误
常见的段错误和BUS错误，BUS错误通常是由于数据在内存中不对齐引起的
#+BEGIN_EXAMPLE
union{ char a[10];
       int i;
}u;
int * p = (int *)&(u.a[1]);
*p = 17;
#+END_EXAMPLE
在实例中，数组a在共用体中是和int对齐的，所以a[1]必然不和int对齐，然后
在这个地方放入一个4字节的数据会引发BUS错误。

段错误比较常见，通常是
1. 坏指针值错误。在指针赋值前就用它来引用内存，指针释放后再将它置为空
   值。
2. 改写错误。 数组越界。
3. 释放链表出错。
** 捕捉信号signal
使用头文件signal.h,使用句柄函数signal(SIGSGEV, handler)
常见的错误信号值SIGBUS,SIGSGEV,SIGILL,SIGINT,SIGABRT

注意有两个信号是不能被捕获的， SIGKILL和SIGSTOP 并且这两个信号是不能被
忽略的，因为，它们向超级用户提供了使进程终止或停止的可靠方法。

shell自动将后台进程对中断和退出信号的处理方式设置为忽略，于是当按中断
键时就不会影响到后台进程，如果没有这样的处理，那么当按中断键时，它不但
会终止当前进程，还会终止所有后台进程。

** 如何捕获一个子进程终止状态
1. 可以在父进程中使用wait或者waitpid捕获子进程的结束状态
2. 或者使用信号机制捕获SIGCHLD信号
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>

int p = 0;
void handler(int sig)
{
    p++;
}

int main()
{
    signal(SIGCHLD, handler);
    int pid;
    if((pid=fork())<0)
        exit(1);
    else if(pid==0)
    {
        printf("hello\n");
    }
    else{
        sleep(4);
    }
    printf("%d %d\n", p, getpid());
    return 0;
}
#+END_EXAMPLE
打印结果
hello
0 4316
1 7364
由此可见已经成功捕获到了子进程终止的信号，并执行了处理函数handler，使
得p的值增加

注意：父进程已经结束的进程被称为孤儿进程，而子进程如果先于父进程结束，
父进程却没有捕获子进程的状态，被称为僵尸进程。

** sleep函数
unsigned int sleep(unsigned int secondes);
1. 已经过了seconds所指定的墙上时钟时间
2. 调用进程捕捉到了一个信号并从信号处理程序返回

如同alarm信号一样，由于其他系统活动，实际返回的时间会比所要求的会迟一些

第一种情况下，返回值是0，第二种情况下，由于捕捉到某个信号sleep提早返回，返回值是未睡够的秒数

sleep可以用alarm来实现

** 作业控制信号
与作业控制有关的6个信号
SIGCHLD  子进程停止或终止
SIGCONT  如果进程已停止，则使其继续进行
SIGSTOP  停止信号
SIGTTIN  后台进程组成员读控制终端
SIGTTOU  后台进程组成员写控制终端

** unix系统中逐字符输入的两种实现
一种是把I/O设置为raw状态，可以实现阻塞式读入，如果终端没有字符输入，进
程就一直等待，直到有字符输入为止。
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int c;
    /* 中断驱动原来处于普通的一次一行模式*/
    /* 把终端设置为raw状态可以实现阻塞式读入*/
    system("stty raw");
    while(1){
        /*现在驱动处于一次一字符的模式*/
        c=getchar();
        putchar(c);
        if(c=='q')
            break;
    }
    /* 终端驱动又处于一次一字符的方式 */
    system("stty cooked");
    return 0;
}
#+END_EXAMPLE

另外一种方式是使用ioctl(),这样只有当一个字符等待被读入时，进程才进行读
取，这种类型的I/O被称为轮询，就好像你不断地询问设备的状态，看看它是否
有字符要传给你。

#+BEGIN_EXAMPLE
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/ioctl.h>

int kbhit()
{
    int i;
    /* 设置I/O轮询 */
    ioctl(0, FIONREAD, &i);
    return i;
}

int main()
{
    int i=0;
    int c=' ';
    system("stty raw -echo");
    printf("enter 'q' to quit \n");
    for(;c!='q';i++){
        if(kbhit()){
            c=getchar();
            printf("\n got %c, on iteration %d", c, i);
        }
    }
    system("stty cooked echo");
}
#+END_EXAMPLE
** 函数库调用和系统调用的区别
system是一个库函数 strlen并不调用任何系统调用
函数库调用是语言或应用程序的一部分，而系统调用是操作系统的一部分，不管
是java还是python的I/O最后都是通过read和write这样的系统调用来完成的
系统调用是用户程序和内核交互的接口
| 函数库调用                                  | 系统调用                                     |
|---------------------------------------------+----------------------------------------------|
| 在所有的ansi c编译器版本中，c库函数是相同的 | 各个操作系统的系统调用时不同的               |
| 它调用函数库中的一个程序                    | 它调用系统内核的服务                         |
| 与用户程序相联系           important        | 是操作系统的一个入口点                       |
| 在用户地址空间执行         important        | 在内核地址空间执行                           |
| 它的运行时间属于用户时间    important       | 它的运行时间属于系统时间                     |
| 属于过程调用，开销较小      important             | 需要切换到内核上下文环境然后再切换回来开销大 |
| 在C函数库libc中有大约300个程序              | 在unix中有大约90个系统调用(MS-DOS)中少一些   |

自己总结
| 函数库调用             | 系统调用             |
|------------------------+----------------------|
| 通常提供比较复杂的功能 | 通常提供一种最小界面 |

#+BEGIN_EXAMPLE
int main()

{
    int fd = create("filename",0666);

    exit(0);
}
#+END_EXAMPLE
在执行main函数时，是在user mode下执行，当遇到create函数时，继续在user mode下执行，然后将filename和0666两个参数压入栈中寄存器，接着调用库函数create，系统仍然处于user mode。
这里的库函数create实际上调用了内核的系统调用create，执行到这里后，系统将create系统调用的unique number压入寄存器，然后执行指令trap使系统进入kernel mode(执行int $0x80产生中断)。
这时系统意识到要进行系统调用的invoke，于是从刚才的寄存器中取出create系统调用的unique number，从系统调用表中得知要invoke的系统调用是create，然后执行。执行完毕返回库函数create的调用，库函数负责检查系统调用的执行情况(检查某些寄存器的值)，
然后库函数create根据检查的结果返回响应的值。

这里trap指令类似于一个系统中断并且是软中断，而系统调用create类似于一个中断处理函数
所有的系统调用都与上边的情况类似，靠中断机制切换到内核模式实现。

系统调用通常比库函数要慢，因为要把上下文环境切换到内核模式

** 内核开发的特点
+ 内核编程时不能访问C库，也不能访问标准的C头文件
+ 内核编程时必须使用GNU C
+ 内核编程时缺少像用户空间那样的内存保护机制
  内核中的内存都是不分页的，每用掉一个字节，物理内存就减少一个字节。
+ 内核编程时难以执行浮点运算
  不要轻易在内核中使用浮点数
+ 内核给每个进程只有一个很小的定长堆栈
  内核栈的大小是两页，32位机的内核栈是8KB，而64位机是16KB，固定不变，
  每个处理器都有自己的栈。用户空间的栈比较大，而且通常可以动态增长，
  DOS不可以。
+ 内核支持异步终端，抢占和SMP，因此必须时刻注意同步和并发
  同步和并发
  内核很容易产生竞争。和单线程的用户空间程序不同，内核的许多特性都要求
  能够并发地访问共享数据。
  + Linux是抢占式多任务操作系统
  + Linux支持对称多处理器系统
  + 中断是异步到来的
    中断异步到来，完全不顾及当前正在执行的代码。如果不加以适当的保护，
    中断完全有可能在代码访问资源的时候到来，这样中断处理程序就有可能访
    问同一资源
  + Linux内核可以抢占。所以如果不加以适当保护，内核中一段正在执行的代
    码可能会被另外一段代码抢占，从而有可能导致几段代码同时访问相同的资
    源。

    常用的解决竞争的方法是自旋锁和信号量。

** 文件描述符和文件指针的区别
在linux系统中把设备和普通文件也都看做是文件，要对文件进行操作就必须先打开文件，
打开文件后会得到一个文件描述符，它是一个很小的正整数，是一个索引值。

内核会为每一个运行中的进程在进程控制块pcb中维护一个打开文件的记录表，
每一个表项都有一个指针指向打开的文件，上边的索引值是记录表的索引值。

文件描述符的优点：兼容POSIX标准，许多系统调用都依赖于它；缺点是不能移
植到unix之外的系统上去。

文件指针：c语言中使用的是文件指针而不是文件描述符来作为I/O的句柄，文件
指针指向进程的用户空间中一个FILE结构的数据结构，FILE结构里主要包括一个
I/O缓冲区和一个文件描述符，而文件描述符值是文件描述符表中的一个索引，
从某种意义上将文件指针就是句柄的句柄(在Window中文件描述符被称为文件句
柄)。

文件指针的优点：是c语言中的通用格式，便于移植。

既然FILE结构中含有文件描述符，那么可以使用fopen来获得文件指针，然后从
文件指针获取文件描述符，文件描述符应该是唯一的，而文件指针却不是唯一的，
但指向的对象是唯一的。

C语言文件指针域文件描述符之间可以相互转换
int fileno(FILE * stream)
FILE * fdopen(int fd, const char * mode)

open和fopen的区别

| open                      | fopen                       |
|---------------------------+-----------------------------|
| open返回一个文件描述符    | 返回FILE *                  |
| 无缓冲                    | 有缓冲                      |
| 与write()和read()配合使用 | 与fwrite()和fread()配合使用 |


FILE的结构
#+BEGIN_EXAMPLE
struct _iobuf {
        char *_ptr;          //缓冲区当前指针
        int   _cnt;
        char *_base;         //缓冲区基址
        int   _flag;         //文件读写模式
        int   _file;         //文件描述符
        int   _charbuf;      //缓冲区剩余自己个数
        int   _bufsiz;       //缓冲区大小
        char *_tmpfname;
        };
typedef struct _iobuf FILE;

int fd = open("TAGS", O_RDONLY);
FILE * fp = fopen("TAGS", "r");
printf("%d %d\n", fd, fp->_file);
可以从文件指针中获取文件描述符

fileno(fp) 和fp->_file效果是一样的
FILE * fp = fdopen(fd, "r") 根据文件描述符加上访问模式可以得到文件指针
#+END_EXAMPLE

** makefile规则
*** ':='和'='的区别
':='和平时使用的赋值符号相同，'='则不同，使用'='时，函数和变量参考会留
在那儿，改变一个变量的值会导致其它变量的值也被改变，类似于指针。

** Unix高级环境高级编程
所有操作系统都需要向它们运行的程序提供各种服务.包括执行新程序,打开文件,读
文件,分配存储区等.在严格意义上,可将操作系统定义为一种软件，它控制计算
机硬件资源，提供程序运行环境。一般而言我们称这种软件为内核，它相对较小，
位于环境的中心。UNIX的体系结构从内到外是内核、系统调用、shell 库函数、
应用软件。内核的接口被称为系统调用，公用函数库建立在系统调用之上，应用
软件可以使用库函数也可以使用系统调用。shell是一种特殊的应用程序，它为
运行其它软件提供了一种接口。

** APUE源码编译与使用
UNIX环境高级编程（第二版）/ APUE 源码编译与使用

为了用APUE的源码折腾了一下，网上很多方法都不能用，或者有小问题，特此记录。

注意，不同环境的编译提示有所不同，如果你的环境和我的相似，那么应该没问题。

环境

Linux mypad 2.6.38-ARCH #1 SMP PREEMPT Tue May 3 06:04:40 UTC 2011 i686 Intel(R) Core(TM)2 Duo CPU T6570 @ 2.10GHz GenuineIntel GNU/Linux

确保你已经安装了gcc和gawk。

步骤

到www.apuebook.com下载源码
tar解包，cd apue.2e
vi Make.defines.linux 修改变量WKDIR，指向你的apue源码的位置，我的是/home/huangz/code/apue.2e，所以 WKDIR=/home/huangz/code/apue.2e
vi include/apue.h 增加一个常量ARG_MAX，这是threadctl/getenv1.c和threadctl/getenv3.c要用到的；4096这个值是参考里给的，如果有问题，自己修改吧。
vi threadctl/getenv1.c 增加
vi threadctl/getenv3.c 增加
vi threads/badexit2.c 修改第31行，将pthread_self()的返回值转换为int类型。 printf(“thread 2: ID is %d\n”, (int)pthread_self());
vi std/linux.mk 将两个nawk改为gawk
make
sudo cp include/apue.h /usr/include sudo cp lib/libapue.a /usr/lib
好了，测试一下，记得要用-lapue命令让编译器链接apue库 gcc main.c -lapue

** 不带缓冲的I/O
每个read和write都调用内核的一个系统调用，是不带缓冲的I/O，
** Unix文件共享
1. 每个进程在进程表中都有一个记录项，记录项中包含有一张打开文件描述表，
   每个描述符占有一项。与每个文件描述符相关联的是：
   + 文件描述符标志
   + 指向一个文件表的指针
2. 内核为所有打开文件维持一张文件表，每个文件表项包含：
   + 文件状态标志
   + 当前文件偏移量
   + 指向该文件V节点表项的指针
3. 每个打开文件都有一个v节点结构(Linux中使用i节点)，v节点包含了文件类型和对此文件进行各
   种操作的函数的指针。对于大多数文件，v节点还包含了该文件的i节点
   (i-node索引节点)。这个信息都是在打开文件的时候从磁盘上读入内存的，i
   节点包含了文件的所有者、文件长度、文件所在的设备、指向文件实际数据
   块在磁盘上所在位置的指针等。

Linux没有使用v节点，而是使用了通用的节点结构，虽然两种实现有所不同，但
在概念上v节点和i节点是一样的，两者都指向文件系统特有的i节点结构。


当在两个进程中同时打开同一个文件时，每个进程表中都有一个记录项，都有自己的
文件描述符和指向文件表的指针，而文件表中的v节点指针指向同一个v节点。

对于一个给定文件只有一个v节点表项，每个进程都有自己的文件表项的理由是：
每个进程都拥有自己对该文件的当前偏移量。

当使用dup函数或者fork之后，可能有多个文件描述符指向同一文件表项。在
fork之后父子进程对于每一个打开文件描述符共享同一个文件表项。由于共享文
件表项，因此拥有同一当前文件偏移量,以下实例:

#+BEGIN_EXAMPLE
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main()
{
    FILE * fp1, * fp2;
    int fd1, fd2;
    if((fd1 = open("in", 2)) < 0) /* 打开文件 2表示只写方式 */
    {
        printf("open error\n");
        exit(1);
    }
    lseek(fd1, 10, SEEK_SET);   /* 设定文件偏移量 */
    /* fd2 = fcntl(fd1, F_DUPFD, 0); /\* 和下面一句等效 *\/ */
    fd2 = dup(fd1);             /* 复制文件描述符 */
    lseek(fd1, 20, SEEK_SET);   /* 设定文件偏移量 */
    lseek(fd2, 30, SEEK_SET);   /* 设定文件偏移量 */
    fp1 = fdopen(fd1, "r");     /* 文件描述符转化为文件指针 */
    fp2 = fdopen(fd2, "r");
    printf("%d %d %d %d\n", fd1, fd2, ftell(fp1), ftell(fp2)); /* 打印文件偏移量 */
    return 0;
}
#+END_EXAMPLE
复制一个描述符的另一种方法时fcntl函数，调用dup(filedes)，等效于
fcntl(filedes, F_DUPFD, 0);而调用dup2(filedes, filedes2);等效于
close(fildes2); fcntl(filedes, F_DUPFD, filedes2);
** Unix文件系统基本结构
一个磁盘分成一个或多个分区，每个分区可以包含一个文件系统。

见系统附图：filesystem.jpg i_node.jpg

Linux文件系统使用 索引节点i 来记录文件信息，索引节点是一个结构，用固定长度，它包含了一个文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。

一个文件系统维护了一个索引节点的数组 即为目录项，目录项中的每一项包括文件
索引节点i的节点号和文件名，所以目录只是将文件的名称和它的索引节点号结
合在一起的一张表。

对于一个文件来说有唯一的索引节点与之对应，而一个索引节点却可以有多个
文件名与之对应，因此磁盘上的同一个文件可以通过不同的路径去访问它。

可以用ln命令对一个已经存在的文件建立一个新的连接，而不复制文件的内容。
连接有软连接和硬连接之分，软连接又叫符号连接。

| 硬连接                                          | 软连接                                                     |
|-------------------------------------------------+------------------------------------------------------------|
| 硬链接指向文件的i节点                           | 它的数据是它所连接的文件的路径名，是指向一个文件的间接指针 |
| 目录不能有硬连接，但超级用户可以                | 目录也适用                                                 |
| 不能跨越文件系统                                | 可以跨越文件系统                                           |
| 文件在磁盘中只有一个拷贝                        |                                                            |
| 索引节点的引用为0时才可以删除文件可以防止误删除 | 可以删除原有文件保留连接文件，没有防误删功能               |

每个文件系统都对它们的i节点进行编号，因此目录项中的i节点指向同一文件系
统的i节点，不能使一个目录项指向另一个文件系统的i节点，因此硬连接不能跨
越文件系统。


一个磁盘块分为三部分：
+ 超级快， 文件系统中第一块被称为超级快。这个快存放文件系统本身的结构
  信息，比如每个区域的大小，未被使用的磁盘块的信息。
+ i节点， 超级块的下一个部分就是i节点表，文件系统中的每个文件在该表中
  都对应一个i节点。
+ 数据区， 文件的内容保存在这个区域上，磁盘上所有块的大小都一样，如果
  文件包含了超过一个块的内容，则文件内容会存放在多个磁盘块中，并把磁盘
  块的分配情况记录在文件的i节点中的磁盘序列表中

大文件存储的实现：
linux文件系统使用三级分页存储结构，每个i节点的磁盘序列表中最多有13项，
通常用前10个数据块存放文件数据，第11个数据块用来构造一级索引，第12个数
据块用来构造二级索引，第13个数据块用来构造三级索引。

** 进程终止方式
1. 从main返回
2. 调用exit
3. 调用_exit或_Exit
4. 最后一个线程从其启动例程返回
5. 组后一个线程调用pthread_exit
异常终止有三种方式：
6. 调用abort
7. 接收一个信号并终止
8. 最后一个线程对取消请求作出响应

有三个函数用于正常终止一个程序：_exit和_Exit立即进入内核，exit则先执行
一些清理工作，如为所有打开文件执行fclose函数，然后进入内核

内核使程序执行的唯一方法是调用一个exec函数，函数资源终止的唯一方法是显
式或隐式调用_exit或_Exit
** linux特殊权限:setUid setGid 粘着位(sticky)
linux中的每个文件都有自己的可读可写可执行权限位rwx，除了这些常见的权限
位外还存在一些特殊的权限位。

如果是一个可执行文件, 那么在执行时, 一般该文件只拥有调用该文件的用户具
有的权限. 而setuid, setgid 可以来改变这种设置

setuid:只对文件有效，当文档被设定为setuid位以后，任何能够运行此文档的用户都能够像文档属主相同地运行它，例如：假如给/bin/rm配置了setuid权限位，那么任何用
户都可以像rm的拥有者root一样删除掉系统内的任何文档，等于是为该可执行程
序赋予了root权限，当文档本来就没有可执行权限还加上setuid属性时，权限位
就用S表示，注意是大写的S不是小写的s。

setgid:和setuid功能类似，只对目录有效，setgid权限位被设定以后，任何用户都拥有了该文档所属组的权限，也就是能够像该文档组内成员相同的方式运行它。另外当一个
目录被配置为setgid位后，以后用别的用户创建或者复制到这个目录下的文档，
它所属的组会自动改成目录文档所在的组，除非复制是加上-p(preserve)选项。

sticky:只对文件有效， 当sticky位被配置以后，只有root或文档用户才能删除或移动它，例如/tmp目录就被设定了sticky位drwxrwxrwt， 这样任何的用户都会这个文件夹可
读可写，却只有root能删除或移动它。

setuid，setgid，sticky的八进制位分别是4, 2, 1，助记法表示为u+s，g+s，
o+t，(删除标记位是u-s，g-s，o-t)

1) chmod u+s temp -- 为temp文件加上setuid标志. (setuid 只对文件有效)

　　chmod g+s tempdir -- 为tempdir目录加上setgid标志 (setgid 只对目录有效)

　　chmod o+t temp -- 为temp文件加上sticky标志 (sticky只对文件有效)

   chmod 4644 frogleap.swf结果是-rwsr--r--

   chmod u+s frogleap.swf 结果和上边一样

2) 采用八进制方式，对一般文件通过三组八进制数字来置标志, 如 666, 777, 644等. 如果设置这些特殊标志, 则在这组数字之外外加一组八进制数字. 如 4666, 2777等. 这一组八进制数字三位的意义如下,

　　abc

　　a - setuid位, 如果该位为1, 则表示设置setuid

　　b - setgid位, 如果该位为1, 则表示设置setgid

　　c - sticky位, 如果该位为1, 则表示设置sticky

　　设置完这些标志后, 可以用 ls -l 来查看. 如果有这些标志, 则会在原来的执行标志位置上显示. 如

　　rwsrw-r-- 表示有setuid标志

　　rwxrwsrw- 表示有setgid标志

　　rwxrw-rwt 表示有sticky标志

　　那么原来的执行标志x到哪里去了呢? 系统是这样规定的, 如果本来在该位上有x, 则这些特殊标志显示为小写字母 (s, s, t). 否则, 显示为大写字母 (S, S, T)

以上三种特别权限位现在已用得比较少或不建议使用，例如setuid和setgid有安
全风险，linux的虚拟内存机制使得sticky作用已不大

** alloca函数
alloca的调用与malloc相同，但是它是在当前函数的栈针上分配内存空间，而不是在堆中。优点是:当函数返回时，自动释放它所使用的栈桢，所以不必再为释放空间而费心。其缺点是：alloca函数增加了栈桢的长度，而某些系统在函数已被调用后不能增加栈桢长度。
** init进程
有关/sbin/init程序的问题

最简单的请参见Linux 0.12系统（下Linux.old/bochs/下有），或者看Linux.old/Linux-0.12/
-------------
当init启动后，它通过执行各种启动事务来继续引导进程（检查并监视文件系统，启动后台程序daemons,等等），直至完成用户所有操作环境的设置工作。这里主要涉及4个程序：init、getty(agetty)、login和shell程序。这4个程序之间的关系见下图所示。

init进程的主要任务是根据/etc/rc文件中设置的信息，执行其中设置的命令，然后根据/etc/inittab文件中的信息，为每一个允许登录的终端设备使用fork()创建一个子进程，并在每个新创建的子进程中运行agetty （getty）程序。而init进程则调用wait()，进入等待子进程结束状态。每当它的一个子进程结束退出，它就会根据wait()返回的pid号知道是哪个对应终端的子进程结束了，因此就会为相应终端设备再创建一个新的子进程，并在该子进程中重新执行agetty程序。这样，每个被允许的终端设备都始终有一个对应的进程为其等待处理。
在正常的操作下，init确定agetty正在工作着以允许用户登录，并且收取孤立进程。孤立进程是指那些其父辈进程已结束的进程；在Linux中所有的进程必须属于单棵进程树，所以孤立进程必须被收取。当系统关闭时，init负责杀死所有其它的进程，卸载所有的文件系统以及停止处理器的工作，以及任何它被配置成要做的工作。

getty程序的主要任务是设置终端类型、属性、速度和线路规程。它打开并初始化一个tty端口，显示提示信息，并等待用户键入用户名。该程序只能由超级用户执行。通常，若/etc/issue文本文件存在，则getty会首先显示其中的文本信息，然后显示登录提示信息（例如：plinux login: ），读取用户键入的登录名，并执行login程序。
为了能让init程序运行getty，/etc/inittab文件中必须含有getty（agetty）命令。/etc/inittab文件中有关agetty的内容例子见如下所示。
列表 3.1 poeigl-1.2中的inittab文件
# inittab for linux, poeigl 1.2
# Format:
# ttyline:termcap-entry:getty-command
tty1:con80x60:/bin/agetty 9600 tty1
tty2:con80x60:/bin/agetty 9600 tty2
tty3:con80x60:/bin/agetty 9600 tty3
tty4:con80x60:/bin/agetty 9600 tty4
# tty5:con80x60:/bin/agetty 9600 tty5
# tty64:dumb:/bin/agetty 9600 tty64
# tty65:dumb:/bin/agetty -m -t60 2400 tty65
每个终端都有自己的getty命令。其中列出了tty1—tty4对应的登录项信息。以’#’开始的是注释行。第1列是所用终端设备名称，第2列是指定终端的类型，这里指定了终端类型是con80x60。第3列是所执行的命令及其参数。最后两行中的tty64和tty65对应连接在串行端口上的终端。
对于使用串行端口与主机直接相连的终端以及通过modem拨号连接的终端，Linux的agetty程序还有其它一些属性。如在读取登录名时自动调整tty的设置信息，例如奇偶校验位、檫除字符、行结束字符以及上档键字符等。可选择地从链接的Hayes兼容modem信息中检测出传输波特率。
/dev/inittab中每一项的参数格式与具体使用哪一种getty程序有关。目前一般常用的getty程序有如下几种：
1.agetty（有时直接称为getty）：容易设置，无须配置文件。适用于直接连接的终端；
2.getty（getty_ps的一部分）：适用于直接连接的终端；
3.mgetty：最适合于通过modem连接，也可用于直连；
4.uugetty：仅用于通过modem连接终端，是getty_ps软件包的部分；
5.mingetty：简单的getty。适用于控制台终端或虚拟终端；
6.fbgetty：适用于控制台或虚拟终端。
Redhat 9系统默认配置中带有mingetty和agetty两个程序。控制台或虚拟终端使用的是mingetty。对于实际的字符终端则一般使用agetty。因此在Redhat 9系统的/etc/inittab文件中会看到以下的信息。
列表 3.2 RedHat 9系统的/etc/inittab文件中有关getty的信息
# Run gettys in standard runlevels
1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
4:2345:respawn:/sbin/mingetty tty4
5:2345:respawn:/sbin/mingetty tty5
6:2345:respawn:/sbin/mingetty tty6
其中第1列表示名称tty后的数字，2345表示该mingetty的运行层。respawn表示如果该mingetty被终止，则mingetty将再次自动执行。/sbin/mingetty是命令。ttyn代表/dev/ttyn（n表示数字1—5）。
在登录到Linux系统中之后，你会发现（使用”top”或”ps –ax”命令）自己终端原来的getty进程已经找不到了。因为getty进程执行了login程序，被替换成了login进程，并且最后被替换成你的登录shell进程。
当你在”login: “提示符下键入了你的用户名后，getty会读取用户名并且去执行login程序，也把用户名信息传给了它。因此getty进程被替换成了login进程。此时login进程会接着要求你输入口令。在口令检查通过后就会去执行/etc/passwd文件中对应你用户名项中记录的程序。通常这个程序是bash shell程序。因此原来的getty进程最终被替换成了bash进程，对应的这三个程序也就都具有相同的进程ID。
当注销登录（log out）时，则该终端上的所有进程都会被终止（killed），包括登录shell进程bash。因此，对于在/etc/inittab文件中列出的getty程序，一旦其被替换执行的bash程序被终止或退出，init进程就会为对应终端重新创建一个getty进程。

login程序则主要用于要求登录用户输入密码。根据用户输入的用户名，它从口令文件passwd中取得对应用户的登录项，然后调用getpass()以显示”password:”提示信息，读取用户键入的密码，然后使用加密算法对键入的密码进行加密处理，并与口令文件中该用户项中pw_passwd字段作比较。如果用户几次键入的密码均无效，则login程序会以出错码1退出执行，表示此次登录过程失败。此时父进程（进程init）的wait()会返回该退出进程的pid，因此会根据记录下来的信息再次创建一个子进程，并在该子进程中针对该终端设备再次执行agetty程序，重复上述过程。
login程序也可以被用户在运行过程中在shell下当作一个命令执行。此时它可以被用随时从一个用户切换成另一个用户。如果执行时没有给出参数，则login就会显示输入用户名的提示信息。如果用户不是超级用户（root），并且/etc/目录下存在一个名为nologin的文件，那么该文件中的信息就会被显示出来，此次登录过程也随即被终止。
如果在/etc/usertty文件中对该用户指定了特殊的访问限制，那么这些限制要求必须满足。如果是一个超级用户，那么所使用的登录tty设备必须是在/etc/securetty文件中指定的。
在所有这些条件满足之后，login同样也会要求用户输入密码并对其进行检查。如果.hushlogin存在的话，login就会执行一个“安静”的登录过程，也即不检查是否有邮件，也不显示上次登录时间和motd文件中的信息。否则如果/var/log/lastlog文件存在的话，就会显示其中的最后登录时间。
如果用户键入的密码正确，则login就会把当前工作目录（Currend Work Directory）修改成口令文件中指定的该用户的起始工作目录。并把对该终端设备的访问权限修改成用户读/写和组写，设置进程的组ID。然后利用所得到的信息初始化环境变量信息，例如起始目录（HOME=）、使用的shell程序（SHELL=）、用户名（USER=和LOGNAME=）和系统执行程序的默认路径序列（PATH=）。接着显示/etc/motd文件（message-of-the-day）中的文本信息，并检查并显示该用户是否有邮件的信息。最后login程序改变成登录用户的用户ID并执行口令文件中该用户项中指定的shell程序，如bash或csh等。
如果口令文件/etc/passwd中该用户项中没有指定使用哪个shell程序，系统则会使用默认的/bin/sh程序。如果口令文件中也没有为该用户指定用户起始目录的话，系统就会使用默认的根目录/。有关login程序的一些执行选项和特殊访问限制的说明，请参见Linux系统中的在线手册页（man 8 login）。

shell程序是一个复杂的命令行解释程序，是当用户登录系统进行交互操作时执行的程序。它是用户与计算机进行交互操作的地方。它获取用户输入的信息，然后执行命令。用户可以在终端上向shell直接进行交互输入，也可以使用shell脚本文件向shell解释程序输入。在Linux系统中，目前常用的shell有：
Bourne Again Shell,/bin/bash
C shell,/bin/csh（或tcsh）
BSD shell/bin/ash（或bsh）
在登录过程中，系统（login）会从口令文件用户对应登录项的最后一个字段知道应该为用户执行哪个shell程序。
shell程序中实现了一个具有流控制结构的语言，使用相当广泛。目前这些shell程序都朝着与IEEE POSIX 1003.2兼容的方向发展，因此它们各自虽然各自有自己的特点，但基本功能已经越来越相象。本书主要介绍bash的工作原理和实现机制，其它几种shell的实现机制与之类似。
在登录过程中login开始执行shell时，所带参数argv[0]的第一个字符是’-’，表示该shell是作为一个登录shell被执行。此时该shell程序会根据该字符，执行某些与登录过程相应的操作。登录shell会首先从/etc/profile文件以及.profile文件（若存在的话）读取命令并执行。如果在进入shell时设置了ENV环境变量，或者在登录shell的.profile文件中设置了该变量，则shell下一步会从该变量命名的文件中读去命令并执行。因此用户应该把每次登录时都要执行的命令放在.profile文件中，而把每次运行shell都要执行的命令放在ENV变量指定的文件中。设置ENV环境变量的方法是把下列语句放在你起始目录的.profile文件中。
ENV=$HOME/.anyfilename; export ENV
在执行shell时，除了一些指定的可选项以外，如果还指定了命令行参数，则shell会把第一个参数看作是一个脚本文件名并执行其中的命令，而其余的参数则被看作是shell的位置参数（$1、$2等）。否则shell程序将从其标准输入中读取命令。
在执行shell程序时可以有很多选项，请参见Linux系统中的有关sh的在线手册页
中的说明。
** linux中source exec和shell script的区别
exec和source都属于linux内部命令，在bash下输入man exec或者man source可
以查看所有的内部命令信息。

bash  shell的，命令分为两类：外部命令和内部命令。外部命令是通过系统调
用或者独立的程序实现的，如sed awk等，内部命令是由特殊文件格式(.def)来
实现，如cd history等

fork是linux的系统调用，用来创建子进程，环境变量只能单向从父进程传给子
进程。不管子进程的环境变量如何变化，都不会影响父进程的环境变量。

有两种方式执行shell scripts,一种是新产生一个shell, 然后执行响应的shell
scripts;一种是在当前shell下执行，不再启用其他shell。

新产生一个shell然后再执行scripts的方法是在scripts文件开头加入以下语句
#！/bin/sh
这种方法先启用新的shell，然后在其下执行命令。

另外一种就是source命令，不再产生新的shell, 而在当前shell下执行一条命令。

source命令和. 命令是一样的
由于所有执行结果均于当前shell内完成，若script的环境有所改变，当然也会
改变当前环境了

在bash下输入man source，找到source命令解释处，可以看到解释"Read and
execute commands from filename in the current shell environment and
..."。从中可以知道，source命令是在当前进程中执行参数文件中的各个命令，
而不是另起子进程(或sub-shell)。

在bash下输入man exec，找到exec命令解释处，可以看到有"No new process is
created."这样的解释，这就是说exec命令不产生新的子进程。那么exec与
source的区别是什么呢？

shell的内建命令exec将并不启动新的shell，而是用要被执行命令替换当前的shell进程，并且将老进程的环境清理掉，而且exec命令后的其它命令将不再执行。
因此，如果你在一个shell里面，执行exec ls那么，当列出了当前目录后，这个shell就自己退出了，因为这个shell进程已被替换为仅仅执行ls命令的一个进程，执行结束自然也就退出了。
exec也是让script在同一个进程上执行，但是原有进程则被结束了。
也就是简而言之：原有进程会否终止，就是exec与source/fork的最大差异了。

** fcntl系统调用
功能描述：根据文件描述词来操作文件的特性。

用法：
int fcntl(int fd, int cmd);
int fcntl(int fd, int cmd, long arg);
int fcntl(int fd, int cmd, struct flock *lock);

参数：
fd：文件描述词
cmd：操作命令
arg：供命令使用的参数
lock：同上

fcntl函数有5种功能：
1.复制一个现有的描述符（cmd=F_DUPFD）.
2.获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD).
3.获得／设置文件状态标记(cmd=F_GETFL或F_SETFL).
4.获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN).
5.获得／设置记录锁(cmd=F_GETLK,F_SETLK或F_SETLKW).

F_DUPFD ：复制文件描述词 。
FD_CLOEXEC ：设置close-on-exec标志。如果FD_CLOEXEC位是0，执行execve的过程中，文件保持打开。反之则关闭。
F_GETFD ：读取文件描述词标志。
F_SETFD ：设置文件描述词标志。
F_GETFL ：读取文件状态标志。
F_SETFL ：设置文件状态标志。
其中O_RDONLY， O_WRONLY， O_RDWR， O_CREAT，  O_EXCL， O_NOCTTY 和
O_TRUNC不受影响，

能更改的标志有 O_APPEND，O_ASYNC， O_DIRECT， O_NOATIME 和 O_NONBLOCK。

七.  F_GETLK, F_SETLK 和 F_SETLKW ：获取，释放或测试记录锁，使用到的参数是以下结构体指针：F_SETLK：在指定的字节范围获取锁（F_RDLCK, F_WRLCK）或释放锁（F_UNLCK）。如果和另一个进程的锁操作发生冲突，返回 -1并将errno设置为EACCES或EAGAIN。

F_SETLKW：行为如同F_SETLK，除了不能获取锁时会睡眠等待外。如果在等待的过程中接收到信号，会即时返回并将errno置为EINTR。
F_GETLK：获取文件锁信息。
F_UNLCK：释放文件锁。

为了设置读锁，文件必须以读的方式打开。为了设置写锁，文件必须以写的方式打开。为了设置读写锁，文件必须以读写的方式打开。

等等... ...

** linux进程
*** 进程组
每个进程除了有一个进程ID之外，还属于一个进程组，每个进程组有一个唯一的
进程组ID，用pid_t getpgrp(void);函数可以获取组ID

每个进程组都可以有一个组长进程，组长进程的标志是，其进程组ID等于其进程
ID，只要进程组有还有一个进程存在，进程组就存在
*** 守护进程
守护进程也称为精灵进程是生存期较长的一种进程，它们常常在系统自举时启动，
仅在系统关闭时才终止。
系统进程依赖于操作系统实现。父进程ID为0的各进程通常是内核进程，它们作
为系统自举过程的一部分而启动，init是此种进程的例外，它是内核在自举时启
动的用户层命令。内核进程是特殊的，通常存在于系统的整个生命周期中。它们
以超级用户的特权运行，无控制终端，无命令行。

进程1通常是init， 它是一个系统守护进程，负责启动各运行层次特定的系统服
务。这些服务通常是在它们自己拥有的守护进程的帮助下实现的。

inetd守护进程xinetd，它侦听系统网络接口，以便取得来自网络的对各种网络
服务进程的请求。
*** 进程间通信
大多数进程间通信，通常限于同一台主机的各个进程间的IPC,最后两种，即套接
字和STREAMS,是仅有的两种支持不同主机上各个进程间IPC的类型。
**** 管道
管道道是UNIX系统中IPC的最古老形式，所有UNIX系统都提供此种通信机制。
1. 历史上它们是半双工的，现在某些系统提供全双工管道
2. 通常一个管道由一个进程创建，然后该进程调用fork，此后父子进程之间就
   可以应用该管道
FIFO命名管道没有2的这种限制，可以在任意进程间通信
源代码实现如下：
#+BEGIN_EXAMPLE
#include <apue.h>

int main(void)
{
    int n;
    int fd[2];
    pid_t pid;
    char line[MAXLINE];
    if(pipe(fd)<0)
        err_sys("pipe error");
    if(pid=for()<0)
        err_sys("fork error");
    else if(pid>0)
    {
        close(fd[0]);
        write(fd[1], "hello world\n", 12);
    }
    else
    {
        close(fd[1]);
        read(fd[0], line, MAXLINE);
        write(STDOUT_FILENO,line,n);
    }
    exit(0);
}
#+END_EXAMPLE
在上面的例子中，直接对管道描述符调用read和write，更好的方法时将管道描
述符复制为标准输入和标准输出。在此之后通常子进程执行另一个程序，该程序
或者从标准输入读数据，或者将数据写至标准输出。

管道的使用：
单个进程的管道几乎没有用处，一般情况下，用户创建父子两个进程，即父进程创建pipe后接着调用 fork（）函数，这样就创建了父进程到子进程（或者反向）的管道。下面考虑父进程到子进程的管道：fork之后父进程所有打开的文件描述符都被复制给子进程，也就是说，父子进程每个打开的相同描述符共享一个文件表项，父进程关闭管道的读端（filedes[0]），子进程关闭管道的写端（filedes[1]），这样，对于管道，父进程负责写数据，子进程负责读数据。
当管道的一端被关闭后，下列两条规则起作用：
　　（1）当读一个写端已经关闭的管道，在所有数据都被读取后，read返回0，以表示达到文件末尾；
　　（2）当写一个读端已经关闭的管道，则产生信号SIGPIPE。
　　根据APUE，借用系统已经存在的分页程序（如more或者less），通过管道直
接将文件内容送到分页程序，代码如下：

#+BEGIN_EXAMPLE
#include <stdlib.h>
 #include <unistd.h>
 #include <sys/wait.h>
 #include <string.h>

 #define MAXLINE 1024
 #define DEF_PAGER "/bin/more"

 int main(int argc, char *argv[])
 {
     int count;
     int fd[2];
     pid_t pid;
     char line[MAXLINE];
     char *pager, *argv0;
     FILE *fp;

     if((fp = fopen(argv[1], "r")) == NULL)
       perror("fopen");

     if(pipe(fd) < 0)
       perror("pipe");

     if((pid = fork()) < 0)
       perror("fork");
     else if(pid > 0) {
         close(fd[0]);
         while(fgets(line, MAXLINE, fp) != NULL) {
             count = strlen(line);
             write(fd[1], line, count);
         }
         if(ferror(fp))
           perror("fgets");
         close(fd[1]);
         if(waitpid(pid, NULL, 0) < 0)
           perror("waitpid");
         exit(0);
     } else {
         close(fd[1]);
         /* 将管道复制为标准输入 */
         if(fd[0] != STDIN_FILENO) {
             if(dup2(fd[0], STDIN_FILENO) != STDIN_FILENO)
               perror("dup2");
             close(fd[0]);
         }
         if((pager = getenv("PAGER")) == NULL)    //通常是/bin/more
           pager = DEF_PAGER;
         if((argv0 = strrchr(pager, '/')) != NULL)   //这里得到程序名
       字more
             argv0++;
         else
           argv0 = pager;
         if(execl(pager, argv0, NULL) < 0)
           perror("execl");
     }
     exit(0);
 }
#+END_EXAMPLE
在这个程序中，父进程创建管道后，调用fork产生子进程，父进程首先关闭读端，运用fgets将文件内容读入，并写入管道；子进程关闭写端，并将标准输入和fd[0]共享同一个文件表项，这样分页程序就能够利用管道中的数据。

**** FIFO命名管道
管道应用的一个重大限制是它没有名字，因此，只能用于具有亲缘关系的进程间
通信，在命名管道中，它提供了一个路径名与之关联，以FIFO的文件形式存在于
文件系统中，这样即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问
该路径，就能彼此通过FIFO相互通信，因此，通过FIFO不相关的进程也能交换数
据，值得注意的是，FIFO严格遵循先进先出，对管道及FIFO的读总是从开始处返
回数据。

FIFO是一个文件类型，stat结构中st_mode指明一个文件结点是不是一个FIFO，
可以使用宏S_ISFIFO来测试这一点。

FIFO依然是半双工的。

创建FIFO的函数如下：
#include <sys/stat.h>
int mkfifo(const char * name, mode_t mode);
成功返回0，失败返回-1

| 名称     | mkfifo                                           |
|----------+--------------------------------------------------|
| 功能     | 创建有名管道                                     |
| 头文件   | #include <sys/types.h>                           |
| 函数原型 | int mkfifo(const char * pathname, mode_t mdoe)   |
| 参数     | pathname表示管道的路径  mode_t表示管道的读写情况 |
| 返回值   | 成功返回0，失败返回-1                            |

参数pathname指出想要创建的FIFO路径，参数mode指定创建的FIFO访问模式。这个访问会与当前进程的umask进程运算，以产生实际应用的权限模式。
mkfifo返回-1时表示创建过程中遇到某种错误，此时会设置errno，用户可以检测errno来取得进一步信息：
EACCES： 路径所在的目录不允许执行权限
EEXIST：路径已经存在，这时包括路径是一个符号链接，无论它是悬空还没有悬空。
ENAMETOOLONG：要么全部的文件名大于PATH_MAX，要么是单独的文件名大于NAME_MAX。在GNU系统里没有这个文件名长度的限制，但在其它系统里可能存在。
ENOENT：目录部分不存在，或者是一个悬空链接。
ENOTDIR：目录部分不一个目录。
EROFS：路径指向一个只读的文件系统。

mkfifo的第一个参数是一个已经存在的路径名时，会返回EEXIST错误
所以一般典型的调用代码首先会检查是否返回该错误，如果确实返回该错误，那
么只要调用打开FIFO的函数就可以了
一般文件的I/O函数都可以用于FIFO，如close、read、write等等。

使用命令man 3 mkfifo可以查看此函数信息
FIFO创建后，可以像普通文件一样对其进行访问。Linux下一个同名命令mkfifo
用于创建FIFO，例如：
$mkfifo /tmp/fifo
$cat /tmp/fifo
程序阻塞。
再打开一个shell，执行
$echo hello > /tmp/fifo
前一个程序返回，显示hello

下面用一个简答 程序，演示FIFO IPC的用法

该程序分为两部分：
server程序创建一个FIFO，并从FIFO读取字符，转换成大写后输出到屏幕
client程序读取用户输入并写入FIFO.

server
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>
#define FIFO_PATH "/tmp/myfifo"

int main()
{
    int ret;
    char buffer;
    /* 创建命名管道 */
    ret=mkfifo(FIFO_PATH, 0777);
    /* 打开命名管道 */
    int fd=open(FIFO_PATH, O_RDONLY);
    /* 成功打开命名管道返回0，否则返回-1 */
    if(fd==-1)
    {
        printf("error\n");
        return -1;
    }
    while(1)
    {
        /* 从管道中读数据，当没有数据的时候阻塞 */
        int nread=read(fd,&buffer,1);
        if(nread>0)
            /* 将字符转换为大写然后输出 */
            printf("%c\n",toupper(buffer));
    }
    return 0;
}
#+END_EXAMPLE

client
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#define FIFO_PATH "/tmp/myfifo"

int main()
{
    /* 设置缓冲区 */
    /* if(setvbuf(stdin,NULL,_IONBF,0)!=0) */
    /*     err_sys("setvbuf error"); */
    /* if(setvbuf(stdout,NULL,_IOLBF,0)!=0) */
    /*     err_sys("setvbuf error"); */
    int fd;
    /* 打开指定的命名管道 */
    fd=open(FIFO_PATH, O_WRONLY);
    /* 成功打开返回0 */
    if(fd==-1)
    {
        printf("error\n");
        return -1;
    }
    int c;
    /* 持续从标准输入读取字符，然后写入管道中 */
    while(c=getchar())
    {
        write(fd,&c,1);
    }

    return 0;
}
#+END_EXAMPLE

先启动server程序，再运行client，随便输入些字符。
server端将在屏幕上显示转换为大写后的输入字符。

1. 命名管道的打开规则
   如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开，则
   当前打开操作将成功返回，否则，可能阻塞直到有相应进程为写而打开该
   FIFO(当前打开操作设置了阻塞表示)；或者，如果当前打开操作没有设置阻
   塞标志，则将成功返回

   如果当前打开操作是为写而打开FIFO时，如果已经有相应进程为读而打开该
   FIFO，则当前打开操作成功返回；否则，可能阻塞直到有相应进程为读而打
   开该FIFO（当前打开操作设置了阻塞标志）；或者返回ENXIO错误(当前打开
   操作没有设置阻塞标志)

2. 命名管道的读写规则
   如果有进程写打开FIFO，且当前FIFO内没有数据，则对于设置了阻塞标志的
   读操作来说，将一直阻塞。对于没有设置阻塞标志读操作来说则返回-1，当
   前errno值为EAGAIN，提醒以后再试

   对于设置了阻塞标志的读操作说，造成阻塞的原因有两种：当前FIFO内有数
   据，但有其它进程在读这些数据；另外就是FIFO内没有数据。解阻塞的原因
   则是FIFO中有新的数据写入，不论信写入数据量的大小，也不论读操作请求
   多少数据量。

   读打开的阻塞标志只对本进程第一个读操作施加作用，如果本进程中有多个
   读操作序列，则在第一个读操作被唤醒并完成读操作后，其它将要执行的读
   操作将不再阻塞，即使在执行读操作时，FIFO中没有数据也一样（此时，读
   操作返回0）。

   如果没有进程写打开FIFO，则设置了阻塞标志的读操作会阻塞。

   向FIFO中写入数据：
   1. 对于设置了阻塞标志的写操作：
   当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果
   此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当
   缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。

   当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO缓
   冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请
   求写的数据后返回。

   2. 对于于没有设置阻塞标志的写操作：
   当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果当前FIFO空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；如果当前FIFO空闲缓冲区不能够容纳请求写入的字节数，则返回EAGAIN错误，提醒以后再写。
   当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。在
   写满所有FIFO空闲缓冲区后，写操作返回。
**** 消息队列
**** 信号量
**** 共享存储器
共享内存是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程共享
内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A
可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同
一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。

采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：一次从输入
文件到共享内存区，另一次从共享内存区到输出文件。

进程之间在通信时，会一直保持共享区域，直到通信完毕为止，这样，数据内容
一直保持在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射
时才写回文件的，因此采用共享内存的通信方式效率是非常高的。

Linux的2.2.x内核支持多种共享内存方式，如mmap()系统调用，Posix共享内存，以及系统V共享内存。

#mmap()及其相关系统调
mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件
被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必
再调用read()，write（）等操作。

mmap()系统调用并不是完全为了用于共享内存而设计的，它本身提供了不同于一
般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而
Posix或系统V的共享内存IPC则纯粹用于共享目的

1. mmap()系统调用形式如下：
void* mmap ( void * addr , size_t len , int prot , int flags , int fd , off_t offset )
参数fd为即将映射到进程空间的文件描述字，一般由open()返回，同时，fd可以指定为-1，此时须指定flags参数中的MAP_ANON，表明进行的是匿名映射（不涉及具体的文件名，避免了文件的创建及打开，很显然只能用于具有亲缘关系的进程间通信）。
len是映射到调用进程地址空间的字节数，它从被映射文件开头offset个字节开
始算起。prot 参数指定共享内存的访问权限。可取如下几个值的或：PROT_READ
（可读） , PROT_WRITE （可写）, PROT_EXEC （可执行）,PROT_NONE（不可访
问）。flags由以下几个常值指定：MAP_SHARED ,MAP_PRIVATE , MAP_FIXED，其
中，MAP_SHARED , MAP_PRIVATE必选其一，而MAP_FIXED则不推荐使用。

offset参数一般设为0，表示从文件头开始映射。

参数addr指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此
时选择起始地址的任务留给内核来完成。函数的返回值为最后文件映射到进程空
间的地址，进程可直接操作起始地址为该值的有效地址。

2. 系统调用mmap()用于共享内存的两种方式
（1）使用普通文件提供的内然后再调用mmap()
#+BEGIN_EXAMPLE
#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
struct people{
    char name;
    int age;
};

// map a normal file as shared mem:
int main(int argc, char** argv)
{
    int fd,i;
    people *p_map;
    char temp;
    /* open the identify file */
    fd=open(argv[1],O_CREAT|O_RDWR|O_TRUNC,00777);
    /* change the file offset, so that the file's size is
     * sizeof(people)*5 */
    lseek(fd, sizeof(people)*5-1,SEEK_SET);
    /* write a null char into the file */
    write(fd,"",1);
    /* 做内存映射，映射的空间大小为sizeof(peopel)*10 */
    p_map = (people*) mmap( NULL,sizeof(people)*10,PROT_READ|PROT_WRITE,
                            MAP_SHARED,fd,0 );
    close( fd );
    /* 关闭文件描述符，并直接对内存进行操作，这些操作会映射到文件中 */
    temp = 'a';
    for(i=0; i<10; i++)
    {
        temp += 1;
        /* 修改成员变量的值 */
        memcpy(&((*(p_map+i)).name), &temp, 1);
        (*(p_map+i)).age = 20+i;
    }
    printf(" initialize over \n ");
    sleep(10);
    /* 解除映射 */
    munmap( p_map, sizeof(people)*10 );
    printf( "umap ok \n" );
}

#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

struct people{
char name;
int  age;
};

// map a normal file as shared mem:
int main(int argc, char** argv)
{
    int fd,i;
    people *p_map;
    /* 打开文件 */
    fd=open( argv[1],O_CREAT|O_RDWR,00777 );
    /* 对指定文件进行映射 */
    p_map = (people*)mmap(NULL,sizeof(people)*10,PROT_READ|PROT_WRITE,
                          MAP_SHARED,fd,0);
    /* 读取映射文件中的内容 */
    for(i = 0;i<10;i++)
        printf( "name: %c age %d;\n",(*(p_map+i)).name, (*(p_map+i)).age );
    /* 解除映射 */
    munmap( p_map,sizeof(people)*10 );
    return 0;
}
#+END_EXAMPLE
这个例子中包括了两个子进程，它们通过把同一个文件映射到自己的内存空间进
行读写操作，来实现进程间通信。
第一个进程打开或创建了一个文件，并把文件的长度设置为5个people结构大小，
然后从mmap()的返回地址开始，设置了10个people结构，注意这里的映射地址空
间大于文件大小。

第二个进程只是简单的映射一个文件，并以people数据结构的格式从mmap()返回
的地址处读取10个people结构，并输出读取的值，然后解除映射

程序的运行结果得出结论：
+最终被映射文件的内容的长度不会超过文件本身的初始大小，即映射不能改变文
件的大小；
+可以用于进程通信的有效地址空间大小大体上受限于被映射文件的大小，但不
完全受限于文件大小。打开文件被截短为5个people结构大小，而在第一个进程
中初始化了10个people数据结构，在恰当时候（map_normalfile1输出initialize over 之后，输出umap ok之前）调用map_normalfile2会发现map_normalfile2将输出全部10个people结构的值

注意：在linux中，内存的保护是以页为基本单位的，即使被映射文件只有一个字节大小，内核也会为映射分配一个页面大小的内存。当被映射文件小于一个页面大小时，进程可以对从mmap()返回地址开始的一个页面大小进行访问，而不会出错；但是，如果对一个页面以外的地址空间进行访问，则导致错误发生，后面将进一步描述。因此，可用于进程间通信的有效地址空间大小不会超过文件大小及一个页面大小的和。

+ 文件一旦被映射后，调用mmap()的进程对返回地址的访问是对某一内存区域的
  访问，暂时脱离了磁盘上文件的影响。所有对mmap()返回地址空间的操作只在
  内存中有意义，只有在调用了munmap()后或者msync()时，才把内存中的相应
  内容写回磁盘文件，所写内容仍然不能超过文件的大小。


（2）使用特殊文件提供匿名内存映射：适用于具有亲缘关系的进程之间； 由于父子进程特殊的亲缘关系，在父进程中先调用mmap()，然后调用fork()。那么在调用fork()之后，子进程继承父进程匿名映射后的地址空间，同样也继承mmap()返回的地址，这样，父子进程就可以通过映射区域进行通信了。注意，这里不是一般的继承关系。一般来说，子进程单独维护从父进程继承下来的一些变量。而mmap()返回的地址，却由父子进程共同维护。
对于具有亲缘关系的进程实现共享内存最好的方式应该是采用匿名内存映射的方
式。此时，不必指定具体的文件，只要设置相应的标志即可
#+BEGIN_EXAMPLE
#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
typedef struct{
  char name[4];
  int  age;
}people;
main(int argc, char** argv)
{
  int i;
  people *p_map;
  char temp;
  p_map=(people*)mmap(NULL,sizeof(people)*10,PROT_READ|PROT_WRITE,
       MAP_SHARED|MAP_ANONYMOUS,-1,0);
  if(fork() == 0)
  {
    sleep(2);
    for(i = 0;i<5;i++)
      printf("child read: the %d people's age is %d\n",i+1,(*(p_map+i)).age);
    (*p_map).age = 100;
    munmap(p_map,sizeof(people)*10); //实际上，进程终止时，会自动解除映射。
    exit();
  }
  temp = 'a';
  for(i = 0;i<5;i++)
  {
    temp += 1;
    memcpy((*(p_map+i)).name, &temp,2);
    (*(p_map+i)).age=20+i;
  }
  sleep(5);
  printf( "parent read: the first people,s age is %d\n",(*p_map).age );
  printf("umap\n");
  munmap( p_map,sizeof(people)*10 );
  printf( "umap ok\n" );
}
#+END_EXAMPLE
3. 解除内存映射munmap()

int munmap( void * addr, size_t len )
该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生

4. 共享内存数据写回磁盘msync()
int msync ( void * addr , size_t len, int flags)
一般说来，进程在映射空间的对共享内容的改变并不直接写回到磁盘文件中，往往在调用munmap（）后才执行该操作。可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。

5. 对mmap()返回地址的访问
linux采用的是页式管理机制。对于用mmap()映射普通文件来说，进程会在自己
的地址空间新增一块空间，空间大小由mmap()的len参数指定，注意，进程并不
一定能够对全部新增空间都能进行有效访问。进程能够访问的有效地址大小取决
于文件被映射部分的大小。简单的说，能够容纳文件被映射部分大小的最少页面
个数决定了进程从mmap()返回的地址开始，能够有效访问的地址空间大小。超过
这个空间大小，内核会根据超过的严重程度返回发送不同的信号给进程。可用如
下图示说明：
[[file:pic/mmap.gif]]

注意：文件被映射部分而不是整个文件决定了进程能够访问的空间大小，另外，
如果指定文件的偏移部分，一定要注意为页面大小的整数倍。

**** 网络套接字socket
http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html

套接字是一种进程间的通信方法，与以往介绍的进程间通信方式不同的是，它并
不局限与同一台计算机的资源。

主要API
htons();          //将short类型的值从主机字节序转换为网络字节序
inet_addr();      //将IP地址字符串转换为long类型的网络字节序
gethostbyname();  //获得与该域名对应的IP地址
inet_ntoa();      //将long类型的网络字节序转换成IP地址字符串

套接字的工作过程（服务器端）：
1. 服务端通过socket系统调用创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，不能与其它进程共享。
2. 服务器进程使用bind系统调用给套接字命名，本地套接字的名字是linux文件
   系统的文件名，一般放在/tmp或者/usr/tmp目录下。
3. 接下来，服务器进程开始等待客户连接到这个命名套接字，调用listen创建
   一个等待队列以便存放来自客户的连接。
4. 服务器通过accept系统调用来接收客户的连接。此时会产生一个与原有的命
   名套接字不同的套接字，它仅用于与这个特定的客户通信，而命名套接字则
   被保留下来继续处理来自其它客户的连接。

套接字的工作过程（客户端）：
1. 调用socket创建一个未命名的套接字
2. 将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。服务
   器的命名套接字中需要指明IP地址和端口号。
3. 一旦建立了连接，就可以像使用底层文件描述符那样用套接字进行双向的数
   据通信。

服务器端代码：
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main(int argc, char *argv[])
{
    int server_sockfd;//服务器端套接字
    int client_sockfd;//客户端套接字
    int len;
    struct sockaddr_in my_addr;     //服务器网络地址结构体
    struct sockaddr_in remote_addr; //客户端网络地址结构体
    int sin_size;
    char buf[BUFSIZE];  //数据传送的缓冲区
    memset(&my_addr,0,sizeof(my_addr)); //数据初始化--清零
    my_addr.sin_family=AF_INET; //设置为IP通信
    my_addr.sin_addr.s_addr=INADDR_ANY;//服务器IP地址--允许连接到所有本地地址上
    my_addr.sin_port=htons(8000); //服务器端口号

    /*创建服务器端套接字--IPv4协议，面向连接通信，TCP协议*/
    if((server_sockfd=socket(PF_INET,SOCK_STREAM,0))<0)
    {
        perror("socket");
        return 1;
    }

        /*将套接字绑定到服务器的网络地址上*/
    if (bind(server_sockfd,(struct sockaddr *)&my_addr,sizeof(struct sockaddr))<0)
    {
        perror("bind");
        return 1;
    }

    /*监听连接请求--监听队列长度为5*/
    listen(server_sockfd,5);

    sin_size=sizeof(struct sockaddr_in);

    /*等待客户端连接请求到达*/
    if((client_sockfd=accept(server_sockfd,(struct sockaddr *)&remote_addr,&sin_size))<0)
    {
        perror("accept");
        return 1;
    }
    //打印客户端的IP地址
    printf("accept client %s/n",inet_ntoa(remote_addr.sin_addr));
    len=send(client_sockfd,"Welcome to my server/n",21,0);//发送欢迎信息

    /*接收客户端的数据并将其发送给客户端--recv返回接收到的字节数，send返回发送的字节数*/
    while((len=recv(client_sockfd,buf,BUFSIZ,0))>0))
    {
        buf[len]='/0';
        printf("%s/n",buf);
        if(send(client_sockfd,buf,len,0)<0)
        {
            perror("write");
            return 1;
        }
    }
    close(client_sockfd);
    close(server_sockfd);
        return 0;
}
#+END_EXAMPLE
客户端代码：
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main(int argc, char *argv[])
{
	int client_sockfd;
	int len;
	struct sockaddr_in remote_addr; //服务器端网络地址结构体
	char buf[BUFSIZ];  //数据传送的缓冲区
	memset(&remote_addr,0,sizeof(remote_addr)); //数据初始化--清零
	remote_addr.sin_family=AF_INET; //设置为IP通信
	remote_addr.sin_addr.s_addr=inet_addr("127.0.0.1");//服务器IP地址
	remote_addr.sin_port=htons(8000); //服务器端口号

	/*创建客户端套接字--IPv4协议，面向连接通信，TCP协议*/
	if((client_sockfd=socket(PF_INET,SOCK_STREAM,0))<0)
	{
		perror("socket");
		return 1;
	}

	/*将套接字绑定到服务器的网络地址上*/
	if(connect(client_sockfd,(struct sockaddr *)&remote_addr,sizeof(struct sockaddr))<0)
	{
		perror("connect");
		return 1;
	}
	printf("connected to server/n");
	len=recv(client_sockfd,buf,BUFSIZ,0);//接收服务器端信息
         buf[len]='/0';
	printf("%s",buf); //打印服务器端信息

	/*循环的发送接收信息并打印接收信息--recv返回接收到的字节数，send返回发送的字节数*/
	while(1)
	{
		printf("Enter string to send:");
		scanf("%s",buf);
		if(!strcmp(buf,"quit")
			break;
		len=send(client_sockfd,buf,strlen(buf),0);
		len=recv(client_sockfd,buf,BUFSIZ,0);
		buf[len]='/0';
		printf("received:%s/n",buf);
	}
	close(client_sockfd);//关闭套接字
         return 0;
}
#+END_EXAMPLE

UDP协议
服务器端代码：
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main(int argc, char *argv[])
{
	int server_sockfd;
	int len;
	struct sockaddr_in my_addr;   //服务器网络地址结构体
         struct sockaddr_in remote_addr; //客户端网络地址结构体
	int sin_size;
	char buf[BUFSIZ];  //数据传送的缓冲区
	memset(&my_addr,0,sizeof(my_addr)); //数据初始化--清零
	my_addr.sin_family=AF_INET; //设置为IP通信
	my_addr.sin_addr.s_addr=INADDR_ANY;//服务器IP地址--允许连接到所有本地地址上
	my_addr.sin_port=htons(8000); //服务器端口号

	/*创建服务器端套接字--IPv4协议，面向无连接通信，UDP协议*/
	if((server_sockfd=socket(PF_INET,SOCK_DGRAM,0))<0)
	{
		perror("socket");
		return 1;
	}

        /*将套接字绑定到服务器的网络地址上*/
	if (bind(server_sockfd,(struct sockaddr *)&my_addr,sizeof(struct sockaddr))<0)
	{
		perror("bind");
		return 1;
	}
	sin_size=sizeof(struct sockaddr_in);
	printf("waiting for a packet.../n");

	/*接收客户端的数据并将其发送给客户端--recvfrom是无连接的*/
	if((len=recvfrom(server_sockfd,buf,BUFSIZ,0,(struct sockaddr *)&remote_addr,&sin_size))<0)
	{
		perror("recvfrom");
		return 1;
	}
	printf("received packet from %s:/n",inet_ntoa(remote_addr.sin_addr));
	buf[len]='/0';
	printf("contents: %s/n",buf);
	close(server_sockfd);
        return 0;
}
#+END_EXAMPLE
客户端代码：
#+BEGIN_EXAMPLE
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main(int argc, char *argv[])
{
	int client_sockfd;
	int len;
        struct sockaddr_in remote_addr; //服务器端网络地址结构体
	int sin_size;
	char buf[BUFSIZ];  //数据传送的缓冲区
	memset(&remote_addr,0,sizeof(remote_addr)); //数据初始化--清零
	remote_addr.sin_family=AF_INET; //设置为IP通信
	remote_addr.sin_addr.s_addr=inet_addr("127.0.0.1");//服务器IP地址
	remote_addr.sin_port=htons(8000); //服务器端口号

         /*创建客户端套接字--IPv4协议，面向无连接通信，UDP协议*/
	if((client_sockfd=socket(PF_INET,SOCK_DGRAM,0))<0)
	{
		perror("socket");
		return 1;
	}
	strcpy(buf,"This is a test message");
	printf("sending: '%s'/n",buf);
	sin_size=sizeof(struct sockaddr_in);

	/*向服务器发送数据包*/
	if((len=sendto(client_sockfd,buf,strlen(buf),0,(struct sockaddr *)&remote_addr,sizeof(struct sockaddr)))<0)
	{
		perror("recvfrom");
		return 1;
	}
	close(client_sockfd);
	return 0;
}
#+END_EXAMPLE

** linux线程
*** 线程简介
就像每个进程有一个进程ID一样，每个线程也有一个线程ID，进程ID在整个系统
中是唯一的，但线程ID不同，线程ID只在它所属的进程环境中有效。

进程ID用pid_t数据类型来表示，是一个非负整数。线程ID则用pthread_t数据类
型来表示，实现的时候可以用一个结构来代表pthread_t数据类型，所以可移植
的操作系统实现不能把它作为整数来处理，这里使用一个函数来对两个线程Id进
行比较
int pthread_equal(pthread_t tid1, pthread_t tid2);
若相等则返回非0值，否则返回0

线程可以通过pthread_t pthread_self(void);函数来获得自身的线程ID

linux使用clone系统调用来实现pthread_create, clone系统调用创建子进程，
这个子进程可以共享父进程一定数量的执行环境，这个数量是可配置的。

*** 线程终止
如果进程中任意线程调用了exit,_exit或者_Exit,那么整个进程就会终止。于此
类似，如果信号的默认动作是终止进程，那么把该信号发送到线程会终止整个进
程。

单个线程可以通过下列三种方式退出，在不终止整个进程的情况下停止它的控制
流。
1. 线程只是从启动例程中返回，返回值是线程的退出码
2. 线程可以被同一进程中的的其它线程取消
3. 线程调用pthread_exit.

*** 线程同步
多个线程在运行中会访问到同一个资源，这样就产生了资源的竞争，为了解决这
个问题，必须使用加锁机制
1. 互斥量
可以通过使用pthread的互斥接口保护数据，确保同一时间只有一个线程访问数
据。互斥量从本质上说是一把锁，对互斥量加锁以后，任何其它试图再次加锁的
线程将会被阻塞直到当当前线程释放该互斥锁。如果释放互斥锁时有多个线程阻
塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的
线程可以对互斥量加锁，其它线程将会看到互斥锁依然被锁住，只能回去再次等
待它重新变为可用，在这种方式下，每次只有一个线程可以向前执行。

避免死锁：可以规定互斥量的加锁顺序来避免死锁

读写锁：读写锁类似与互斥量，不过读写锁允许更高的并发性，互斥量要么是锁
住状态要么是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有
三种状态:读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个
线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。

* Linux常见问题
** /etc/shadow文件被覆盖 su故障
重启电脑在root账户下执行passwd kong重新生成账户密码, 执行 sudo passwd root重新生成ro
ot的密码,然后su就可以恢复工作
** 文件的每一行后边多一个^M
这个问题是由于Unix和Window的换行符不一样造成的Unix中是以\n作为换行，
Window中是以\n\r作为换行符，一个直接结果是，Unix系统下的文件在Window中
打开都是一行，Window下的文件在Unix下打开的话在 每行的结尾可能会多出一
个^M符号

在Unix下转换Window下文件的两种方式：
1. 命令dos2unix test.file
2. 去掉'\r', 用命令sed -i 's/\r//' test.file
ok!!

** archlinux签名错误
error: GPGME error: No data

最近archlinux　yaourt的时候, 老是遇到＂GPGME error: No data＂的错误…
翻遍了论坛, 试着重新更新pacman-key, 删除/et/pacman.d/gnupg; /var/lib/pacman/sync/*db.sig*　等均不管用;

(1) 修改/etc/pacman.conf
设置全局SigLevel = Never
这个方案可以解决问题, 但是禁用了签名验证, 不推荐. 至少我的版本是在某次升级后, networkmanager挂掉了. = =!

(2) 或者修改mirrorlist
后来将mirrorlist用官方原始的那份覆盖过来了下, 问题解决了..
估计是之前配置的国内哪个源签名的问题. = =!

ref:
1. pacman-key

https://wiki.archlinux.org/index.php/Pacman-key#Master_keys
