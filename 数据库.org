* 数据库事务
数据库事务是指作为单个逻辑工作单元执行的一系列操作，一个逻辑工作单元要
成为事务，必须满足所谓的ACID属性(原子性、一致性、隔离性和持久性)


原子性： 事务必须是原子工作单元，对于其数据修改，要么全都执行，要么全
都不执行
一致性： 事务在完成时，必须使所有数据都保持一致。事务结束时，所有的内
部数据结构如B树索引或者双向链表都必须是正确的
隔离性： 由并发事务所做的修改必须与任何其它事务所做的修改隔离。事务查
看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一
事务修改它之后的状态，事务不会查看中间状态的数据。 由于高度隔离会限制
可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量，防
止数据丢失
持久性： 事务完成之后，它对于系统的影响是永久的，该修改即使出现致命的
系统故障也将一直保持

事务是并发控制的基本单位，保证事务ACID特性的是事务处理的重要任务，而并
发有可能会破坏其ACID特性

由于并发操作带来的数据不一致性包括：丢失数据修改，读脏数据、不可重复读、
产生幽灵数据
1. 丢失数据修改，后一个事务的修改会覆盖掉前一个事务的操作
2. 读脏数据，指前一个事务修改完数据之后，又由于某些原因进行回滚操作，
   则在这中间读到的数据就是脏数据，与数据库中的数据不一致
3. 不可重复读， 事务T1读取数据之后，T2进行更新操作，则T1无法读取前一次
   的结果
4. 幽灵数据，T1从数据库中读取某些记录之后，T2删除了部分记录，当T1再次
   去读的时候发现记录消失了

* 隔离级别
4个事务隔离级别 串行化、可重复读、读已提交、读未提交，为了实现隔离级别，
数据库通常采用锁机制。一般在编程的时候只需要设置隔离等级，至于具体采用什么锁则由数据库来设置

读未提交： 一个事务读取了另一个事务修改但是还未提交的数据
读已提交： 一个事务读取了数据，然后第二个事务更新了数据，则第二次读的
时候就和第一次有所不同
Repeatable Read：所有被Select获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况。
Serializable：所有事务都一个接一个地串行执行，这样可以避免幻读（phantom reads）

REPEATABLE READ    锁定该事务以任何方式引用的所有行
锁定查询中使用的所有数据以防止其他用户更新数据，但是其他用户可以将新的幻像行插入数据集，且幻像行包括在当前事务的后续读取中。因为并发低于默认隔离级别，所以应只在必要时才使用该选项。
也就是说你在同一事务中在不同时间读取同一条记录时,每次读的应该是一样的
不会被别的语句修改,但其他语句还可以insert

SERIALIZABLE
在数据集上放置一个范围锁，以防止其他用户在事务完成之前更新数据集或将行
插入数据集内。


一般的DBMS系统，默认都会使用读提交作为默认隔离级别，如Oracle、SQL
Server等，而MySQL却使用可重复读作为默认隔离级别，隔离级别越高，能解决
的数据一致性问题就越多，理论上性能损耗更大，可并发性越低

MS_SQL:
--事务一
set transaction isolation level serializable
begin tran
insert into test values('xxx')

--事务二
set transaction isolation level read committed
begin tran
select * from test

--事务三
set transaction isolation level read uncommitted
begin tran
select * from test

在查询分析器中执行事务一后，分别执行事务二，和三。结果是事务二会等待，
而事务三则会执行、

一般处理并发问题时的步骤：
1、开启事务。
2、申请写权限，也就是给对象(表或记录)加锁。
3、假如失败，则结束事务，过一会重试。
4、假如成功，也就是给对象加锁成功，防止其他用户再用同样的方式打开。
5、进行编辑操作。
6、写入所进行的编辑结果。
7、假如写入成功，则提交事务,完成操作。
8、假如写入失败，则回滚事务，取消提交。
9、(7.8)两步操作已释放了锁定的对象，恢复到操作前的状态。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|----------+------+------------+------|
| 读未提交 | YES  | YES        | YES  |
| 读已提交 | NO   | YES        | YES  |
| 可重复读 | NO   | NO         | YES  |
| 串行化   | NO   | NO         | NO   |

* 数据库锁的类型和粒度
数据库通常采用锁机制。一般在编程的时候只需要设置隔离等级，至于具体采用
什么锁则由数据库来设置

在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁
（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读
取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利
用这两种基本的锁类型来对数据库的事务进行并发控制。

共享锁：共享锁锁定的资源可以被其它用户读取，但其它用户无法修改它
独占锁：只允许进行锁定操作的程序使用，其它任何对他的操作均不会被接收

锁粒度是被封锁目标的大小，粒度小则并发度高，但开销大，封锁粒度大则并发
性低但开销小

sql server支持的粒度可分为行、页、键、键范围、索引、表、或数据库获取锁

悲观锁：正如其名，指对数据被外界修改持保守态度，因此在整个数据处理过程
中，将数据处于锁定状态，直到锁释放后其它用户才可以修改，悲观锁的实现往往依靠数据库提供的锁机制.

相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下
依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数
据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。

乐观锁，大多是基于数据版本（Version）记录机制实现。
乐观锁的工作原理：读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。








* 数据库引擎
所谓数据库引擎是应用程序和数据存储之间的一种接口，它将与数据有关的内存
管理、游标管理和错误管理等具体而复杂的细节问题抽象为一个既高度一致而又
简化的编程接口。

mysql上的数据库引擎：
isam、myisam、InnorDB

isam:ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。ISAM
的两个主要不足之处在于，它不支持事务处理，也不能够容错

myisam:MyISAM是MySQL的ISAM扩展格式和缺省的数据库引擎。除了提供ISAM里所
没有的索引和字段管理的大量功能，MyISAM还使用一种表格锁定的机制，来优化
多个并发的读写操作。
MyISAM强调了快速读取操作

InnoDB: 造就了MySQL的灵活性，支持事务处理和外来键，但是它的执行速度比
myisam要慢的多

